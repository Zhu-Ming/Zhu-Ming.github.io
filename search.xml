<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GIT移动文件导致任务管理器找不到服务</title>
    <url>/2019/12/11/GIT%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6%E5%AF%BC%E8%87%B4%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E6%89%BE%E4%B8%8D%E5%88%B0%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<blockquote>
<p>移动GIT默认文件夹导致任务管理其找不到对应的服务。<br>1打开cmd,输入regedit</p>
</blockquote>
<blockquote>
<p>2找到HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory<br>\background\shell\git_gui\command，修改它的路径为现在的<br>git-gui.exe程序所在的路径。</p>
</blockquote>
<blockquote>
<p>3找到HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\background\shell\git_shell\command修改路径为现在的git-bash.exe所在的路径。</p>
</blockquote>
<blockquote>
<p>完成</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/12/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><a id="more"></a>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>PTA-Basic-1006</title>
    <url>/2019/09/15/PTA-Basic-1006/</url>
    <content><![CDATA[<h1 id="1006-换个格式输出整数"><a href="#1006-换个格式输出整数" class="headerlink" title="1006 换个格式输出整数"></a>1006 换个格式输出整数</h1><p>让我们用字母 B 来表示“百”、字母 S 表示“十”，用 12…n 来表示不为零的个位数字 n（&lt;10），换个格式来输出任一个不超过 3 位的正整数。例如 234 应该被输出为 BBSSS1234，因为它有 2 个“百”、3 个“十”、以及个位的 4。</p>
<p>输入格式：<br>    每个测试输入包含 1 个测试用例，给出正整数 n（&lt;1000）。</p>
<p>输出格式：<br>    每个测试用例的输出占一行，用规定的格式输出 n。</p>
<p>输入样例 1：</p>
<pre><code>234</code></pre><p>输出样例 1：</p>
<pre><code>BBSSS1234</code></pre><p>输入样例 2：</p>
<pre><code>23</code></pre><p>输出样例 2：</p>
<pre><code>SS123</code></pre><hr>
<p>分析：</p>
<p>1因为输入的数字小于1000，所以定义一个数组长度为3的整型数组，存放数字的个位，十位，百位。</p>
<p>2再定义一个足够大的数组存放结果。</p>
<p>3倒叙遍历存放数字的数组，按按百对应下标为2，十位对应的下标为1，个位对应的下标的为0，分别对处理。</p>
<p>4注意一定要在最后将字符数组的最后置为’\0’,否则会输出错误。</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> result[<span class="number">1000</span>];</span><br><span class="line">   <span class="keyword">int</span> number;</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;number);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> num[<span class="number">3</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">   <span class="keyword">while</span>(number)&#123;</span><br><span class="line">       num[n++]=number%<span class="number">10</span>;</span><br><span class="line">       number=number/<span class="number">10</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> <span class="built_in">step</span>=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">       <span class="keyword">int</span> time=num[i];</span><br><span class="line">       <span class="keyword">if</span>(time==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;time;j++)&#123;</span><br><span class="line">           result[<span class="built_in">step</span>++]=<span class="string">'B'</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;time;j++)&#123;</span><br><span class="line">           result[<span class="built_in">step</span>++]=<span class="string">'S'</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;time;j++)&#123;</span><br><span class="line">           result[<span class="built_in">step</span>++]=j+<span class="string">'1'</span>;</span><br><span class="line">       	&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">   result[<span class="built_in">step</span>]=<span class="string">'\0'</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%s"</span>,result);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种思路：</p>
<p>分析：</p>
<p>利用字符串长度判断输入的是几位数，再利用字符串倒置输出对应的题目要求符号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i,j;</span><br><span class="line">   <span class="keyword">char</span> n[<span class="number">4</span>];</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">"%s"</span>,n);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span>(i=<span class="built_in">strlen</span>(n);i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">       <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=(n[<span class="built_in">strlen</span>(n)-i]-<span class="string">'0'</span>);j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(i==<span class="number">3</span>)</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">"B"</span>);</span><br><span class="line">           <span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">"S"</span>);</span><br><span class="line">           <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">"%d"</span>,j);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/huaxuewan/article/details/85778884" title="参考资料">https://blog.csdn.net/huaxuewan/article/details/85778884</a></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1005</title>
    <url>/2019/09/15/PTA-Basic-1005/</url>
    <content><![CDATA[<p>卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。</p>
<p>当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 n=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”，如果 n 不能被数列中的其他数字所覆盖。</p>
<p>现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。</p>
<p>输入格式：<br>    每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 K (&lt;100)，第 2 行给出 K 个互不相同的待验证的正整数 n (1&lt;n≤100)的值，数字间用空格隔开。</p>
<p>输出格式：<br>    每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。</p>
<p>输入样例：</p>
<pre><code>6
3 5 6 7 8 11</code></pre><p>输出样例：</p>
<pre><code>7 6</code></pre><hr>
<p>分析：</p>
<p>1定义一个数组存储输入的数字。</p>
<p>2遍历数组的每一个数字，对它们每个数字求其覆盖的数字，对被覆盖的每个数字一一与输入的数组对比，如果有相同的就将处于该位置的数字置为1，因为题目中提到数字在（1&lt;n&lt;=100）之间，所以便利该数组时可以遇到一就跳过去。</p>
<p>3最后数组中只剩下不能被数组中的其他元素所覆盖的数字了，这就是要求的关键数的数组。</p>
<p>4对这个数组进行排序，直到第一个为1的下标。</p>
<p>5按要求输出下标前面的数字。</p>
<hr>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
//此处是比较函数，用于对处理后的数组排序。
int compare(const void *a,const void *b){
if(*(int *)a&gt;*(int *)b)
return -1;
if(*(int *)a&lt;*(int *)b)
return 1;
return 0;
}
int main(void){
int number;
scanf(&quot;%d&quot;,&amp;number);
int num[number];
int i=0;
while(i&lt;number){ 
    scanf(&quot;%d&quot;,&amp;num[i++]);
}
for(i=0;i&lt;number;i++){
    int n=num[i];
    if(n==1){
        continue;
    }
    while(1){
     if(n==1){
        break;
    }
    if(n%2==0){
        n=n/2;
    }else{
        n=(3*n+1)/2;
    }
    for(int m=0;m&lt;number;m++){
        if(n==num[m]){
            num[m]=1;// 因为数组的数字各不相同，找到被覆盖的即可跳出循环
            break;
        }
      }
    }
}
qsort(num,sizeof(num)/sizeof(int),sizeof(int),compare);
int flag=1;
for(int i=0;i&lt;number;i++）{
    if(num[i]==1)break;
    if(flag){
        flag=0;
        printf(&quot;%d&quot;,num[i]);
    }else{
        printf(&quot; %d&quot;,num[i]);
    }
}
return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1003</title>
    <url>/2019/09/15/PTA-Basic-1003/</url>
    <content><![CDATA[<p>“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。</p>
<p>得到“答案正确”的条件是：</p>
<p>字符串中必须仅有 P、 A、 T这三种字符，不可以包含其它字符；]<br>任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串;</p>
<p>如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a、 b、 c 均或者是空字符串，或者是仅由字母 A 组成</p>
<p>的字符串。</p>
<p>现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。</p>
<p>输入格式：<br>每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 n (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。</p>
<p>输出格式：<br>每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出 YES，否则输出 NO。</p>
<p>输入样例：</p>
<p>8</p>
<p>PAT</p>
<p>PAAT</p>
<p>AAPATAA</p>
<p>AAPAATAAAA</p>
<p>xPATx</p>
<p>PT</p>
<p>Whatever</p>
<p>APAAATAA</p>
<p>输出样例：</p>
<p>YES</p>
<p>YES</p>
<p>YES</p>
<p>YES</p>
<p>NO</p>
<p>NO</p>
<p>NO</p>
<p>NO<br>题目分析：</p>
<p>1必须含有P,A,T这三个字符，且不含其他字符。<br>2字符P ,T 的数目必须为1；<br>3字符P与T之间的字符数*P字符前A的个数必须等于字符T后的A的数目。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;

#include&lt;string.h&gt;

int main(void){

int number;
scanf(&quot;%d&quot;,&amp;number);
char str[100];
int i=0;
char* result[number];
while(i&lt;number){
    int number_p=0;
    int number_t=0;
    int flag1=0,flag2=0,flag3=0;
    int index_p=0,index_t=0;
    scanf(&quot;%s&quot;,str);
    getchar();
    for(int j=0;j&lt;strlen(str);j++){
        if(str[j]==&apos;A&apos;){
            flag1=1
        }
        if(str[j]==&apos;P&apos;){
            flag2=1;
            number_p++;
        }
        if(str[j]==&apos;T&apos;){
            flag3=1;
            number_t++;
        }
        if(str[j]!=&apos;A&apos;&amp;&amp;str[j]!
=&apos;T&apos;&amp;&amp;str[j]!=&apos;P&apos;){
            break;
        }else{
            if(str[j]==&apos;P&apos;){
                index_p=j;
            }
            if(str[j]==&apos;T&apos;){
                index_t=j;
                break;
            }
        }
    }
    if(index_p!=index_t&amp;&amp;(index_p*(index_t-index_p-1)==(strlen(str)-index_t-1))

&amp;&amp;flag1&amp;&amp;flag2&amp;&amp;flag3&amp;&amp;number_p==1&amp;&amp;number_t==1){
        result[i]=&quot;YES&quot;;
    }else{
        result[i]=&quot;NO&quot;;
    }
    i++;
}
for(int i=0;i&lt;number;i++){
    printf(&quot;%s\n&quot;,result[i]);
}
return 0;

} </code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>PTA</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1008</title>
    <url>/2019/12/12/PTA-Basic-1008/</url>
    <content><![CDATA[<hr>
<p>title: PTA-Basic-1008<br>date: 2019-09-16 23:58:39<br>categories:<br>     - [算法与数据结构,PTA]<br>tags:<br>    - 算法<br>    - C语言</p>
]]></content>
  </entry>
  <entry>
    <title>PTA-Basic-1012</title>
    <url>/2019/09/17/PTA-Basic-1012/</url>
    <content><![CDATA[<p>给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字：</p>
<p>A<br>​1<br>​​  = 能被 5 整除的数字中所有偶数的和；<br>A<br>​2<br>​​  = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 n<br>​1<br>​​ −n<br>​2<br>​​ +n<br>​3<br>​​ −n<br>​4<br>​​ ⋯；<br>A<br>​3<br>​​  = 被 5 除后余 2 的数字的个数；<br>A<br>​4<br>​​  = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位；<br>A<br>​5<br>​​  = 被 5 除后余 4 的数字中最大数字。<br>输入格式：<br>每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N，随后给出 N 个不超过 1000 的待分类的正整数。数字间以空格分隔。</p>
<p>输出格式：<br>对给定的 N 个正整数，按题目要求计算 A<br>​1<br>​​ ~A<br>​5<br>​​  并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。</p>
<p>若其中某一类数字不存在，则在相应位置输出 N。</p>
<p>输入样例 1：</p>
<p>13 1 2 3 4 5 6 7 8 9 10 20 16 18</p>
<p>输出样例 1：</p>
<p>30 11 2 9.7 9</p>
<p>输入样例 2：</p>
<p>8 1 2 4 5 6 7 9 16</p>
<p>输出样例 2：</p>
<p>N 11 2 N 9</p>
<p>分析：<br>输入：一个代表个数的数字，后面跟着相应个数的数字。<br>输出：</p>
<p>1number%2==0&amp;&amp;number%5==0的数字的和</p>
<p>2number%5==1的差项和a1-a2+a3-a4…</p>
<p>3number%5==2的个数</p>
<p>4number%5==3的数字的平均数，保留一位小数。</p>
<p>5number%5==4的所有数字中的最大数。</p>
<p>以上所有输出如果不存在时，输出‘N’;</p>
<p>思路：</p>
<p>1输入时就处理数字，对每个数字判断，存放在二维数组，第一行存储个数，第二行存储结果。</p>
<p>2输出时一定要注意，当输出平均数时，要注意到我们使用的时整型数组，因此就要进行相应的处理。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
static int result[2][5];
int num=0;
scanf(&quot;%d&quot;,&amp;nu2m);
int number;
int i=0;
int flag=1;
while(i&lt;num){
    scanf(&quot;%d&quot;,&amp;number);
    if(number%2==0&amp;&amp;number%5==0){
        result[0][0]++;
        result[1][0]=result[1][0]+number;
    }
    if(number%5==1){
        result[0][1]++;
        result[1][1]=result[1][1]+flag*number;
        flag=-flag;
    }
    if(number%5==2){
        result[0][2]++;
        result[1][2]++;
    }
    if(number%5==3){
        result[0][3]++;
        result[1][3]=result[1][3]+number;
    }
    if(number%5==4){
        result[0][4]++;
        result[1][4]=result[1][4]&gt;=number?result[1][4]:number;
    }
    i++;
}

for(i=0;i&lt;4;i++){
    if(i==3){
        if(result[0][i]==0){
            printf(&quot;N &quot;);
        }else{
            printf(&quot;%.1f &quot;,result[1][i]*1.0/result[0][i]);
        }
        continue;
    }
    if(result[0][i]==0){
        printf(&quot;N &quot;);
    }
    else{
        printf(&quot;%d &quot;,result[1][i]);
    }
}
if(result[0][i]==0){
        printf(&quot;N&quot;);
    }
    else{
        printf(&quot;%d&quot;,result[1][i]);
    }
return 0; 
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT_Basic-1004</title>
    <url>/2019/09/15/PTA-Basic-1004/</url>
    <content><![CDATA[<p>读入 n（&gt;0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。</p>
<p>输入格式：<br>每个测试输入包含 1 个测试用例，格式为</p>
<p>第 1 行：正整数 n</p>
<p>第 2 行：第 1 个学生的姓名 学号 成绩</p>
<p>第 3 行：第 2 个学生的姓名 学号 成绩<br>  … … …<br>第 n+1 行：第 n 个学生的姓名 学号 成绩</p>
<p>其中姓名和学号均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。</p>
<p>输出格式：<br>对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。</p>
<p>输入样例：</p>
<p>3</p>
<p>Joe Math990112 89</p>
<p>Mike CS991301 100</p>
<p>Mary EE990830 95</p>
<p>输出样例：</p>
<p>Mike CS991301</p>
<p>Joe Math990112</p>
<hr>
<p>分析：</p>
<p>1直接使用结构体的两个对象存储最大和最小分数对应的学生。<br>2在输入时比较分数的大小，比最大的的的就将最大的重新赋值，比最小的小的就将最小的重新赋值。</p>
<p>##代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
typedef struct student{
char name[11];
char id[11];
int score;
};
int main(void){
int number;
scanf(&quot;%d&quot;,&amp;number);
getchar();
struct student max,min;
number--;
scanf(&quot;%s %s %d&quot;,max.name,max.id,&amp;max.score);
min=max;
while(number--){
    getchar();
    char name[11];
    char id[11];
    int score;
    scanf(&quot;%s %s %d&quot;,name,id,&amp;score);
    if(max.score&lt;score){
        strcpy(max.name,name);
        strcpy(max.id,i
        max.score=score;
    }
    if(min.score&gt;score){
        strcpy(min.name,name);
        strcpy(min.id,id);
        min.score=score;
    }
}
printf(&quot;%s %s\n&quot;,max.name,max.id);
printf(&quot;%s %s&quot;,min.name,min.id);
return 0;
}
``</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1014</title>
    <url>/2019/09/18/PTA-Basic-1014/</url>
    <content><![CDATA[<p>大侦探福尔摩斯接到一张奇怪的字条：我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间星期四 14:04，因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 D，代表星期四；第 2 对相同的字符是 E ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示）；后面两字符串第 1 对相同的英文字母 s 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。</p>
<p>输入格式：</p>
<p>输入在 4 行中分别给出 4 个非空、不包含空格、且长度不超过 60 的字符串。</p>
<p>输出格式：</p>
<p>在一行中输出约会的时间，格式为 DAY HH:MM，其中 DAY 是某星期的 3 字符缩写，即 MON 表示星期一，TUE 表示星期二，WED 表示星期三，THU 表示星期四，FRI 表示星期五，SAT 表示星期六，SUN 表示星期日。题目输入保证每个测试存在唯一解。</p>
<p>输入样例：</p>
<p>3485djDkxh4hhGE </p>
<p>2984akDfkkkkggEdsb </p>
<p>s&amp;hgsfdk </p>
<p>d&amp;Hyscvnm</p>
<p>输出样例：</p>
<p>THU 14:04</p>
<p>分析：</p>
<p>输入：四个字符串，一行一个。</p>
<p>处理：首先找出前面两个字符串中的第一个相应位置上相等的大写字母，并记录字母；以第一个大写字母相同的为第一个相等的字符，找出第二对相等的且为（0-9或A-N）中的字符，并记录。<br>在找出后两个字符串中对应位置上相等字符的下标，并记录。</p>
<p>输出：见题目（注意：小时&lt;10时要补0，分钟小于&lt;10要补0）；</p>
<p>思路：</p>
<p>定义四个字符数组，存储数据。<br>遍历前两字符串，找出第一个字符（大写字母），第二个字符（0-9或A-N）；<br>遍历后面两个字符串，找到第一个对应位置上相等的字符下标。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main(void){
    char str[4][800];
    int i=0;
    while(i&lt;4){
    scanf(&quot;%s&quot;,str[i++]);
    getchar();
    }
    char* res;
    int flag=1;
    int h=0;
    for(i=0;i&lt;strlen(str[1])&amp;&amp;i&lt;strlen(str[0]);i++){
    if(!flag&amp;&amp;((str[0][i]&gt;=&apos;A&apos;&amp;&amp;str[0][i]&lt;=&apos;N&apos;)||(str[0][i]&gt;=&apos;0&apos;&amp;&amp;str[0][i]&lt;=&apos;9&apos;))&amp;&amp;str[0][i]==str[1][i]){
            switch(str[0][i]){
                case &apos;0&apos;:case &apos;1&apos;:case &apos;2&apos;:case &apos;3&apos;:
                case &apos;4&apos;:case &apos;5&apos;:case &apos;6&apos;:case &apos;7&apos;:
                case &apos;8&apos;:case &apos;9&apos;:h=str[0][i]-&apos;0&apos;;break;
                default:h=str[0][i]-&apos;A&apos;+10;break;
            }
            break;
        }
        if(flag&amp;&amp;str[0][i]&gt;=&apos;A&apos;&amp;&amp;str[0][i]&lt;=&apos;G&apos;&amp;&amp;str[0][i]==str[1][i]){
            flag=0;
            switch(str[0][i]){
                case &apos;A&apos;:res=&quot;MON&quot;;break;
                case &apos;B&apos;:res=&quot;TUE&quot;;break;
                case &apos;C&apos;:res=&quot;WED&quot;;break;
                case &apos;D&apos;:res=&quot;THU&quot;;break;
                case &apos;E&apos;:res=&quot;FRI&quot;;break;
                case &apos;F&apos;:res=&quot;SAT&quot;;break;
                case &apos;G&apos;:res=&quot;SUN&quot;;break;
            }
        }
    }
    for(i=0;i&lt;strlen(str[2])&amp;&amp;i&lt;strlen(str[3]);i++){
        if(((str[2][i]&lt;=&apos;z&apos;&amp;&amp;str[2][i]&gt;=&apos;a&apos;)||(str[2][i]&lt;=&apos;Z&apos;&amp;&amp;str[2][i]&gt;=&apos;A&apos;))&amp;&amp;str[2][i]==str[3][i]){
            break;
        }
    }
    printf(&quot;%s %02d:%02d&quot;,res,h,i);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1009</title>
    <url>/2019/09/17/PTA-Basic-1009/</url>
    <content><![CDATA[<p>给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。</p>
<p>输入格式：<br>测试输入包含一个测试用例，在一行内给出总长度不超过 80 的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用 1 个空格分开，输入保证句子末尾没有多余的空格。</p>
<p>输出格式：<br>每个测试用例的输出占一行，输出倒序后的句子。</p>
<p>输入样例：</p>
<p>Hello World Here I Come</p>
<p>输出样例：</p>
<p>Come I Here World Hello</p>
<p>分析：<br>1给出一句话，要求单词顺序不变，倒序输出所有单词。<br>首先要输出最后一个单词，接着是倒数第二个… ,直到到达首单词。</p>
<p>思路：双指针算法。<br>1用一个字符数组存储输入的字符串；使用两个字符指针，一个用来指向空格的位置，另一个用来输出空格与空格或者空格与     ‘\0’    之间的单词（字符串的末尾会存放一个‘\0’）,然后继续此操作直到到达第一个单词，第一个单词不输出（因题目格式要求）<br>2另外输出第一个单词。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#define MAX 81
int main(void){
char str[MAX];
char *p,*q;
gets(str);
for(p=str+strlen(str)-1;p!=str;p--){//输出到第一个单词停止。
    if(*p==&apos; &apos;){//如果读到一个空格，说明，一个单词已经结束。
        for(q=p+1;*q!=&apos; &apos;&amp;&amp;*q;q++){
            printf(&quot;%c&quot;,*q);
        }
        printf(&quot; &quot;);
    }
}
for(p=str;*p!=&apos; &apos;&amp;&amp;*p;p++){
//此处判定条件中的*p是为了防止输入一个单词时造成死循环。因为只输入一个单词时，也作为字符串末尾也会加上一个&apos;\0&apos;.
    printf(&quot;%c&quot;,*p);
}
return 0;
}</code></pre><p>######如果有更好的思路欢迎交流。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1011</title>
    <url>/2019/09/17/PTA-Basic-1011/</url>
    <content><![CDATA[<p>给定区间 [−2^31,2^31] 内的 3 个整数 A、B 和 C，请判断 A+B 是否大于 C。</p>
<p>输入格式：</p>
<p>输入第 1 行给出正整数 T (≤10)，是测试用例的个数。随后给出 T 组测试用例，每组占一行，顺序给出 A、B 和 C。整数间以空格分隔。</p>
<p>输出格式：</p>
<p>对每组测试用例，在一行中输出 Case #X: true 如果 A+B&gt;C，否则输出 Case #X: false，其中 X 是测试用例的编号（从 1 开始）。</p>
<p>输入样例：</p>
<p>4</p>
<p>1 2 3</p>
<p>2 3 4</p>
<p>2147483647 0 2147483646</p>
<p>0 -2147483648 -2147483647</p>
<p>输出样例：</p>
<p>Case #1: false</p>
<p>Case #2: true</p>
<p>Case #3: true</p>
<p>Case #4: false</p>
<p>分析：</p>
<p>输入：个数，每一行一一组数据。<br>输出：判定结果。</p>
<p>难点：<br>数字的长度过大，使用long long 类型，long long对应的长度为（-2^63,2^63 -1）足够存储数据，与加后的数据了;</p>
<p>对定义后的字符数组赋值时，必须使用strcpy（）函数</p>
<p>思路：输入一组比较一组，结果存放在字符数组中。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main(void){
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    long long number1,number2,number3;
    char result[n][8];
    int i=0;
    while(i&lt;n){
        scanf(&quot;%ld %ld %ld&quot;,&amp;number1,&amp;number2,&amp;number3);
        strcpy(result[i],(number1+number2&gt;number3)?&quot;true&quot;:&quot;false&quot;);
        i++;
    }
    for(i=0;i&lt;n;i++){
        printf(&quot;Case #%d: %s\n&quot;,i+1,result[i]);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1013</title>
    <url>/2019/09/17/PTA-Basic-1013/</url>
    <content><![CDATA[<p>令 P<br>​<br>​​  表示第 i 个素数。现任给两个正整数 M≤N≤10<br>​4<br>​​ ，请输出 P<br>​M<br>​​  到 P<br>​N<br>​​  的所有素数。</p>
<p>输入格式：<br>输入在一行中给出 M 和 N，其间以空格分隔。</p>
<p>输出格式：<br>输出从 P<br>​M<br>​​  到 P<br>​N<br>​​  的所有素数，每 10 个数字占 1 行，其间以空格分隔，但行末不得有多余空格。</p>
<p>输入样例：</p>
<pre><code>5 27</code></pre><p>输出样例：</p>
<pre><code>11 13 17 19 23 29 31 37 41 43
47 53 59 61 67 71 73 79 83 89
97 101 103</code></pre><p>分析：</p>
<p>输入：整型数字n,m;<br>输出：从第n个素数（包含在内）到第m个素数之间的所有素数.十个换一行。</p>
<p>思路：</p>
<p>1写一个判定素数的函数。<br>2for循环从2开始数每当是素数计算素数的变量num就加一，当变量大于等于n时开始输出，大于m时停止输出。<br>3变量num-n+1就是从n开始第几个素数，每当此数字为十的倍数时，就换行。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
int isPrime(int n){
if(n==1)
return 0;
if(n==2)
return 1;
if(n%2==0){
    return 0;
}
for(int i=3;i&lt;sqrt(n+1);i+=2){
    if(n%i==0){
        return 0;
    }
}
return 1;
}
int main(void){
int n,m;
scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
int num=0;
for(int i=2;i&lt;=1000000;i++){
    if(isPrime(i)){
        num++;
        if(num&gt;m){
            break;
        }
        if(num&gt;=n){
            if((num-n+1)%10==0){
            printf(&quot;%d\n&quot;,i);
            continue;
        }
        if(num!=m) 
            printf(&quot;%d &quot;,i);
        else
            printf(&quot;%d&quot;,i);
        } 
    }
}
return 0;
}</code></pre><p>###注意：此算法还可以在进一步优化，这里就不加赘述了。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1010</title>
    <url>/2019/09/17/PTA-Basic-1010/</url>
    <content><![CDATA[<p>设计函数求一元多项式的导数。（注：x<br>​n<br>​​ （n为整数）的一阶导数为nx<br>​n−1<br>​​ 。）</p>
<p>输入格式:<br>以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。</p>
<p>输出格式:<br>以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是 0，但是表示为 0 0。</p>
<p>输入样例:</p>
<pre><code>3 4 -5 2 6 1 -2 0</code></pre><p>输出样例:</p>
<pre><code>12 3 -10 1 6 0</code></pre><p>分析：</p>
<p>一元多项式条件：系数不为0，指数为大于-1的整数即（指数&gt;=0）;</p>
<p>输入：先输入一个系数再输入一个指数，依此重复，指数递减。</p>
<p>输出：格式见题目，输出求一次导后的的多项式对应的系数与指数。</p>
<p>（注意： “零多项式”，最高项指数为0，但是表示为 0 0，除此以外，只要指数不为0，系数为不为无所谓，也要输出。百度解释0多项式就是0）</p>
<p>因为系数一定不为0，所以如果结果中有“零多项式”，那么一定是输入时的指数为0.一旦指数为0，后面就不会再有输入了。</p>
<p>思路：</p>
<p>1读取一对数字再读一个字符。</p>
<p>2如果指数为0就可以判断后面没有输入了。</p>
<p>3不为0就输出对应求导后的数值，并标记一下此多项式不是“0多项式”。</p>
<p>4如果不是0多项式，就不用输出“0 0”了，如果那么前面一定没有输出，那么就要输出此。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
int n,m;
int flag=0;
char ch;
while(1){
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    ch=getchar();
    if(m!=0){
        if(flag)//此处用于判断是否为第一个输出，是就不用输出空格。
            printf(&quot; &quot;);
        printf(&quot;%d %d&quot;,n*m,m-1);
        flag=1;
    }
    if(ch==&apos;\n&apos;){
        break;
    }
}
if(!flag){
    printf(&quot;0 0&quot;);
}
 return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1017</title>
    <url>/2019/09/22/PTA-Basic-1017/</url>
    <content><![CDATA[<p>题目：</p>
<p>本题要求计算 A/B，其中 A 是不超过 1000 位的正整数，B 是 1 位正整数。你需要输出商数 Q 和余数 R，使得 A=B×Q+R 成立。</p>
<p>输入格式：</p>
<pre><code>输入在一行中依次给出 A 和 B，中间以 1 空格分隔。</code></pre><p>输出格式：</p>
<pre><code>在一行中依次输出 Q 和 R，中间以 1 空格分隔。</code></pre><p>输入样例：</p>
<pre><code>123456789050987654321 7</code></pre><p>输出样例：</p>
<pre><code>17636684150141093474 3</code></pre><p>分析：<br>输入：除数为数字，而被除数因为输入的不超过1000位，所以只能用字符串来存储，也就是说这题不能用除法来计算了，只能用字符串模拟除法的原理。</p>
<p>处理：</p>
<pre><code>从高位到低位每一位对被除数取整，并用余数*10加上后一位继续此
操作，并将整数存入结果的字符数组中去（注意如果第一个字符
为‘0’就不存入结果数组中去，否则就加入到数组中去。）继续此操
作，最后将‘\0’送入结果数组。</code></pre><p>输出：</p>
<pre><code>如果结果数组长度为0说明整数部分为0，则输出 ‘0 余数’，不为
0，就输出‘字符数组，余数’。</code></pre><p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main(void){
    int number2;
    char number1[1000] ;
    scanf(&quot;%s %d&quot;,number1,&amp;number2);
    int n=0;//余数，初始值为0。
    char result[1000];
    int j=0;
    int i=0;
    while(i&lt;strlen(number1)){
        n=n*10+number1[i]-&apos;0&apos;;//上一位的余数*10加上此位置的数值
        if(j==0&amp;&amp;n/number2==0)
            ;
        else
            result[j++]=n/number2+&apos;0&apos;;//务必要加上‘0’
        n=n%number2;
        i++;
    }
    result[j]=&apos;\0&apos;;//在数组的末尾加上&apos;\0&apos;,这样在输出的时候才会正常结束。
    if(strlen(result)==0){
        printf(&quot;%s %d&quot;,&quot;0&quot;,n);
    } else{
        printf(&quot;%s %d&quot;,result,n);
}
    return 0;
    }</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1016</title>
    <url>/2019/09/18/PTA-Basic-1016/</url>
    <content><![CDATA[<p>正整数 A 的“D<br>​A<br>​​ （为 1 位整数）部分”定义为由 A 中所有 D<br>​A<br>​​  组成的新整数 P<br>​A<br>​​ 。例如：给定 A=3862767，D<br>​A<br>​​ =6，则 A 的“6 部分”P<br>​A<br>​​  是 66，因为 A 中有 2 个 6。</p>
<p>现给定 A、D<br>​A<br>​​ 、B、D<br>​B<br>​​ ，请编写程序计算 P<br>​A<br>​​ +P<br>​B<br>​​ 。</p>
<p>输入格式：<br>输入在一行中依次给出 A、D<br>​A<br>​​ 、B、D<br>​B<br>​​ ，中间以空格分隔，其中 0&lt;A,B&lt;10<br>​10<br>​​ 。</p>
<p>输出格式：</p>
<p>在一行中输出 P<br>​A<br>​​ +P<br>​B<br>​​  的值。</p>
<p>输入样例 1：</p>
<pre><code>3862767 6 13530293 3</code></pre><p>输出样例 1：</p>
<pre><code>399</code></pre><p>输入样例 2：</p>
<pre><code>3862767 1 13530293 8</code></pre><p>输出样例 2：</p>
<pre><code>0</code></pre><p>分析：</p>
<p>输入：数字1 包含的数1 数字2 包含的数2；<br>处理：<br>对数字1不断取余数，判断是否等于包含的数字1，是的话就在和基础上*10+包含的数字一。<br>对数字2的处理同1；<br>输出：<br>输出上述两个操作过后得到的两个数字的和。</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int num1,num2;
    int d1,d2;
    int sum1=0,sum2=0;
    scanf(&quot;%d %d %d %d&quot;,&amp;num1,&amp;d1,&amp;num2,&amp;d2);
    while(num1){
        int n=num1%10;
        num1=num1/10;
        if(n==d1){
            sum1=sum1*10+d1;
        }
    }
    while(num2){
        int n=num2%10;
        num2=num2/10;
        if(n==d2){
            sum2=sum2*10+d2;
        }
    }
    printf(&quot;%d&quot;,sum1+sum2);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1018</title>
    <url>/2019/09/22/PTA-Basic-1018/</url>
    <content><![CDATA[<p>题目：</p>
<p>大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示：</p>
<p><img src="https://images.ptausercontent.com/724da598-b37f-4f1f-99b4-71459654ce3a.jpg" alt="剪刀石头布"><br>现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。</p>
<p>输入格式：<br>输入第 1 行给出正整数 N（≤10<br>​5<br>​​ ），即双方交锋的次数。随后 N 行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C 代表“锤子”、J 代表“剪刀”、B 代表“布”，第 1 个字母代表甲方，第 2 个代表乙方，中间有 1 个空格。</p>
<p>输出格式：<br>输出第 1、2 行分别给出甲、乙的胜、平、负次数，数字间以 1 个空格分隔。第 3 行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有 1 个空格。如果解不唯一，则输出按字母序最小的解。</p>
<p>输入样例：</p>
<pre><code>10
C J
J B
C B
B B
B C
C C
C B
J B
B C
J J</code></pre><p>输出样例：</p>
<pre><code>5 3 2
2 3 5
B B</code></pre><p>分析：</p>
<pre><code>输入：第一行各处要输入的次数，以下接着放置n行的数据。

处理：
定义两个二维整型数组（第一行存储字符，第二行存储对应的数目，以字符‘0’为起点每符合一个就再对应的第二行加一）存储字符对应的Ascall码值（为什么不用字符型？能因为字符型数组的如果加的范围超出字符型就会报错）定义两个变量用来存储甲胜利的次数，与平局的次数。

输出：最后遍历两个二维数组找出字符数最大的下标并记录。</code></pre><p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int time;
    scanf(&quot;%d&quot;,&amp;time);
    int A[2][3]={{'B','C','J'},{0,0,0}};//第一层代表可以出的手势，第二层代表此手势获胜的次数。
    int B[2][3]={{'B','C','J'},{0,0,0}};
    char a,b;
    int number=time;
    int N=0,M=0;
    while(time--){
        getchar();
        scanf(&quot;%c %c&quot;,&amp;a,&amp;b);
        if((a==&apos;C&apos;&amp;&amp;b==&apos;J&apos;)||(a==&apos;J&apos;&amp;&amp;b==&apos;B&apos;)||(a==&apos;B&apos;&amp;&amp;b==&apos;C&apos;)){
            N++;
            switch(a){
                case &apos;B&apos;:  A[1][0]=A[1][0]+1;break;
                case &apos;C&apos;:  A[1][1]=A[1][1]+1;break;
                case &apos;J&apos;:  A[1][2]=A[1][2]+1;break;
            }
        }else if((b==&apos;C&apos;&amp;&amp;a==&apos;J&apos;)||(b==&apos;J&apos;&amp;&amp;a==&apos;B&apos;)||(b==&apos;B&apos;&amp;&amp;a==&apos;C&apos;)){
            M++;
            switch(b){
                case &apos;B&apos;:  B[1][0]=B[1][0]+1;break;
                case &apos;C&apos;:  B[1][1]=B[1][1]+1;break;
                case &apos;J&apos;:  B[1][2]=B[1][2]+1;break;
            }
        }else{
        }
            }
        printf(&quot;%d %d %d\n&quot;,N,number-N-M,M);
        printf(&quot;%d %d %d\n&quot;,M,number-N-M,N);
        int indexN=0;
        int indexM=0;
        for(int i=1;i&lt;3;i++){
            if((A[1][i]-&apos;0&apos;)&gt;(A[1][indexN]-&apos;0&apos;)){
                indexN=i;
            }
            if((B[1][i]-&apos;0&apos;)&gt;(B[1][indexM]-&apos;0&apos;)){
                indexM=i;
            }
        }
        printf(&quot;%c %c&quot;,A[0][indexN],B[0][indexM]);
        return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1020</title>
    <url>/2019/09/22/PTA-Basic-1020/</url>
    <content><![CDATA[<p>月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。</p>
<p>注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45/2 = 94.5（亿元）。</p>
<p>输入格式：</p>
<pre><code>每个输入包含一个测试用例。每个测试用例先给出一个不超过 
1000 的正整数 N 表示月饼的种类数、以及不超过 500（以万吨为
单位）的正整数 D 表示市场最大需求量。随后一行给出 N 个正数
表示每种月饼的库存量（以万吨为单位）；最后一行给出 N 个正
数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。</code></pre><p>输出格式：</p>
<pre><code>对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到

小数点后 2 位。</code></pre><p>输入样例：</p>
<pre><code>3 20
18 15 10
75 72 45</code></pre><p>输出样例：</p>
<pre><code>94.50</code></pre><p>分析：</p>
<pre><code>定义一个结构体:月饼的库存，与月饼的单价。对月饼数组按单价进行快排（降序）。优先用库存卖出贵的月饼。</code></pre><p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct Moon{
    double store;
    double simple_price;
}Moon;
int compare(const void *a,const void *b){
    if((*(struct Moon *)a).simple_price&gt;(*(struct Moon *)b).simple_price)
        return -1;
    if((*(struct Moon *)a).simple_price&lt;(*(struct Moon *)b).simple_price)
        return 1;
    return 0;
}
int main(void){
    int n;
    double max;
    scanf(&quot;%d %lf&quot;,&amp;n,&amp;max);//输入数目，销量。
    struct Moon moon[n];
    int i=0;
    while(n-i){
        scanf(&quot;%lf&quot;,&amp;moon[i].store);//存入库存。
        i++;
    }
    i=0;
    while(n-i){//故弄玄虚
        double sum_price;
        scanf(&quot;%lf&quot;,&amp;sum_price);
        moon[i].simple_price=sum_price/moon[i].store;//通过单个月饼的库存与总价计算单价存入数组。
        i++;
    }
    qsort(moon,sizeof(moon)/sizeof(Moon),sizeof(Moon),compare);//降序排列月饼有限卖出贵的。
    double sum=0;
    for(i=0;i&lt;n;i++){
        if(moon[i].store&gt;=max){
            sum=sum+moon[i].simple_price*max;
            max=0;
            break;
        }else{
            sum+=moon[i].simple_price*moon[i].store;
            max=max-moon[i].store;
        }
        if((max-0)&lt;0.01){//如果剩余销量几乎为0跳出循环。
            break;
        }
    }
    printf(&quot;%.2f&quot;,sum);//保留两位小数。
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1015</title>
    <url>/2019/09/18/PTA-Basic-1015/</url>
    <content><![CDATA[<p>##1015 德才论</p>
<p>宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”</p>
<p>现给出一批考生的德才分数，请根据司马光的理论给出录取排名。</p>
<p>输入格式：<br>输入第一行给出 3 个正整数，分别为：N（≤10<br>​5<br>​​ ），即考生总数；L（≥60），为录取最低分数线，即德分和才分均不低于 L 的考生才有资格被考虑录取；H（&lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 L 的考生也按总分排序，但排在第三类考生之后。</p>
<p>随后 N 行，每行给出一位考生的信息，包括：准考证号 德分 才分，其中准考证号为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。</p>
<p>输出格式：<br>输出第一行首先给出达到最低分数线的考生人数 M，随后 M 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。</p>
<p>输入样例：</p>
<pre><code>14 60 80
10000001 64 90
10000002 90 60
10000011 85 80
10000003 85 80
10000004 80 85
10000005 82 77
10000006 83 76
10000007 90 78
10000008 75 79
10000009 59 90
10000010 88 45
10000012 80 100
10000013 90 99
10000014 66 60</code></pre><p>输出样例：<br>    12<br>    10000013 90 99<br>    10000012 80 100<br>    10000003 85 80<br>    10000011 85 80<br>    10000004 80 85<br>    10000007 90 78<br>    10000006 83 76<br>    10000005 82 77<br>    10000002 90 60<br>    10000014 66 60<br>    10000008 75 79<br>    10000001 64 90</p>
<p>分析：</p>
<pre><code>输入：
第一行：学生数 最低分 优秀线
第二行：学生id 学生道德分 学生专业分。
.....

处理:
定义一个学生结构包括id score1 score2 sum(分数和)
在输入时进行分析符合条件的就存储到相应等级的学生数组。

对每个等级的学生数组进行快排。

输出：
遍历每个等级数组并输出。</code></pre><p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
typedef struct student{
    int id;
    int score_psy;
    int score_pro;
    int sum;
}student;
int compare(const void *a,const void *b){
    student stu1=*((student *)a);
    student stu2=*((student *)b);
    if(stu1.sum&gt;stu2.sum){
        return -1;
    }
    if(stu1.sum&lt;stu2.sum){
        return 1;
    }else{
        if(stu1.score_psy&gt;stu2.score_psy){
            return -1;
        }else if(stu1.score_psy&lt;stu2.score_psy){
            return 1;
        }else{
            if(stu1.id&gt;stu2.id){
                return 1;
            }
            return -1;
        }
    }
}
int main(void){
    int id;
    int score_pro;
    int score_psy;
    int num,s1,s2;
    scanf(&quot;%d %d %d&quot;,&amp;num,&amp;s1,&amp;s2);
    struct student students1[num],students2[num],students3[num],students4[num];
    int n1=0,n2=0,n3=0,n4=0;
    int i=0;
    while(num--){
        scanf(&quot;%d %d %d&quot;,&amp;id,&amp;score_psy,&amp;score_pro);
        if(score_pro&gt;=s1&amp;&amp;score_psy&gt;=s1){
            i++;
            if(score_psy&gt;=s2&amp;&amp;score_pro&gt;=s2){
            students1[n1].id=id;
            students1[n1].score_pro=score_pro;
            students1[n1].score_psy=score_psy;
            students1[n1].sum=score_pro+score_psy;
            n1++;
            }else if(score_pro &lt; s2 &amp;&amp; score_psy &gt;= s2){
            students2[n2].id=id;
            students2[n2].score_pro=score_pro;
            students2[n2].score_psy=score_psy;
            students2[n2].sum=score_pro+score_psy;
            n2++;
            }else if(score_pro &lt; s2 &amp;&amp; score_psy &lt; s2 &amp;&amp;score_psy&gt;=score_pro){
            students3[n3].id=id;
            students3[n3].score_pro=score_pro;
            students3[n3].score_psy=score_psy;
            students3[n3].sum=score_pro+score_psy;
            n3++;
            }else{
            students4[n4].id=id;
            students4[n4].score_pro=score_pro;
            students4[n4].score_psy=score_psy;
            students4[n4].sum=score_pro+score_psy;
            n4++; 
            }
        }
    }
    printf(&quot;%d\n&quot;,i);
    qsort(students1,n1,sizeof(student),compare);
    qsort(students2,n2,sizeof(student),compare);
    qsort(students3,n3,sizeof(student),compare);
    qsort(students4,n4,sizeof(student),compare);
    for(int j=0;j&lt;n1;j++){
        printf(&quot;%d %d %d\n&quot;,students1[j].id,students1[j].score_psy,students1[j].score_pro);
    }
    for(int j=0;j&lt;n2;j++){
        printf(&quot;%d %d %d\n&quot;,students2[j].id,students2[j].score_psy,students2[j].score_pro);
    }
    for(int j=0;j&lt;n3;j++){
        printf(&quot;%d %d %d\n&quot;,students3[j].id,students3[j].score_psy,students3[j].score_pro);
    }
    for(int j=0;j&lt;n4;j++){
        printf(&quot;%d %d %d\n&quot;,students4[j].id,students4[j].score_psy,students4[j].score_pro);
    }
    return 0;
}</code></pre><p>####注意：排序条件：先按总分降序，如果总分相同，就按道德分数降序，如果还相等就按学号升序排。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1019</title>
    <url>/2019/09/22/PTA-Basic-1019/</url>
    <content><![CDATA[<p>题目：</p>
<p>给定任一个各位数字不完全相同的 4 位正整数，如果我们先把 4 个数字按非递增排序，再按非递减排序，然后用第 1 个数字减第 2 个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的 6174，这个神奇的数字也叫 Kaprekar 常数。</p>
<p>例如，我们从6767开始，将得到</p>
<p>7766 - 6677 = 1089<br>9810 - 0189 = 9621<br>9621 - 1269 = 8352<br>8532 - 2358 = 6174<br>7641 - 1467 = 6174<br>… …<br>现给定任意 4 位正整数，请编写程序演示到达黑洞的过程。</p>
<p>输入格式：<br>输入给出一个 (0,10<br>​4<br>​​ ) 区间内的正整数 N。</p>
<p>输出格式：</p>
<pre><code>如果 N 的 4 位数字全相等，则在一行内输出 N - N = 0000；否
则将计算的每一步在一行内输出，直到 6174 作为差出现，输出格式
见样例。注意每个数字按 4 位数格式输出。</code></pre><p>输入样例 1：</p>
<pre><code>6767</code></pre><p>输出样例 1：</p>
<pre><code>7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174</code></pre><p>输入样例 2：</p>
<pre><code>2222</code></pre><p>输出样例 2：</p>
<pre><code>2222 - 2222 = 0000</code></pre><p>分析：</p>
<pre><code>输入：将输入的数字取余存到数组中去然后快排数组，正序逆序生
成两个数字大的减去小的，如果大数与小数相等只输出相减结束循
环或结果为6174结束循环。否则继续循环。</code></pre><p>输出：</p>
<pre><code>计算过程。</code></pre><p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int compare(const void *a,const void *b){
    if(*(int *)a&gt;*(int *)b){
        return -1;
    }else if(*(int *)a&lt;*(int *)b){
        return 1;
    }else{
        return 0;
    }
}
int print(int * p){
    int number1=(*p)*1000+*(p+1)*100+*(p+2)*10+*(p+3);
    int number2=(*p)+*(p+1)*10+*(p+2)*100+*(p+3)*1000;
    int n=number1-number2;
    printf(&quot;%04d - %04d = %04d\n&quot;,number1,number2,n);
    return n;
}
int main(void){
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    int flag=1;
    int result[4];
    while(1){
        for(int i=0;i&lt;4;i++){
        result[i]=n%10;
        n=n/10;
    }
    qsort(result,sizeof(result)/sizeof(int),sizeof(int),compare);
       n=print(result);
       if(n==0||n==6174){
           break;
       }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1022</title>
    <url>/2019/09/22/PTA-Basic-1022/</url>
    <content><![CDATA[<p>输入两个非负 10 进制整数 A 和 B (≤2<br>​30<br>​​ −1)，输出 A+B 的 D (1&lt;D≤10)进制数。</p>
<p>输入格式：<br>输入在一行中依次给出 3 个整数 A、B 和 D。</p>
<p>输出格式：<br>输出 A+B 的 D 进制数。</p>
<p>输入样例：</p>
<pre><code>123 456 8</code></pre><p>输出样例：</p>
<pre><code>1103</code></pre><p>输入：因为数字范围（&lt;=2^31-1）所以用long类型。<br>处理：先计算两数字和，再对其进行不断的取余，并存入字符数组。最后加入一个‘\0’<br>输出：逆序输出。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main(void){
    int a,b,D;
    scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;D);
    int d=a+b;
    char result[1000];
    int i;
    for(i=0;;i++){
        result[i]=d%D+&apos;0&apos;;
        d=d/D;
        if(d==0){
            break;
        }
    }
    result[++i]=&apos;\0&apos;;//便于计算长度
    for(i=strlen(result)-1;i&gt;-1;i--)
    printf(&quot;%c&quot;,result[i]);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1021</title>
    <url>/2019/09/22/PTA-Basic-1021/</url>
    <content><![CDATA[<p>题目：</p>
<p>给定一个 k 位整数 N=d<br>​k−1<br>​​ 10<br>​k−1<br>​​ +⋯+d<br>​1<br>​​ 10<br>​1<br>​​ +d<br>​0<br>​​  (0≤d<br>​i<br>​​ ≤9, i=0,⋯,k−1, d<br>​k−1<br>​​ &gt;0)，请编写程序统计每种不同的个位数字出现的次数。例如：给定 N=100311，则有 2 个 0，3 个 1，和 1 个 3。</p>
<p>输入格式：<br>每个输入包含 1 个测试用例，即一个不超过 1000 位的正整数 N。</p>
<p>输出格式：<br>对 N 中每一种不同的个位数字，以 D:M 的格式在一行中输出该位数字 D 及其在 N 中出现的次数 M。要求按 D 的升序输出。</p>
<p>输入样例：</p>
<pre><code>100311</code></pre><p>输出样例：</p>
<pre><code>0:2
1:3
3:1</code></pre><p>分析：<br>输入：因为数字的长度不定，所以用字符数组存储。<br>处理：定义一个二维数组，第一行存储0-9，第二存储出现的次数（初始化为0）。遍历字符数组对应数字加1即可。<br>输出：一行一个，输出出现次数不为0的数字以及次数。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main(void){
    char n[1000];
    scanf(&quot;%s&quot;,&amp;n);
    int number[10]={0};
    for(int i=0;i&lt;strlen(n);i++){
        number[n[i]-&apos;0&apos;]++;
    }
   for(int j=0;j&lt;10;j++){
            if(number[j]!=0){
                printf(&quot;%d:%d\n&quot;,j,number[j]);
            }
        }
        return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1023</title>
    <url>/2019/09/22/PTA-Basic-1023/</url>
    <content><![CDATA[<p>题目：</p>
<p>给定数字 0-9 各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意 0 不能做首位）。例如：给定两个 0，两个 1，三个 5，一个 8，我们得到的最小的数就是 10015558。</p>
<p>现给定数字，请编写程序输出能够组成的最小的数。</p>
<p>输入格式：</p>
<pre><code>输入在一行中给出 10 个非负整数，顺序表示我们拥有数字 0、数字 
1、……数字 9 的个数。整数间用一个空格分隔。10 个数字的总个数不
超过 50，且至少拥有 1 个非 0 的数字。</code></pre><p>输出格式：</p>
<pre><code>在一行中输出能够组成的最小的数。</code></pre><p>输入样例：</p>
<pre><code>2 2 0 0 0 3 0 0 1 0</code></pre><p>输出样例：</p>
<pre><code>10015558</code></pre><p>输入：</p>
<p>遍历数字，将相应的整型数组加1（下标代表数字，值代表次数）。优先输出0但是首字符不能为0然后依次输出小的。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    static int number[2][10]={{0,1,2,3,4,5,6,7,8,9},{0}};
    int n=0;
    int sum=0;
    char result[1000];
    int i=0;
    for(i=0;i&lt;10;i++){
        scanf(&quot;%d&quot;,&amp;n);
        number[1][i]=n;
        sum+=n;
    }
    i=0;
    while(sum){//当剩余的总个数为0时说明所有数字都用上了。
        if(i==0){
            for(int j=1;j&lt;10;j++){//首先将1-9的数字次数用掉一次，放在字符串首。
                if(number[1][j]!=0){
                    result[i]=number[0][j]+&apos;0&apos;;
                    number[1][j]--;
                    sum--;
                    break;
                }
            }
        }else{
            for(int j=0;j&lt;10;j++){
                if(number[1][j]!=0){
                    result[i]=number[0][j]+&apos;0&apos;;
                    number[1][j]--;
                    sum--;
                    break;
                }
            }
        }
        i++;
    }
    result[i]=&apos;\0&apos;;
    printf(&quot;%s&quot;,result);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1024</title>
    <url>/2019/09/19/PTA-Basic-1024/</url>
    <content><![CDATA[<p>科学计数法是科学家用来表示很大或很小的数字的一种方便的方法，其满足正则表达式 [+-][1-9].[0-9]+E[+-][0-9]+，即数字的整数部分只有 1 位，小数部分至少有 1 位，该数字及其指数部分的正负号即使对正</p>
<p>数也必定明确给出。</p>
<p>现以科学计数法的格式给出实数 A，请编写程序按普通数字表示法输出 A，并保证所有有效位都被保留。</p>
<p>输入格式：</p>
<pre><code>每个输入包含 1 个测试用例，即一个以科学计数法表示的实数 A。该数字的存储长度不超过 9999 字节，且其指数的绝对值不超过 9999。</code></pre><p>输出格式：</p>
<pre><code>对每个测试用例，在一行中按普通数字表示法输出 A，并保证所有有效位都被保留，包括末尾的 0。</code></pre><p>输入样例 1：</p>
<pre><code>+1.23400E-03</code></pre><p>输出样例 1：</p>
<pre><code>0.00123400</code></pre><p>输入样例 2：</p>
<pre><code>-1.2E+10</code></pre><p>输出样例 2：</p>
<pre><code>-12000000000</code></pre><p>分析：</p>
<p>输入： “[+-][1-9].[0-9]+E[+-][0-9]+” 格式如图，数值正负号，一位1到9之间的整数，小数点，小数部分（长度不定且结果要求保留所有小数部分即小数部分有什么样的数字，结果就得含有这个字符串，可以在不同的位置放小数点），指数部分正负号，指数（0-正无穷）。</p>
<p>处理：首先保留一定是位于第一位的正负号，接着将数字部分的小数点去掉，依次存入到字符数组中，当读到‘E’时就可以保留另一个正负号，与其后面数字代表小数点要移动的位数了，</p>
<p>输出：</p>
<pre><code>根据第一个正负号决定是否输出‘-’号。如果移动的位数为0，直接输出元数字字符；否则 根据第二个正负号判断是左移小数点（符号为负号）还是右移（+）</code></pre><p>1左移：</p>
<pre><code>因为位数为0的情况已经讨论过了，所以剩下的都是位数不为0的。
先输出‘0.’在根据要移动的位数，输出位数-1个0，接着输出字符数组。</code></pre><p>2右移：</p>
<pre><code>先输出第一个字符，根据移动位数是否小于剩余字符串的长度决定是否输出小数点，小于：读到指定位数后输出小数点，接着输出剩余字符数组。
大于等于：不输出小数点可能会输出‘0’，输出移动的位数减去除去第一个字符剩余字符数组的长度个‘0’.




#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main(void){
    char str[10003]={&apos;\0&apos;};//存放输入字符数组
    scanf(&quot;%s&quot;,str);
    int flag=1;//用来标识是否已经读取过小数部分了。
    int f1,f2;//用来记住两个正负号
    char result[10000]={&apos;\0&apos;};//用来存放小数部分除去小数点。
    int j=0;
    int num=0;
    for(int i=0;i&lt;strlen(str);i++){
//判断输入的小数部分的符号
        if(i==0){
            switch(str[i]){
                case &apos;+&apos;:f1=1;break;
                case &apos;-&apos;:f1=-1;
            }
            continue;
        }

//表示小数部分已经读取完毕。
        if(str[i]==&apos;E&apos;){
            flag=0;
            continue;
        }

//将小数部分的数字存放到数组中。
        if(flag&amp;&amp;str[i]&lt;=&apos;9&apos;&amp;&amp;str[i]&gt;=&apos;0&apos;){
            result[j++]=str[i];
        }

//判断输入的指数部分的符号
        if(str[i]==&apos;+&apos;||str[i]==&apos;-&apos;){
            switch(str[i]){
                case &apos;+&apos;:f2=1;break;
                case &apos;-&apos;:f2=-1;
            }
            continue;
        }

//计算指数部分要移动的位数
        if(!flag){
            num=num*10+(str[i]-&apos;0&apos;);
        }
    }
//输出符号（+对应‘’负数对应‘-’）
    if(f1&gt;0){
        printf(&quot;&quot;);
    }else{
        printf(&quot;-&quot;);
    }移动位数为0直接输出原小数
//如果
    if(num==0){
            printf(&quot;%c.%s&quot;,result[0],result+1);
        return 0;
        }
//根据指数部分判断移动方向。大于表示右移。
    if(f2&gt;0){//右移时：
        printf(&quot;%c&quot;,result[0]);//首先输出第一个数字
//根据移动位数判断是否要补0
        if(num&lt;strlen(result+1)){//然后根据要移动位数的长度输出0
        for(int j=1;j&lt;=strlen(result+1);j++){
                    if(j&lt;=num){
                    printf(&quot;%c&quot;,result[j]);
                }
                else{
                    printf(&quot;.%s&quot;,result+j);
                    break;//不要忘了跳出去
                }
            }    
        }else{
                printf(&quot;%s&quot;,result+1);
                for(int j=0;j&lt;num-strlen(result+1);j++){
                    printf(&quot;0&quot;);
                }
            }
    }else{//左移第一个肯定为0.几
            printf(&quot;0.&quot;);
            for(int j=1;j&lt;num;j++){
                printf(&quot;0&quot;);
            }
            printf(&quot;%s&quot;,result);
    }
    return 0;
} </code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1025</title>
    <url>/2019/10/16/PTA-Basic-1025/</url>
    <content><![CDATA[<p>题目：</p>
<p>给定一个常数 K 以及一个单链表 L，请编写程序将 L 中每 K 个结点反转。例如：给定 L 为 1→2→3→4→5→6，K 为 3，则输出应该为 3→2→1→6→5→4；如果 K 为 4，则输出应该为 4→3→2→1→5→6，即最后不到 K 个元素不反转。</p>
<p>输入格式：<br>每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1 个结点的地址、结点总个数正整数 N (≤10<br>​5<br>​​ )、以及正整数 K (≤N)，即要求反转的子链结点的个数。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。</p>
<p>接下来有 N 行，每行格式为：</p>
<p>Address Data Next<br>其中 Address 是结点地址，Data 是该结点保存的整数数据，Next 是下一结点的地址。</p>
<p>输出格式：<br>对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。</p>
<p>输入样例：</p>
<pre><code>00100 6 4
00000 4 99999
00100 1 12309
68237 6 -1
33218 3 00000
99999 5 68237
12309 2 33218</code></pre><p>输出样例：</p>
<pre><code>00000 4 33218
33218 3 12309
12309 2 00100
00100 1 99999
99999 5 68237
68237 6 -1</code></pre><p>思路：<br>定义一个结构体存储节点的地址数据下一个地址，定义一个数组存放结点，在定义一个数组存放从第一个结点出发的有序的结点，然后对有序的结点数组进行反转，交换每k个结点，并将每一个结点的下一个地址设置为下一个结点的地址。</p>
<p>坑：可能输入的结点中有些不在链表中应该舍去它们。<br>代码：</p>
<pre><code>/** 
 * (涉及反转，可回顾一下 1008. 数组元素循环右移问题)
 * 1. 通过数组下标来表示地址，便于链接各个节点
 * 2. 考虑存在无效节点的情况
 */
#include &lt;stdio.h&gt;

typedef struct {
    int address;//节点地址
    int data; //整数数据
    int next;//下一节点的地址  
} Node; 
int main() {
    int addr, N, K;//读取首地址，节点数量，反转个数 
    scanf(&quot;%d %d %d&quot;, &amp;addr, &amp;N, &amp;K);
    Node origin[100001], sort[100001];//创建初始单链表,反转后的单链表 
    for (int i = 0; i &lt; N; i++) {//读取节点
        Node temp; 
        scanf(&quot;%d %d %d&quot;, &amp;temp.address, &amp;temp.data, &amp;temp.next);
        origin[temp.address] = temp;
    }
    for (int i = 0; i &lt; N; i++) {//链接节点 //将链表有序存入sorted数组
        sort[i] = origin[addr];
        addr = sort[i].next;//获取下一个节点的地址 
        if (addr == -1) {
            N = i + 1;//可能有无效的节点，需要更新链表中节点的数量 
            break;
        }
    }   
    for (int i = 0; i &lt; N / K; i++) {//反转的次数 
        for (int j = 0; j &lt; K / 2; j++) {//反转 
            Node temp;
            temp = sort[j + i * K];
            sort[j + i * K] = sort[K - 1 - j + i * K];//数组下标确认好 
            sort[K - 1 - j + i * K] = temp;
        }
    }
    for (int i = 0; i &lt; N; i++) {
        if(i != N - 1) {
            sort[i].next = sort[i+1].address;
            printf(&quot;%05d %d %05d\n&quot;, sort[i].address, sort[i].data, sort[i].next);
        } else {
            sort[i].next = -1;
            printf(&quot;%05d %d %d\n&quot;, sort[i].address, sort[i].data, sort[i].next);
        }
    } 
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1028</title>
    <url>/2019/09/20/PTA-Basic-1028/</url>
    <content><![CDATA[<p>某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。</p>
<p>这里确保每个输入的日期都是合法的，但不一定是合理的——假设已知镇上没有超过 200 岁的老人，而今天是 2014 年 9 月 6 日，所以超过 200 岁的生日和未出生的生日都是不合理的，应该被过滤掉。</p>
<p>输入格式：<br>输入在第一行给出正整数 N，取值在(0,10^5]；随后 N 行，每行给出 1 个人的姓名（由不超过 5 个英文字母组成的字符串）、以及按 yyyy/mm/dd（即年/月/日）格式给出的生日。题目保证最年长和最年轻的人没有并列。</p>
<p>输出格式：<br>在一行中顺序输出有效生日的个数、最年长人和最年轻人的姓名，其间以空格分隔。</p>
<p>输入样例：</p>
<pre><code>5
John 2001/05/12
Tom 1814/09/06
Ann 2121/01/30
James 1814/09/05
Steve 1967/11/20</code></pre><p>输出样例：</p>
<pre><code>3 Tom John</code></pre><p>分析：</p>
<p>定义一个结构体，首先日期一定都是合法的，但是不一定合理。定义一个在<br>最早的可能的年份出生的人，与今天出生的人，然后输入的每个人的数据与这两个人对比，合格的就存入person数组中。然后对此数组进行快排，输出第一个元素，与最后一个元素。注意：当没有人时，只输出一个0.</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
typedef struct person{
    char name[6];
    int birthyear;
    int birthmonth;
    int birthday;
}person;
int compare(const void * a,const void * b){
    person A=*(person *)a;
    person B=*(person *)b;
    if(A.birthyear&gt;B.birthyear){
        return 1;
    }else if(A.birthyear&lt;B.birthyear){
        return -1;
    }else{
        if(A.birthmonth&gt;B.birthmonth){
            return 1;
        }else if(A.birthmonth&lt;B.birthmonth){
            return -1;
        }else{
                if(A.birthday&gt;B.birthday){
                return 1;
            }else if(A.birthday&lt;B.birthday){
                return -1;
            }else{
                return 0;
            }
        }
    }
}
int main(void){
    long num;
    scanf(&quot;%ld&quot;,&amp;num);
    long i=0;
    person persons[num],oldperson,p,lastperson;  
    oldperson.birthyear=1814;
    oldperson.birthmonth=9;
    oldperson.birthday=6;
    lastperson.birthyear=2014;
    lastperson.birthmonth=9;
    lastperson.birthday=7;
    while(num--){
        scanf(&quot;%s %d/%d/%d&quot;,p.name,&amp;p.birthyear,&amp;p.birthmonth,&amp;p.birthday);
        if(compare(&amp;p,&amp;oldperson)&gt;=0 &amp;&amp; compare(&amp;p,&amp;lastperson)&lt;0){
            strcpy(persons[i].name,p.name);
            persons[i].birthyear=p.birthyear;
            persons[i].birthmonth=p.birthmonth;
            persons[i].birthday=p.birthday;
            i++;
        }
    }
    qsort(persons,i,sizeof(person),compare);
    if(i!=0)
    printf(&quot;%d %s %s&quot;,i,persons[0].name,persons[i-1].name);
    else{
        printf(&quot;0&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1026</title>
    <url>/2019/09/19/PTA-Basic-1026/</url>
    <content><![CDATA[<p>要获得一个 C 语言程序的运行时间，常用的方法是调用头文件 time.h，其中提供了 clock() 函数，可以捕捉从程序开始运行到 clock() 被调用时所耗费的时间。这个时间单位是 clock tick，即“时钟打点”。同时还有一个常数 CLK_TCK，给出了机器时钟每秒所走的时钟打点数。于是为了获得一个函数 f 的运行时间，我们只要在调用 f 之前先调用 clock()，获得一个时钟打点数 C1；在 f 执行完成后再调用 clock()，获得另一个时钟打点数 C2；两次获得的时钟打点数之差 (C2-C1) 就是 f 运行所消耗的时钟打点数，再除以常数 CLK_TCK，就得到了以秒为单位的运行时间。</p>
<p>这里不妨简单假设常数 CLK_TCK 为 100。现给定被测函数前后两次获得的时钟打点数，请你给出被测函数运行的时间。</p>
<p>输入格式：<br>输入在一行中顺序给出 2 个整数 C1 和 C2。注意两次获得的时钟打点数肯定不相同，即 C1 &lt; C2，并且取值在 [0,10<br>​7<br>​​ ]。</p>
<p>输出格式：<br>在一行中输出被测函数运行的时间。运行时间必须按照 hh:mm:ss（即2位的 时:分:秒）格式输出；不足 1 秒的时间四舍五入到秒。</p>
<p>输入样例：</p>
<pre><code>123 4577973</code></pre><p>输出样例：</p>
<pre><code>12:42:59</code></pre><p>分析：<br>此题简单不做赘述，注意一点，转型时注意语言自带的转型功能。</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int number1;
    int number2;

    scanf(&quot;%d %d&quot;,&amp;number1,&amp;number2);
    int h=(int)((number2-number1)/360000);
    printf(&quot;%02d:&quot;,h);
    int m=(int)(((number2-number1)/100 -h * 3600)/60);
    printf(&quot;%02d:&quot;,m);</code></pre><p>#####//此处强制转型一定要在除过后就进行否则会导致数字丢失。<br>        int s=(((int)((number2-number1)<em>1.0/100+0.5)-h</em>3600-m*60));<br>        printf(“%02d”,s);<br>        return 0;<br>    }</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1027</title>
    <url>/2019/09/19/PTA-Basic-1027/</url>
    <content><![CDATA[<p>本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印</p>
<pre><code>*****
  ***
    *
  ***
*****</code></pre><p>所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。</p>
<p>给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。</p>
<p>输入格式:<br>输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。</p>
<p>输出格式:<br>首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。</p>
<p>输入样例:</p>
<pre><code>19 *</code></pre><p>输出样例:</p>
<pre><code>*****
 ***
  *
 ***
*****
2</code></pre><p>分析：</p>
<p>此题先根据输入的数字计算出一半+1的行数（2<em>n</em>n-1，其中n为行数）然后每一行输出，空格与2*n-1个字符。然后再进行另一半的操作。<br>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int num;
    char ch;
    scanf(&quot;%d %c&quot;,&amp;num,&amp;ch);
    int i=1; 
    for(;;i++){
        if(2*i*i-1&gt;num){//计算一共有多少层。
            break;
        }
    }
    i=i-1;//行数,去掉对称的哪一行。
    num=num-2*i*i+1;//剩余没有用到的个数。
    int n=i;
    int nums=0;
    for(;n&gt;0;n--){//打印一行
        for(int k=0;k&lt;nums;k++){//这一行的空格从0开始计算。
            printf(&quot; &quot;);
        }
        for(int j=0;j&lt;2*n-2;j++){//
            printf(&quot;%c&quot;,ch);
        }
        printf(&quot;%c\n&quot;,ch);
        nums++;
    }
    nums--;
    for(int j=2;j&lt;=i;j++){
        nums--;
        for(int k=0;k&lt;nums;k++){
            printf(&quot; &quot;);
        }
        for(n=0;n&lt;2*j-2;n++){
            printf(&quot;%c&quot;,ch);
        }
        printf(&quot;%c\n&quot;,ch);
    }
    printf(&quot;%d&quot;,num);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1029</title>
    <url>/2019/09/20/PTA-Basic-1029/</url>
    <content><![CDATA[<p>旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及实际被输入的文字，请你列出肯定坏掉的那些键。</p>
<p>输入格式：<br>输入在 2 行中分别给出应该输入的文字、以及实际被输入的文字。每段文字是不超过 80 个字符的串，由字母 A-Z（包括大、小写）、数字 0-9、以及下划线 _（代表空格）组成。题目保证 2 个字符串均非空。</p>
<p>输出格式：<br>按照发现顺序，在一行中输出坏掉的键。其中英文字母只输出大写，每个坏键只输出一次。题目保证至少有 1 个坏键。</p>
<p>输入样例：</p>
<pre><code>7_This_is_a_test
_hs_s_a_es</code></pre><p>输出样例：</p>
<pre><code>7TI</code></pre><p>分析：</p>
<p>存储两个字符串，遍历第一个字符串每个字符，如果字符串二中没有，且其对应的大写字母用来存放结果字符的字符数组中也没有就将其存入数组中并数字加1。跳出循环，最后要在末尾加上‘\0’。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;ctype.h&gt;
int main(void){
    char str[100]={&quot;\0&quot;};
    gets(str);
    char str2[100]={&quot;\0&quot;};
    gets(str2);
    int i=0;
    char result[80]={&quot;\0&quot;};
    int num=0;
    while(str[i]!=&apos;\0&apos;){
        if(!strchr(str2,str[i])){
            char ch=toupper(str[i]);
            if(!strchr(result,ch)){
                result[num++]=ch;
            }
        }
        i++;
    }
    result[num]=&apos;\0&apos;;
    printf(&quot;%s&quot;,result);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1030</title>
    <url>/2019/09/20/PTA-Basic-1030/</url>
    <content><![CDATA[<p>给定一个正整数数列，和正整数 p，设这个数列中的最大值是 M，最小值是 m，如果 M≤mp，则称这个数列是完美数列。</p>
<p>现在给定参数 p 和一些正整数，请你从中选择尽可能多的数构成一个完美数列。</p>
<p>输入格式：<br>输入第一行给出两个正整数 N 和 p，其中 N（≤10^5）是输入的正整数的个数，p（≤10^9）是给定的参数。第二行给出 N 个正整数，每个数不超过10^9。</p>
<p>输出格式：<br>在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。</p>
<p>输入样例：</p>
<pre><code>10 8
2 3 20 4 5 1 6 7 8 9</code></pre><p>输出样例：</p>
<pre><code>8</code></pre><p>分析:</p>
<p>将输入的数字存入数组，对数组进行排序。从第i个开始向后找,每当有值与第i个元素之比小于p时，就看看要不要改变sum的值，下一次进行第i+1此比较时，就从i+1+sum处向后遍历。只有这样，其可能有的sum值才可能大于上一次循环得到的sum值。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int compare(const void * a,const void *b){
    long A=*(long *)a;
    long B=*(long *)b;
    if(A&gt;B){
        return 1;
    }else{
        if(A==B){
            return 0; 
        }else{
            return -1;
        }
    }
}
int main(void){
    int N;
    double p;
    scanf(&quot;%ld %lf&quot;,&amp;N,&amp;p);
    long nums[N];
    long x=0;
    int i=0;
    while(N--){
        scanf(&quot;%d&quot;,&amp;x);
        nums[i++]=x;
    } 
    int MAX=0;
    qsort(nums,i,sizeof(long),compare);
        for(int j=0;j&lt;i;j++){//外层遍历，从0开始，
            for(int k=j+MAX;k&lt;i;k++){
                if(nums[k]*1.0/nums[j]&gt;p){
                    break;
                }
                else{
                    if(k-j+1&gt;MAX){
                        MAX=k-j+1;
                    }
                }
            }
        }
    printf(&quot;%d&quot;,MAX);
    return 0;
}</code></pre><p>注意：</p>
<p>此处存储数值建议使用long存储数字，double存储p的值。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1031</title>
    <url>/2019/09/22/PTA-Basic-1031/</url>
    <content><![CDATA[<p>题目：<br>一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下：</p>
<p>首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值Z；最后按照以下关系对应Z值与校验码M的值：</p>
<p>Z：0 1 2 3 4 5 6 7 8 9 10<br>M：1 0 X 9 8 7 6 5 4 3 2<br>现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。</p>
<p>输入格式：<br>输入第一行给出正整数N（≤100）是输入的身份证号码的个数。随后N行，每行给出1个18位身份证号码。</p>
<p>输出格式：<br>按照输入的顺序每行输出1个有问题的身份证号码。这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常，则输出All passed。</p>
<p>输入样例1：</p>
<pre><code>4
320124198808240056
12010X198901011234
110108196711301866
37070419881216001X</code></pre><p>输出样例1：</p>
<pre><code>12010X198901011234
110108196711301866
37070419881216001X</code></pre><p>输入样例2：</p>
<pre><code>2
320124198808240056
110108196711301862</code></pre><p>输出样例2：</p>
<pre><code>All passed</code></pre><p>分析：<br>输入:第一行给出要输入的身份证的个数。<br>以下输入n行身份证信息。<br>处理：<br>定义一个判断身份证是否合格的函数，判断每一个输入进的身份证是否合格，不合格的存入二维数组，并且数目加1用一个二维字符数组存储不符合条件的身份证号。<br>身份证处理函数：首先检验前17个字符是否都是数字范围内的，然后用前十七个字符分别减去‘0’然后加到总和上去，然后用总和对11取余数，根据对应的余数找到对应的检验码。<br>输出：<br>如果全部合格输出:All passed<br>否则输出不合格的身份证号一行一个。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int check(char * a){
    int i=0;
    for(;i&lt;17;i++){
        if(!(a[i]&lt;=&apos;9&apos;&amp;&amp;a[i]&gt;=&apos;0&apos;)){
            break;
        }
    }
    if(i&lt;17){
        return 0;
    }
    int sum=0;
    sum=(a[0]-&apos;0&apos;)*7+(a[1]-&apos;0&apos;)*9+(a[2]-&apos;0&apos;)*10+(a[3]-&apos;0&apos;)*5+(a[4]-&apos;0&apos;)*8+
    (a[5]-&apos;0&apos;)*4+(a[6]-&apos;0&apos;)*2+(a[7]-&apos;0&apos;)*1+(a[8]-&apos;0&apos;)*6+(a[9]-&apos;0&apos;)*3+
    (a[10]-&apos;0&apos;)*7+(a[11]-&apos;0&apos;)*9+(a[12]-&apos;0&apos;)*10+(a[13]-&apos;0&apos;)*5+(a[14]-&apos;0&apos;)*8+
    (a[15]-&apos;0&apos;)*4+(a[16]-&apos;0&apos;)*2;
    sum=sum%11;
    int flag=0;
    switch(sum){
        case 0:flag=(a[17]==&apos;1&apos;);break;
        case 1:flag=(a[17]==&apos;0&apos;);break;
        case 2:flag=(a[17]==&apos;X&apos;);break;
        case 3:flag=(a[17]==&apos;9&apos;);break;
        case 4:flag=(a[17]==&apos;8&apos;);break;
        case 5:flag=(a[17]==&apos;7&apos;);break;
        case 6:flag=(a[17]==&apos;6&apos;);break;
        case 7:flag=(a[17]==&apos;5&apos;);break;
        case 8:flag=(a[17]==&apos;4&apos;);break;
        case 9:flag=(a[17]==&apos;3&apos;);break;
        case 10:flag=(a[17]==&apos;2&apos;);break;
    }
     return flag;
}
int main(void){
    int num;
    scanf(&quot;%d&quot;,&amp;num);
    char res[num][19];
    int i=0;
    char ch[19];
    while(num--){
        scanf(&quot;%s&quot;,ch);
        if(!check(ch)){
            strcpy(res[i++],ch);
        }
    }
    if(i==0){
        printf(&quot;All passed&quot;); 
    }else{
        for(int j=0;j&lt;i;j++){
            printf(&quot;%s\n&quot;,res[j]);
        }
    }
    return 0;
} </code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1035</title>
    <url>/2019/10/16/PTA-Basic-1035/</url>
    <content><![CDATA[<p>题目：</p>
<p>根据维基百科的定义：</p>
<p>插入排序是迭代算法，逐一获得输入数据，逐步产生有序的输出序列。每步迭代中，算法从输入序列中取出一元素，将之插入有序序列中正确的位置。如此迭代直到全部元素有序。</p>
<p>归并排序进行如下迭代操作：首先将原始序列看成 N 个只包含 1 个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下 1 个有序的序列。</p>
<p>现给定原始序列和由某排序算法产生的中间序列，请你判断该算法究竟是哪种排序算法？</p>
<p>输入格式：<br>输入在第一行给出正整数 N (≤100)；随后一行给出原始序列的 N 个整数；最后一行给出由某排序算法产生的中间序列。这里假设排序的目标序列是升序。数字间以空格分隔。</p>
<p>输出格式：<br>首先在第 1 行中输出Insertion Sort表示插入排序、或Merge Sort表示归并排序；然后在第 2 行中输出用该排序算法再迭代一轮的结果序列。题目保证每组测试的结果是唯一的。数字间以空格分隔，且行首尾不得有多余空格。</p>
<p>输入样例 1：</p>
<pre><code>10
3 1 2 8 7 5 9 4 6 0
1 2 3 7 8 5 9 4 6 0</code></pre><p>输出样例 1：</p>
<pre><code>Insertion Sort
1 2 3 5 7 8 9 4 6 0</code></pre><p>输入样例 2：</p>
<pre><code>10
3 1 2 8 7 5 9 4 0 6
1 3 2 8 5 7 4 9 0 6</code></pre><p>输出样例 2：</p>
<pre><code>Merge Sort
1 2 3 8 4 5 7 9 0 6</code></pre><p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;

int isinsertion(int n, int num[], int half[]);
int nextmerge(int n, int num[], int half[]);

int comp(const void *a, const void *b)
{
    return *(int *)a - *(int *)b;
}

int main()
{
    int n, num[100], half[100];
    int i;
    scanf(&quot;%d&quot;, &amp;n);
    for(i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;num[i]);
    for(i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;half[i]);

    if(isinsertion(n, num, half)) nextmerge(n, num, half);。//既然不是插入排序，那就一定是归并排序，直接进行下一次排序。

    for(i = 0; i &lt; n; i++){//另一种解决末尾不能有空格的方式。
        printf(&quot;%d%c&quot;, num[i], i == n - 1 ? &apos;\n&apos; : &apos; &apos;);
    }
    return 0;
}

int isinsertion(int n, int num[], int half[])
{
    int i, lenth;
    for(i = 0; i &lt; n - 1 &amp;&amp; half[i] &lt;= half[i + 1]; i++){//先判段排好序的结果是否符合插入排序的判断条件。即开始到某一下标处都是有序的其他的与元素组一样排列。不用担心length处的数字与后一个相同，题目保证了结果唯一，所以你直接取相同数字的后一个。
        continue;
    }
    for(i++, lenth = i; i &lt; n &amp;&amp; half[i] == num[i]; i++){//length代表目前有序的最后一个。然后i继续遍历判断与数组是否相等。
        continue;
    }
    if(i &lt; n)//不是的情况下。
        return 1;
    printf(&quot;Insertion Sort\n&quot;);//此处已经可以判断是插入排序了，因此只需在进行一次排序就可以了。
    lenth++;
    qsort(num, lenth, sizeof(int), comp);
    return 0;
}

int nextmerge(int n, int num[], int half[])
{
    int i, j, lenth;
    printf(&quot;Merge Sort\n&quot;);
    for(lenth = 1, i = 0; i &lt; n &amp;&amp; lenth &lt;= n; lenth *=2){//分n/2次，第一次排序每一个，第二次每两个拍一次顺序，只需要调用qsort函数并改变数组的起始位置就可以了。每次的长度为上一次的2倍
        for(i = 0; i &lt; n &amp;&amp; num[i] == half[i]; i++) ;//判断是否与结果数组完全相同，如果已经完全相同了就没有必要进行下一次排序了。即i已经不符合条件了。
        for(j = 1; j &lt; = n / lenth; j++){//数组依据每一段的长度可以分为n/length段，对每一段排序就饿可以了。
            qsort(num + j * lenth/*每一次排序的起始位置*/, lenth, sizeof(int), comp);
        }
        qsort(num + j * lenth, n % lenth, sizeof(int), comp);//排序剩余的部分数字
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1032</title>
    <url>/2019/09/22/PTA-Basic-1032/</url>
    <content><![CDATA[<p>题目：</p>
<p>为了用事实说明挖掘机技术到底哪家强，PAT 组织了一场挖掘机技能大赛。现请你根据比赛结果统计出技术最强的那个学校。</p>
<p>输入格式：<br>输入在第 1 行给出不超过 10<br>​5<br>​​  的正整数 N，即参赛人数。随后 N 行，每行给出一位参赛者的信息和成绩，包括其所代表的学校的编号（从 1 开始连续编号）、及其比赛成绩（百分制），中间以空格分隔。</p>
<p>输出格式：<br>在一行中给出总得分最高的学校的编号、及其总分，中间以空格分隔。题目保证答案唯一，没有并列。</p>
<p>输入样例：</p>
<pre><code>6
3 65
2 80
1 100
2 70
3 40
3 0</code></pre><p>输出样例：</p>
<pre><code>2 150</code></pre><p>分析：</p>
<p>输入：第一行给出要输入的数目，随后每一行给出一个学校的得分。<br>处理：<br>先定义一个学校编号的数组越大越好（其数组下标就是输入的学校的编号），定义一个得分最大的学校的编号，与对应的分数，然后输入n次一个学校的编号与得分，如果输入的分数加到对应的学校后比当前最高的学校搞，就改变两个量，最后输入结束时就得到了，最大的学校的编号与分数了。<br>输出：学校的编号 学校的总分数。<br>注意：此题如果采用排序的话可能会运行超时。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int schools[100001]={0};
    int max=0;
    int max_school=0;
    int n,a,b;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++){
        scanf(&quot;%d %d&quot;,&amp;a,&amp;b);
        schools[a]=schools[a]+b;
        if(schools[a]&gt;max){
            max=schools[a];
            max_school=a;
        }
    }
    printf(&quot;%d %d&quot;,max_school,max);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1034</title>
    <url>/2019/09/22/PTA-Basic-1034/</url>
    <content><![CDATA[<p>题目：</p>
<p>本题要求编写程序，计算 2 个有理数的和、差、积、商。</p>
<p>输入格式：<br>输入在一行中按照 a1/b1 a2/b2 的格式给出两个分数形式的有理数，其中分子和分母全是整型范围内的整数，负号只可能出现在分子前，分母不为 0。</p>
<p>输出格式：<br>分别在 4 行中按照 有理数1 运算符 有理数2 = 结果 的格式顺序输出 2 个有理数的和、差、积、商。注意输出的每个有理数必须是该有理数的最简形式 k a/b，其中 k 是整数部分，a/b 是最简分数部分；若为负数，则须加括号；若除法分母为 0，则输出 Inf。题目保证正确的输出中没有超过整型范围的整数。</p>
<p>输入样例 1：</p>
<pre><code>2/3 -4/2</code></pre><p>输出样例 1：</p>
<pre><code>2/3 + (-2) = (-1 1/3)
2/3 - (-2) = 2 2/3
2/3 * (-2) = (-1 1/3)
2/3 / (-2) = (-1/3)</code></pre><p>输入样例 2：</p>
<pre><code>5/3 0/6</code></pre><p>输出样例 2：</p>
<pre><code>1 2/3 + 0 = 1 2/3
1 2/3 - 0 = 1 2/3
1 2/3 * 0 = 0
1 2/3 / 0 = Inf</code></pre><p>分析：</p>
<p>输入：按格式输入两个有理数（分母一定不为0，符号一定在分子上，分子可能为0）.<br>处理：首先定义一个求最大公约数的函数（注意求最大公约数时的算法一定要快，而且注意负数与正数之间也是有最大公约数的，其最大公约数是正数）。然后定义一个符合题目格式的函数用于输出运算后的结果（先对每个结果判断分母是否为0，如果分母为0直接输出Inf,如果不为0，再判断分子是否为0,为0就直接输出0，否则再对其先进行约分{注意一定要定义一个变量保存最大公约数，因为后面再约分时数字已经改变}，然后在根据分子是否时是负数对其进行假分数的相关操作，），再定义一个求加，减，乘，除的函数。注意输入的所有数字一定要是long型的不然会有俩个测试点过不了。<br>输出：。。。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
long gcd(long a,long b)//最大公约数
{
    if(a&lt;0){
        a=-a;
    }
    if(b&lt;0){
        b=-b;
    }
    long n=(a&gt;b?a:b),m=(a&gt;b?b:a);
    long c=a%b;
    while(c){
        a=b;
        b=c;
        c=a%b;
    }
    return b;
}
void form(long a,long b){
    if(b==0){
        printf(&quot;Inf&quot;);
        return;
    }
    if(a==0){
        printf(&quot;0&quot;);
        return;
    }
    long n=gcd(a,b);//对其进行约分
    a=a/n;
    b=b/n;
    if(a&gt;0){
        long k=a/b;
        if(k==0){
            printf(&quot;%ld/%ld&quot;,a,b);
            return;
        }else{
            a=a%b;
            if(a==0){
                printf(&quot;%ld&quot;,k);
                return;
            }else{
                printf(&quot;%ld %ld/%ld&quot;,k,a,b);
                return;
            }
        }
    }else{
        printf(&quot;(&quot;);
        long k=a/b;
        if(k==0){
            printf(&quot;%ld/%ld)&quot;,a,b);
            return;
        }else{
            a=-a;
            a=a%b;
            if(a==0){
                printf(&quot;%ld)&quot;,k);
                return;
            }else{
                printf(&quot;%ld %ld/%ld)&quot;,k,a,b);
                return;
            }
        }
    }
}
void add(long a1,long a2,long b1,long b2){
    long k=a2;
    long c2=b2*a2;
    a1=a1*b2;
    a2=a2*b2;
    b1=b1*a2;
    b2=b2*k;
    long c1=a1+b1;
    form(a1,a2);
    printf(&quot; + &quot;);
    form(b1,b2);
    printf(&quot; = &quot;);
    form(c1,c2);
}
void ride(long a1,long a2,long b1,long b2){
    long c1=a1*b1;
    long c2=a2*b2;
    form(a1,a2);
    printf(&quot; * &quot;);
    form(b1,b2);
    printf(&quot; = &quot;);
    form(c1,c2);
}
void div(long a1,long a2,long b1,long b2){
    long c1=a1*b2;
    long c2=a2*b1;
    if(c2&lt;0){
        c2=-c2;
        c1=-c1;
    }
    form(a1,a2);
    printf(&quot; / &quot;);
    form(b1,b2);
    printf(&quot; = &quot;);
    form(c1,c2);
}

void sub(long a1,long a2,long b1,long b2){
    long k=a2;
    long c2=b2*a2;
    a1=a1*b2;
    b1=b1*a2;
    a2=a2*b2;
    b2=b2*k;
    long c1=a1-b1;
    form(a1,a2);
    printf(&quot; - &quot;);
    form(b1,b2);
    printf(&quot; = &quot;);
    form(c1,c2);
}
int main(void){
    long a1,a2,b1,b2;
    scanf(&quot;%ld/%ld %ld/%ld&quot;,&amp;a1,&amp;a2,&amp;b1,&amp;b2);
    add(a1,a2,b1,b2);
    printf(&quot;\n&quot;);
    sub(a1,a2,b1,b2);
    printf(&quot;\n&quot;);
    ride(a1,a2,b1,b2);
    printf(&quot;\n&quot;);
    div(a1,a2,b1,b2);
    return 0;
} </code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1036</title>
    <url>/2019/09/22/PTA-Basic-1036/</url>
    <content><![CDATA[<p>美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。2014 年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！</p>
<p>输入格式：<br>输入在一行中给出正方形边长 N（3≤N≤20）和组成正方形边的某种字符 C，间隔一个空格。</p>
<p>输出格式：<br>输出由给定字符 C 画出的正方形。但是注意到行间距比列间距大，所以为了让结果看上去更像正方形，我们输出的行数实际上是列数的 50%（四舍五入取整）。</p>
<p>输入样例：</p>
<pre><code>10 a</code></pre><p>输出样例：</p>
<pre><code>aaaaaaaaaa
a        a
a        a
a        a
aaaaaaaaaa</code></pre><p>分析：见题目，行数是列数的一半的四舍五入。第一行与最后一行输出n个字符，其他输出2个字符与n-2个空格。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int num;
    char ch;
    scanf(&quot;%d %c&quot;,&amp;num,&amp;ch);
    int lines=(int)((num*1.0/2)+0.5);
    for(int n=0;n&lt;lines;n++){
        if(n==0||n==lines-1){
            for(int i=0;i&lt;num;i++){
                printf(&quot;%c&quot;,ch);
            }
            if(n==0){
                printf(&quot;\n&quot;);
            }
        }else{
            printf(&quot;%c&quot;,ch);
            for(int n=0;n&lt;num-2;n++){
                printf(&quot; &quot;);
            }
            printf(&quot;%c\n&quot;,ch);
        }
    }
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1033</title>
    <url>/2019/09/22/PTA-Basic-1033/</url>
    <content><![CDATA[<p>题目：</p>
<p>旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及坏掉的那些键，打出的结果文字会是怎样？</p>
<p>输入格式：<br>输入在 2 行中分别给出坏掉的那些键、以及应该输入的文字。其中对应英文字母的坏键以大写给出；每段文字是不超过 10<br>^5<br>​​  个字符的串。可用的字符包括字母 [a-z, A-Z]、数字 0-9、以及下划线 _（代表空格）、,、.、-、+（代表上档键）。题目保证第 2 行输入的文字串非空。</p>
<p>注意：如果上档键坏掉了，那么大写的英文字母无法被打出。</p>
<p>输出格式：<br>在一行中输出能够被打出的结果文字。如果没有一个字符能被打出，则输出空行。</p>
<p>输入样例：</p>
<pre><code>7+IE.
7_This_is_a_test.</code></pre><p>输出样例：</p>
<pre><code>_hs_s_a_tst</code></pre><p>分析:</p>
<pre><code>输入：第一行输入坏掉的字符（如果有字母则对应
的字母不能出现，如果有下划线则不下划线，有加号大写字母甭能出现）</code></pre><hr>
<pre><code>处理：
先定义两个尽可能大的字符数组一个用来存储坏键，一个用来存储要输入的字符串。

定义一个删除字符的函数，然后遍历第一个字符串分别在第二个字符串中删去相应的字符。

输出：处理后的字符串如果字符串长度为0则输出空行。</code></pre><p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;ctype.h&gt;
char * Remove(char*a,char b){
    char * src,*dst;
    src=a;
    dst=a;
    while(*src!=&apos;\0&apos;){
        *dst=*src;
        src++;
        if(*dst!=b){
            dst++;
        }
    }
    *dst=&apos;\0&apos;;
    return a;
}
int main(void){
    char a[110000]={},b[110000]={};
    gets(a);
    gets(b);
    int i=0;
    while(a[i]!=&apos;\0&apos;){
                if(a[i]!=&apos;+&apos;){//shang dang jian mei hua
                            if(a[i]&gt;=&apos;A&apos;&amp;&amp;a[i]&lt;=&apos;Z&apos;){
                                Remove(b,tolower(a[i]));
                                Remove(b,toupper(a[i]));
                            }else{
                                Remove(b,a[i]);
                            }
                }else{
                    for(char j=&apos;A&apos;;j&lt;(&apos;Z&apos;+1);j++){
                        Remove(b,j);
                    }
            }
        i++;
    }

    if(strlen(b)!=0){
        printf(&quot;%s&quot;,b);
    }else{
        printf(&quot;\n&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1040</title>
    <url>/2019/09/24/PTA-Basic-1040/</url>
    <content><![CDATA[<p>字符串 APPAPT 中包含了两个单词 PAT，其中第一个 PAT 是第 2 位(P)，第 4 位(A)，第 6 位(T)；第二个 PAT 是第 3 位(P)，第 4 位(A)，第 6 位(T)。</p>
<p>现给定字符串，问一共可以形成多少个 PAT？</p>
<p>输入格式：</p>
<p>输入只有一行，包含一个字符串，长度不超过10^5，只包含 P、A、T 三种字母。</p>
<p>输出格式：</p>
<p>在一行中输出给定字符串中包含多少个 PAT。由于结果可能比较大，只输出对 1000000007 取余数的结果。</p>
<p>输入样例：</p>
<pre><code>APPAPT</code></pre><p>输出样例：</p>
<pre><code>2</code></pre><p>思路：输入一个字符串。<br>处理：定义三个变量，分别用来计算p，pa,pat的总数。<br>从前向后数，计算p的个数，如果遇到a就说明已经有了(已数p的数目)个pa，如果有遇到a,则将已经有的pa数加上已经有的p数（a前有多少个p代表有多少个pa）,如果遇到T就说明有了pa个数个pat,再遇到t时就将已经有的pat个数加上以前有的pa数。<br>输出：输出结果对1000000007 取余的结果。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int p=0,pa=0,pat=0;
    char ch;
    while((ch=getchar())!=&apos;\n&apos;){
    if(ch==&apos;P&apos;)p++;
    if(ch==&apos;A&apos;)pa=pa+p;
    if(ch==&apos;T&apos;)pat=(pat+pa)%1000000007;//为什么在这里要对其取余，而不在输出时？

    /*因为pat存储的就是结果数目，如果在加的过程中超出了范围
    会导致内存溢出，数据就会存储出错，对结果取余也就不对了，
    在求总数的过程中对其进行取余一旦超过1000000007但是其还
    在整型范围内所以一旦超出就对其进行取余。*/
    }
    printf(&quot;%d&quot;,pat);
    return 0;
}</code></pre><p>思路二：<br>思路分析：先数出一共有多少T，然再遍历字符串，遇到一个T就减去一个，遇到一个p就将P的个数加1，遇到一个a就说明后面有剩余T个数个T,那么就有T的个数个pat,每遇到一个A就用已有的pat个数加上后面剩余的T的个数。最后得出总数，同样这里也要取余。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
int main() {
    string s;
    cin &gt;&gt; s;
    int len = s.length(), result = 0, countp = 0, countt = 0;
    //先输出一共有有多少T;
    for (int i = 0; i &lt; len; i++) {
        if (s[i] == &apos;T&apos;)
            countt++;
    }
    for (int i = 0; i &lt; len; i++) {
        if (s[i] == &apos;P&apos;) countp++;
        if (s[i] == &apos;T&apos;) countt--;
        if (s[i] == &apos;A&apos;) result = (result + countp * countt) % 1000000007;
    }
    cout &lt;&lt; result;
    return 0;
}</code></pre><p>参考文章：<br><a href="https://blog.csdn.net/zhanshen112/article/details/83629587">https://blog.csdn.net/zhanshen112/article/details/83629587</a></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1037</title>
    <url>/2019/09/23/PTA-Basic-1037/</url>
    <content><![CDATA[<p>题目：</p>
<p>如果你是哈利·波特迷，你会知道魔法世界有它自己的货币系统 —— 就如海格告诉哈利的：“十七个银西可(Sickle)兑一个加隆(Galleon)，二十九个纳特(Knut)兑一个西可，很容易。”现在，给定哈利应付的价钱 P 和他实付的钱 A，你的任务是写一个程序来计算他应该被找的零钱。</p>
<p>输入格式：<br>输入在 1 行中分别给出 P 和 A，格式为 Galleon.Sickle.Knut，其间用 1 个空格分隔。这里 Galleon 是 [0, 10<br>​^7<br>​​ ] 区间内的整数，Sickle 是 [0, 17) 区间内的整数，Knut 是 [0, 29) 区间内的整数。</p>
<p>输出格式：</p>
<p>在一行中用与输入同样的格式输出哈利应该被找的零钱。如果他没带够钱，那么输出的应该是负数。</p>
<p>输入样例 1：</p>
<pre><code>10.16.27 14.1.28</code></pre><p>输出样例 1：</p>
<pre><code>3.2.1</code></pre><p>输入样例 2：</p>
<pre><code>14.1.28 10.16.27</code></pre><p>输出样例 2：</p>
<pre><code>-3.2.1</code></pre><p>分析：</p>
<p>输入:Galleon1.Sickle1.Knut1 Galleon2.Sickle2.Knut2<br>处理：先将每个分别化为最小单位的货币和，然后用实收减去应收，所得结果即为多的或少的。然后对此进行单位换算，先化为高位的，再化为中位的，剩下的就是最低单位的数字。<br>输出：Galleon3.Sickle3.Knut3</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    long p[3]={0};
    long a[3]={0};
    scanf(&quot;%d.%d.%d %d.%d.%d&quot;,&amp;p[0],&amp;p[1],&amp;p[2],&amp;a[0],&amp;a[1],&amp;a[2]);
    long c[3]={0};
    long x=a[0]*29*17+a[1]*29+a[2];
    long y=p[0]*29*17+p[1]*29+p[2];
    x=x-y;
    c[0]=(x)/(29*17);
    c[1]=(x-c[0]*29*17)/29;
    c[2]=(x-c[0]*29*17-c[1]*29);
//此处的一个坑就是当欠钱时值输出一个负号。
    printf(&quot;%d.%d.%d&quot;,c[0],(c[1]&gt;0?c[1]:-c[1]),(c[2]&gt;0?c[2]:-c[2]));//如果第一是负数时后面的就不用输出负号了。
    return 0;
    }</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1041</title>
    <url>/2019/09/24/PTA-Basic-1041/</url>
    <content><![CDATA[<p>每个 PAT 考生在参加考试时都会被分配两个座位号，一个是试机座位，一个是考试座位。正常情况下，考生在入场时先得到试机座位号码，入座进入试机状态后，系统会显示该考生的考试座位号码，考试时考生需要换到考试座位就座。但有些考生迟到了，试机已经结束，他们只能拿着领到的试机座位号码求助于你，从后台查出他们的考试座位号码。</p>
<p>输入格式：<br>输入第一行给出一个正整数 N（≤1000），随后 N 行，每行给出一个考生的信息：准考证号 试机座位号 考试座位号。其中准考证号由 16 位数字组成，座位从 1 到 N 编号。输入保证每个人的准考证号都不同，并且任何时候都不会把两个人分配到同一个座位上。</p>
<p>考生信息之后，给出一个正整数 M（≤N），随后一行中给出 M 个待查询的试机座位号码，以空格分隔。</p>
<p>输出格式：<br>对应每个需要查询的试机座位号码，在一行中输出对应考生的准考证号和考试座位号码，中间用 1 个空格分隔。</p>
<p>输入样例：</p>
<pre><code>4
3310120150912233 2 4
3310120150912119 4 1
3310120150912126 1 3
3310120150912002 3 2
2
3 4</code></pre><p>输出样例：</p>
<pre><code>3310120150912002 2
3310120150912119 1</code></pre><p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
typedef struct stu{
    char id[17];
    int sitNum;
    int examNum;
}stu;
int main(void){
    int num;
    scanf(&quot;%d&quot;,&amp;num);
    stu stus[num];
    int i=0;
    while(i&lt;num){
        scanf(&quot;%s %d %d&quot;,(stus[i].id),&amp;(stus[i].sitNum),&amp;(stus[i].examNum));
        i++;
    }
    int num1=0;
    scanf(&quot;%d&quot;,&amp;num1);
    while(num1--){
        int n;
        scanf(&quot;%d&quot;,&amp;n);
        for(int i=0;i&lt;num;i++){
            if(stus[i].sitNum==n){
                printf(&quot;%s %d\n&quot;,stus[i].id,stus[i].examNum);
            }
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1038</title>
    <url>/2019/09/23/PTA-Basic-1038/</url>
    <content><![CDATA[<p>题目：<br>本题要求读入 N 名学生的成绩，将获得某一给定分数的学生人数输出。</p>
<p>输入格式：<br>输入在第 1 行给出不超过 10<br>​^5<br>​​  的正整数 N，即学生总人数。随后一行给出 N 名学生的百分制整数成绩，中间以空格分隔。最后一行给出要查询的分数个数 K（不超过 N 的正整数），随后是 K 个分数，中间以空格分隔。</p>
<p>输出格式：<br>在一行中按查询顺序给出得分等于指定分数的学生人数，中间以空格分隔，但行末不得有多余空格。</p>
<p>输入样例：</p>
<pre><code>10
60 75 90 55 75 99 82 90 75 50
3 75 90 88</code></pre><p>输出样例：</p>
<pre><code>3 2 0</code></pre><p>分析：</p>
<p>输入：数目 与 得分。<br>处理：此题不好用循环去一个一个遍历，查找比对。<br>因为题目说了数字范围是1-100的整数，所以直接定义一个长度为101的数组，每输入一个分数时，就再分数对应的下标所在的数组存储的数目加1.输入要查找的得分时通过得分直接找到相应的次数，并输出，如果输出最后一个数字时，不用输出空格。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main()
{
    int n,m;
    scanf(&quot;%d&quot;,&amp;n);
    int score1[101]={0};
    int score2;
    while(n--)
    {
        scanf(&quot;%d&quot;,&amp;score2);
        score1[score2]++;
    }
    scanf(&quot;%d&quot;,&amp;m);
    int score3;
    while(m--)
    {
        scanf(&quot;%d&quot;,&amp;score3);
        printf(&quot;%d&quot;,score1[score3]);
        if(m!=0)
            printf(&quot; &quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1039</title>
    <url>/2019/09/23/PTA-Basic-1039/</url>
    <content><![CDATA[<p>题目：</p>
<p>小红想买些珠子做一串自己喜欢的珠串。卖珠子的摊主有很多串五颜六色的珠串，但是不肯把任何一串拆散了卖。于是小红要你帮忙判断一下，某串珠子里是否包含了全部自己想要的珠子？如果是，那么告诉她有多少多余的珠子；如果不是，那么告诉她缺了多少珠子。</p>
<p>为方便起见，我们用[0-9]、[a-z]、[A-Z]范围内的字符来表示颜色。例如在图1中，第3串是小红想做的珠串；那么第1串可以买，因为包含了全部她想要的珠子，还多了8颗不需要的珠子；第2串不能买，因为没有黑色珠子，并且少了一颗红色的珠子。</p>
<p><img src="https://images.ptausercontent.com/b7e2ffa6-8819-436d-ad79-a41263abe914.jpg" alt="串串"></p>
<p>图 1</p>
<p>输入格式：</p>
<pre><code>每个输入包含 1 个测试用例。每个测试用例分别在 2 行中先后给出
摊主的珠串和小红想做的珠串，两串都不超过 1000 个珠子。</code></pre><p>输出格式：</p>
<pre><code>如果可以买，则在一行中输出 Yes 以及有多少多余的珠子；如果不
可以买，则在一行中输出 No 以及缺了多少珠子。其间以 1 个空格
分隔。</code></pre><p>输入样例 1：</p>
<pre><code>ppRYYGrrYBR2258
YrR8RrY</code></pre><p>输出样例 1：</p>
<pre><code>Yes 8</code></pre><p>输入样例 2：</p>
<pre><code>ppRYYGrrYB225
YrR8RrY</code></pre><p>输出样例 2：</p>
<pre><code>No 2</code></pre><p>分析：此题与上一题采用相同的思路，先定义一个整型数组（范围要能把字母与数字的ascall码值包含在内），然后输入字符，如果字符符合条件就将字符对应的ascall码对应的数组下标所对应的数组+1，表示此种字符输入一次。输入要查找的字符串时，字符对应的数目-1.最后遍历数组将所有符数加到一起，所以正数加到一起，负数表示缺少的字符数目，正数表示多余的字符数目，如果有负数优先输出：No 缺少的数目（&gt;0）。反之 就输出Yes 多余的数目。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
        int chars[250]={0};
        char ch;
        while((ch=getchar())!=&apos;\n&apos;){
            if((ch&lt;=&apos;z&apos;&amp;&amp;ch&gt;=&apos;a&apos;)||(ch&lt;=&apos;Z&apos;&amp;&amp;ch&gt;=&apos;A&apos;)||ch&lt;=&apos;9&apos;&amp;&amp;ch&gt;=&apos;0&apos;){
                chars[ch]++;
            }
        }
        while((ch=getchar())!=&apos;\n&apos;){
            if((ch&lt;=&apos;z&apos;&amp;&amp;ch&gt;=&apos;a&apos;)||(ch&lt;=&apos;Z&apos;&amp;&amp;ch&gt;=&apos;A&apos;)||ch&lt;=&apos;9&apos;&amp;&amp;ch&gt;=&apos;0&apos;){
                chars[ch]--;
            }
        }
        int sum1=0;
        int sum2=0;
        int i=0;
        while(i&lt;250){
            if(chars[i]&lt;0){
                sum2+=chars[i];
            }else{
                sum1+=chars[i];
                }
                i++;
        }
        if(sum2&lt;0){
            printf(&quot;No %d&quot;,-sum2);
        }else{
            printf(&quot;Yes %d&quot;,sum1);
            }
        return 0;
    }</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1043</title>
    <url>/2019/09/25/PTA-Basic-1043/</url>
    <content><![CDATA[<p>题目：<br>给定一个长度不超过 10<br>​4<br>​​  的、仅由英文字母构成的字符串。请将字符重新调整顺序，按 PATestPATest…. 这样的顺序输出，并忽略其它字符。当然，六种字符的个数不一定是一样多的，若某种字符已经输出完，则余下的字符仍按 PATest 的顺序打印，直到所有字符都被输出。</p>
<p>输入格式：<br>输入在一行中给出一个长度不超过 10<br>​4<br>​​  的、仅由英文字母构成的非空字符串。</p>
<p>输出格式：<br>在一行中按题目要求输出排序后的字符串。题目保证输出非空。</p>
<p>输入样例：</p>
<pre><code>redlesPayBestPATTopTeePHPereatitAPPT</code></pre><p>输出样例：</p>
<pre><code>PATestPATestPTetPTePePee</code></pre><p>分析：<br>定义一个整型数组用下标对应字母，数值对应个数。另外用一个变量存储符合条件的字符总数，然后进行输出，每次查找对应的字母是否还有数目，如果有就输出并字符总数减去1没有就跳过字母。</p>
<p>代码：</p>
<p>c++实现：</p>
<pre><code>#include &lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;

int main()
{
    int chars[6]={0};
    string str;
    cin&gt;&gt;str;
    int len=str.length();
    int sum=0;
    for(int i=0;i&lt;len;i++){
        switch(str.at(i)){
            case &apos;P&apos;:chars[0]++;sum++;break;
            case &apos;A&apos;:chars[1]++;sum++;break;
            case &apos;T&apos;:chars[2]++;sum++;break;
            case &apos;e&apos;:chars[3]++;sum++;break;
            case &apos;s&apos;:chars[4]++;sum++;break;
            case &apos;t&apos;:chars[5]++;sum++;break;
            default:break;
        }
    }
    while(sum){
        if(chars[0]){
            chars[0]--;
            sum--;
            cout&lt;&lt;&apos;P&apos;;
        }
        if(chars[1]){
            chars[1]--;
            sum--;
            cout&lt;&lt;&apos;A&apos;;
        }
        if(chars[2]){
            chars[2]--;
            sum--;
            cout&lt;&lt;&apos;T&apos;;
        }
        if(chars[3]){
            chars[3]--;
            sum--;
            cout&lt;&lt;&apos;e&apos;;
        }
        if(chars[4]){
            chars[4]--;
            sum--;
            cout&lt;&lt;&apos;s&apos;;
        }
        if(chars[5]){
            chars[5]--;
            sum--;
            cout&lt;&lt;&apos;t&apos;;
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1042</title>
    <url>/2019/09/24/PTA-Basic-1042/</url>
    <content><![CDATA[<p>请编写程序，找出一段给定文字中出现最频繁的那个英文字母。</p>
<p>输入格式：<br>输入在一行中给出一个长度不超过 1000 的字符串。字符串由 ASCII 码表中任意可见字符及空格组成，至少包含 1 个英文字母，以回车结束（回车不算在内）。</p>
<p>输出格式：<br>在一行中输出出现频率最高的那个英文字母及其出现次数，其间以空格分隔。如果有并列，则输出按字母序最小的那个字母。统计时不区分大小写，输出小写字母。</p>
<p>输入样例：</p>
<pre><code>This is a simple TEST.  There ARE numbers and other symbols 1&amp;2&amp;3...........</code></pre><p>输出样例：</p>
<pre><code>e 7</code></pre><p>分析：定义一个26个字母（小写）的整型数组，每次遇到字母（如果大写就将其化为小写）存储到字母-97（‘a’对应的ascall码值）下标的位置。最后遍历数组找出最大数字的下标，并将其转为字符输出。</p>
<p>代码:</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int strs[26]={0};
    char ch;
    while((ch=getchar())!=&apos;\n&apos;){
        if((ch&lt;=&apos;z&apos;&amp;&amp;ch&gt;=&apos;a&apos;)||(ch&gt;=&apos;A&apos;&amp;&amp;ch&lt;=&apos;Z&apos;)){
            if(ch&lt;97){
                ch=ch-&apos;A&apos;+&apos;a&apos;;
            }
            strs[ch-97]++;
        }
    }
    int a=0;
    for(int i=1;i&lt;26;i++){
        if(strs[i]&gt;strs[a]){
            a=i;
        }
    }
    printf(&quot;%c %d&quot;,a+97,strs[a]);
    return 0;
}</code></pre><p>思路二：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;ctype.h&gt;
int map[255]={0};
int main(void){
    int maxNum=0;
    char  maxChar=&apos;a&apos;;
    char ch;
    while((ch=getchar())!=&apos;\n&apos;){
        if((ch&gt;=&apos;a&apos;&amp;&amp;ch&lt;=&apos;z&apos;)||(ch&gt;=&apos;A&apos;&amp;&amp;ch&lt;=&apos;Z&apos;)){
            ch=tolower(ch);
            map[ch]++;
            if(map[ch]&gt;=map[maxChar]){
                if(map[ch]==map[maxChar]){
                    if(maxChar&gt;ch)
                        maxChar=ch;
                }else{
                    maxChar=ch;
                }
            }
        }

    }
    printf(&quot;%c %d&quot;,maxChar,map[maxChar]);
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1044</title>
    <url>/2019/09/25/PTA-Basic-1044/</url>
    <content><![CDATA[<p>题目：</p>
<p>火星人是以 13 进制计数的：</p>
<p>地球人的 0 被火星人称为 tret。<br>地球人数字 1 到 12 的火星文分别为：jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec。<br>火星人将进位以后的 12 个高位数字分别称为：tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou。<br>例如地球人的数字 29 翻译成火星文就是 hel mar；而火星文 elo nov 对应地球数字 115。为了方便交流，请你编写程序实现地球和火星数字之间的互译。</p>
<p>输入格式：<br>输入第一行给出一个正整数 N（&lt;100），随后 N 行，每行给出一个 [0, 169) 区间内的数字 —— 或者是地球文，或者是火星文。</p>
<p>输出格式：<br>对应输入的每一行，在一行中输出翻译后的另一种语言的数字。</p>
<p>输入样例：</p>
<pre><code>4
29
5
elo nov
tam</code></pre><p>输出样例：</p>
<pre><code>hel mar
may
115
13</code></pre><p>分析：<br>    定义一个字符串数组，用来存储n个字符串，然后对每个字符串判断是数字还是字母，分别调用不同的函数。<br>数字》字符串：<br>因为数字范围是【0-169），所以火星文只有两位。用数字对13取整得到高位，然后再对13取余，得到低位。如果高位有数，而低位为0则不用输出低位对应的火星文，如果高位低位都不为0，就正常输出。<br>字符串到数字：<br>在函数中定义两个字符串数组分别对应高位与低位的字符串，然后对传入的字符串查找是否包含某一个火星文，包含高位上的火星文就拿对应的下标<em>13，低位布用</em>13，为了减少运行时间可以添加变量控制循环。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
void changeToNumber(char *a);
void changeToString(int num);
int main(void){
    int num=0;
    scanf(&quot;%d&quot;,&amp;num);
    getchar();
    char str[num][10];
    int i=0;
    while(i&lt;num){
        gets(str[i++]);
    }
    i=0;
    for(;i&lt;num;i++){
        if(str[i][0]&lt;=&apos;9&apos;&amp;&amp;str[i][0]&gt;=&apos;0&apos;){
            int sum=0;
            for(int j=0;j&lt;strlen(str[i]);j++){
                sum=sum*10+(str[i][j]-&apos;0&apos;);
            }
            changeToString(sum);
        }else{
            changeToNumber(str[i]);
        }
    }
    return 0;
}
void changeToString(int num){
    int n=num/13;
    int m=num%13;
    if(n&gt;0){
        switch(n){
            case 1:printf(&quot;tam&quot;);break;
            case 2:printf(&quot;hel&quot;);break;
            case 3:printf(&quot;maa&quot;);break;
            case 4:printf(&quot;huh&quot;);break;
            case 5:printf(&quot;tou&quot;);break;
            case 6:printf(&quot;kes&quot;);break;
            case 7:printf(&quot;hei&quot;);break;
            case 8:printf(&quot;elo&quot;);break;
            case 9:printf(&quot;syy&quot;);break;
            case 10:printf(&quot;lok&quot;);break;
            case 11:printf(&quot;mer&quot;);break;
            case 12:printf(&quot;jou&quot;);break;
        }
    }
    if(n&gt;0&amp;&amp;m&gt;0){
        printf(&quot; &quot;);
    }
    if(n&gt;0&amp;&amp;m==0){
        printf(&quot;\n&quot;);
        return;
    }
        switch(m){
            case 0:printf(&quot;tret\n&quot;);break;
            case 1:printf(&quot;jan\n&quot;);break;
            case 2:printf(&quot;feb\n&quot;);break;
            case 3:printf(&quot;mar\n&quot;);break;
            case 4:printf(&quot;apr\n&quot;);break;
            case 5:printf(&quot;may\n&quot;);break;
            case 6:printf(&quot;jun\n&quot;);break;
            case 7:printf(&quot;jly\n&quot;);break;
            case 8:printf(&quot;aug\n&quot;);break;
            case 9:printf(&quot;sep\n&quot;);break;
            case 10:printf(&quot;oct\n&quot;);break;
            case 11:printf(&quot;nov\n&quot;);break;
            case 12:printf(&quot;dec\n&quot;);break;
        }
} 

void changeToNumber(char *a){
    static char chrs1[13][5]={&quot;##&quot;,&quot;tam&quot;, &quot;hel&quot;, &quot;maa&quot;, &quot;huh&quot;, &quot;tou&quot;, &quot;kes&quot;, &quot;hei&quot;, &quot;elo&quot;, &quot;syy&quot;, &quot;lok&quot;, &quot;mer&quot;, &quot;jou&quot;};
    static char chrs2[13][5]={&quot;tret&quot;,&quot;jan&quot;, &quot;feb&quot;, &quot;mar&quot;, &quot;apr&quot;, &quot;may&quot;, &quot;jun&quot;, &quot;jly&quot;, &quot;aug&quot;, &quot;sep&quot;, &quot;oct&quot;, &quot;nov&quot;, &quot;dec&quot;};
    int sum=0;
    int flag1=1,flag2=1;
    for(int i=0;i&lt;13;i++){
        if(strstr(a,chrs1[i])&amp;&amp;flag1){
            sum=sum+(i)*13;
            flag1=0;
        }
        if(strstr(a,chrs2[i])&amp;&amp;flag2){
            sum=sum+i;
            flag2=0;
        }
        if(!flag1&amp;&amp;!flag2){
            break;
        }
    }
    printf(&quot;%d\n&quot;,sum);
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1045</title>
    <url>/2019/09/25/PTA-Basic-1045/</url>
    <content><![CDATA[<p>著名的快速排序算法里有一个经典的划分过程：我们通常采用某种方法取一个元素作为主元，通过交换，把比主元小的元素放到它的左边，比主元大的元素放到它的右边。 给定划分后的 N 个互不相同的正整数的排列，请问有多少个元素可能是划分前选取的主元？</p>
<p>例如给定 $N = 5$, 排列是1、3、2、4、5。则：</p>
<p>1 的左边没有元素，右边的元素都比它大，所以它可能是主元；<br>尽管 3 的左边元素都比它小，但其右边的 2 比它小，所以它不能是主元；<br>尽管 2 的右边元素都比它大，但其左边的 3 比它大，所以它不能是主元；<br>类似原因，4 和 5 都可能是主元。<br>因此，有 3 个元素可能是主元。</p>
<p>输入格式：<br>输入在第 1 行中给出一个正整数 N（≤10<br>​5<br>​​ ）； 第 2 行是空格分隔的 N 个不同的正整数，每个数不超过 10<br>​9<br>​​ 。</p>
<p>输出格式：<br>在第 1 行中输出有可能是主元的元素个数；在第 2 行中按递增顺序输出这些元素，其间以 1 个空格分隔，行首尾不得有多余空格。</p>
<p>输入样例：<br>5<br>1 3 2 4 5<br>输出样例：<br>3<br>1 4 5</p>
<p>我的思路：<br>使用for循环，从左边开始遍历如果有比它大的就标记它自己与那个数字，但是不跳出循环继续遍历，继续标识不合格的数字，如果一次循环下来没有找到比它大的数字那么说明他是合格的，合格的就存入另外一个数组。如果不是合格的那么后面比它小的都不合格了，所以不用遍历这些，最后最后得出一个主元的递增数列。但是这个方发还是有一个测试点1超时了。我还是可以的能把别人一半运行超时的思路减到一个。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main(void){
    unsigned int num;
    scanf(&quot;%d&quot;,&amp;num);
    int res[num];
    memset(res,0,sizeof(res));

    int  nums[2][num];
    memset(nums,0,sizeof(nums));
    int i=0;
    while(i&lt;num){
        scanf(&quot;%d&quot;,&amp;nums[0][i++]);
    }
    int time=0;
    for(i=0;i&lt;num;i++){
        int key=nums[0][i];
            if(nums[1][i]!=1){
                int j=i+1;
                int flag=0;
                for(;j&lt;num;j++){
                    if(nums[0][j]&lt;key){
                        nums[1][j]=1;
                        nums[1][i]=1;
                        flag=1;
                    }
                }
                if(!flag){
                    res[time]=key;
                    time++;
                }
        }
    }
    printf(&quot;%d\n&quot;,time);
    for(int j=0;j&lt;time;j++){
        if(j==0){
            printf(&quot;%d&quot;,res[j]);
        }else{
            printf(&quot; %d&quot;,res[j]);
        }
    }
    printf(&quot;\n&quot;);
    return 0;
}</code></pre><p>思路二：<br>定义两个数组一个用来存储原数组，另一个用来存储对原数组排序后的数组。<br>遍历原数组，如果对应已经排好序的数组的相同位置也为那么这个数可能为主元（特例：3 2 1，1 2 3）还要保证他是原数组前面最大的哪一个，这又符合这两条件他才是主元，存入数组。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;

int cmp(const void *a, const void *b)
{
  return *((int *)a)-*((int *)b);
}

int main()
{
  int iNum=0;
  scanf(&quot;%d&quot;,&amp;iNum);
  int iData[iNum],iData_s[iNum];
  for(int i=0;i&lt;iNum;i++)
  {
    scanf(&quot;%d&quot;,&amp;iData[i]);
    iData_s[i]=iData[i];
  }
  qsort(iData_s,iNum,sizeof(int),cmp);//快速排序
  int iZY[iNum];
  int iCnt=0,iMax=0;
  for(int i=0;i&lt;iNum;i++)
  {
    if(iMax&lt;iData[i])//iMax就是前i-1个数字中最大的哪一个。
    {
      iMax=iData[i];
      if(iData[i]==iData_s[i])   //如果是前i个最大的数字，且对应排好序的数组数字也是它，那么它就是主元。
      {
        iZY[iCnt++]=iData[i];
      }
    }
  }
  printf(&quot;%d\n&quot;,iCnt);//下面两种输出方法，区别在于icnt=0的情况
  for(int i=0;i&lt;iCnt;i++)
  {
    if(i==0)
    {
      printf(&quot;%d&quot;,iZY[i]);
    }
    else
    {
      printf(&quot; %d&quot;,iZY[i]);
    }
  }
  printf(&quot;\n&quot;);//一个测试点好像有毛病，当主元数目为0时，还要要输出个换行。
 return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1046</title>
    <url>/2019/09/26/PTA-Basic-1046/</url>
    <content><![CDATA[<p>题目：</p>
<p>划拳是古老中国酒文化的一个有趣的组成部分。酒桌上两人划拳的方法为：每人口中喊出一个数字，同时用手比划出一个数字。如果谁比划出的数字正好等于两人喊出的数字之和，谁就赢了，输家罚一杯酒。两人同赢或两人同输则继续下一轮，直到唯一的赢家出现。</p>
<p>下面给出甲、乙两人的划拳记录，请你统计他们最后分别喝了多少杯酒。</p>
<p>输入格式：<br>输入第一行先给出一个正整数 N（≤100），随后 N 行，每行给出一轮划拳的记录，格式为：</p>
<p>甲喊 甲划 乙喊 乙划<br>其中喊是喊出的数字，划是划出的数字，均为不超过 100 的正整数（两只手一起划）。</p>
<p>输出格式：<br>在一行中先后输出甲、乙两人喝酒的杯数，其间以一个空格分隔。</p>
<p>输入样例：</p>
<pre><code>5
8 10 9 12
5 10 5 10
3 8 5 12
12 18 1 13
4 16 12 15</code></pre><p>输出样例：</p>
<pre><code>1 2</code></pre><p>分析：<br>定义变量存储甲乙败的次数，对每次输入的数字判断即可。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int num;
    scanf(&quot;%d&quot;,&amp;num);
    int i=0,j=0;
    int a,b,c,d;
    while(num--){
        scanf(&quot;%d %d %d %d&quot;,&amp;a,&amp;b,&amp;c,&amp;d);
        int res=a+c;
        if(b==res&amp;&amp;d!=res){
            j++;
        }else if(b!=res&amp;&amp;d==res){
            i++;
        }else{
            continue;
        }
    }
    printf(&quot;%d %d&quot;,i,j);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1047</title>
    <url>/2019/09/26/PTA-Basic-1047/</url>
    <content><![CDATA[<p>题目：</p>
<p>编程团体赛的规则为：每个参赛队由若干队员组成；所有队员独立比赛；参赛队的成绩为所有队员的成绩和；成绩最高的队获胜。</p>
<p>现给定所有队员的比赛成绩，请你编写程序找出冠军队。</p>
<p>输入格式：<br>输入第一行给出一个正整数 N（≤10<br>​4<br>​​ ），即所有参赛队员总数。随后 N 行，每行给出一位队员的成绩，格式为：队伍编号-队员编号 成绩，其中队伍编号为 1 到 1000 的正整数，队员编号为 1 到 10 的正整数，成绩为 0 到 100 的整数。</p>
<p>输出格式：<br>在一行中输出冠军队的编号和总成绩，其间以一个空格分隔。注意：题目保证冠军队是唯一的。</p>
<p>输入样例：</p>
<pre><code>6
3-10 99
11-5 87
102-1 0
102-3 100
11-9 89
3-2 61</code></pre><p>输出样例：</p>
<pre><code>11 176</code></pre><p>分析：此题与前面的挖掘机那题完全一样。<br>定义一个足够大的数组要把队伍编号都包含在内，然后把输输入一个队伍的相关信息，可以跳过中间一个数字的读取，队伍编号就是对应其在数组的位置，每次就<br>把输入的分数加到对应的位置，然后跟目前位置最大的比，如果比它大就把它存储下来，最后直接输出队伍编号，与分数。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int schools[10001];
    int max=0;
    int max_school=0;
    int n,a,b;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++){
        scanf(&quot;%d-%*d %d&quot;,&amp;a,&amp;b);//%*d代表不接受此输入。
        schools[a]=schools[a]+b;
        if(schools[a]&gt;max){
            max=schools[a];
            max_school=a;
        }
    }
    printf(&quot;%d %d&quot;,max_school,max);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1048</title>
    <url>/2019/09/26/PTA-Basic-1048/</url>
    <content><![CDATA[<p>题目：</p>
<p>本题要求实现一种数字加密方法。首先固定一个加密用正整数 A，对任一正整数 B，将其每 1 位数字与 A 的对应位置上的数字进行以下运算：对奇数位，对应位的数字相加后对 13 取余——这里用 J 代表 10、Q 代表 11、K 代表 12；对偶数位，用 B 的数字减去 A 的数字，若结果为负数，则再加 10。这里令个位为第 1 位。</p>
<p>输入格式：<br>输入在一行中依次给出 A 和 B，均为不超过 100 位的正整数，其间以空格分隔。</p>
<p>输出格式：<br>在一行中输出加密后的结果。</p>
<p>输入样例：</p>
<pre><code>1234567 368782971</code></pre><p>输出样例：</p>
<pre><code>3695Q8118</code></pre><p>分析：<br>定义三个字符串数组分别用来存储输入的两个字符串与处理后的结果，先定义一个反转字符串的函数。然后将两个字符串都反转一下然后对应开始遍历字符串，取长度最大的那个为上限，长度不够时那个位置对应的数字就是0相应的处理就可以了。<br>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
char * strrev(char *a){//反转字符串。
    char *b=a;
    int i=strlen(a)-1,j=0;
    char ch;
    while(i&gt;j){
        ch=a[i];
        a[i]=a[j];
        a[j]=ch;
        i--;
        j++;
    }
    return a;
}
int main(void){
    char strs1[101];
    char strs2[101];
    char result[101];
    memset(strs1,&apos;\0&apos;,101);
    memset(strs2,&apos;\0&apos;,101);
    memset(result,&apos;\0&apos;,101);
    scanf(&quot;%s %s&quot;,strs1,strs2);
    strrev(strs1);
    strrev(strs2);
    int i=0;
    int len=(strlen(strs1)&gt;strlen(strs2)?strlen(strs1):strlen(strs2));//取最长的那个为上限。
    while(len--){
        i++;
        if(i%2!=0){//为奇数
            int x=(strs1[i-1]-&apos;0&apos;)&gt;-1?(strs1[i-1]-&apos;0&apos;):0;
            int y=(strs2[i-1]-&apos;0&apos;)&gt;-1?(strs2[i-1]-&apos;0&apos;):0;
            y=(y+x)%13;
            if(y&lt;10){
                result[i-1]=y+&apos;0&apos;;
            }else{
                switch(y){
                    case 10:result[i-1]=&apos;J&apos;;break;
                    case 11:result[i-1]=&apos;Q&apos;;break;
                    case 12:result[i-1]=&apos;K&apos;;break;
                }
            }
        }else{
            int x=(strs1[i-1]-&apos;0&apos;)&gt;-1?(strs1[i-1]-&apos;0&apos;):0;
            int y=(strs2[i-1]-&apos;0&apos;)&gt;-1?(strs2[i-1]-&apos;0&apos;):0;
            y=y-x;
            if(y&lt;0){
                y=y+10;
            }
            result[i-1]=y+&apos;0&apos;;
        }
    }
    strrev(result);//最后要将数组反转一下。
    printf(&quot;%s&quot;,result);
    return 0;
}</code></pre><p>###总结：做任何算法包括事情前都要有一个大致思路，不然就会在做的过程中迷失方向。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1049</title>
    <url>/2019/09/27/PTA-Basic-1049/</url>
    <content><![CDATA[<p>题目：</p>
<p>给定一个正数数列，我们可以从中截取任意的连续的几个数，称为片段。例如，给定数列 { 0.1, 0.2, 0.3, 0.4 }，我们有 (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) (0.4) 这 10 个片段。</p>
<p>给定正整数数列，求出全部片段包含的所有的数之和。如本例中 10 个片段总和是 0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0。</p>
<p>输入格式：<br>输入第一行给出一个不超过 10<br>​5<br>​​  的正整数 N，表示数列中数的个数，第二行给出 N 个不超过 1.0 的正数，是数列中的数，其间以空格分隔。</p>
<p>输出格式：<br>在一行中输出该序列所有片段包含的数之和，精确到小数点后 2 位。</p>
<p>输入样例：</p>
<pre><code>4

0.1 0.2 0.3 0.4</code></pre><p>输出样例：</p>
<pre><code>5.00</code></pre><p>分析：<br>此题并不难，只要在做题目前，思考一下，不难得出一个推导的公式<br>（sum = n1<em>n</em>1+n2<em>(n-1)*2+n3</em>(n-2)<em>3+…(nk</em>(n-k-1)*k)…）<br>注意点：双精度浮点数输入输出时用%lf，单精度用%f，不能混合用不然输入或输出的数据可能会出错。<br>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int num;
    scanf(&quot;%d&quot;,&amp;num);
    double nums[num];
    int i=0;
    while(i&lt;num){
        scanf(&quot;%lf&quot;,&amp;nums[i]);
        i++;
    }
    double sum=0;
    int n=num;
    for(i=0;i&lt;num;i++){
        sum=sum+1.0*nums[i]*n*(i+1);
        n--;
    }
    printf(&quot;%.2f&quot;,sum);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1051</title>
    <url>/2019/09/27/PTA-Basic-1051/</url>
    <content><![CDATA[<p>复数可以写成 (A+Bi) 的常规形式，其中 A 是实部，B 是虚部，i 是虚数单位，满足 i<br>​2<br>​​ =−1；也可以写成极坐标下的指数形式 (R×e<br>​(Pi)<br>​​ )，其中 R 是复数模，P 是辐角，i 是虚数单位，其等价于三角形式 R(cos(P)+isin(P))。</p>
<p>现给定两个复数的 R 和 P，要求输出两数乘积的常规形式。</p>
<p>输入格式：<br>输入在一行中依次给出两个复数的 R<br>​1<br>​​ , P<br>​1<br>​​ , R<br>​2<br>​​ , P<br>​2<br>​​ ，数字间以空格分隔。</p>
<p>输出格式：<br>在一行中按照 A+Bi 的格式输出两数乘积的常规形式，实部和虚部均保留 2 位小数。注意：如果 B 是负数，则应该写成 A-|B|i 的形式。</p>
<p>输入样例：</p>
<pre><code>2.3 3.5 5.2 0.4</code></pre><p>输出样例：</p>
<pre><code>-8.68-8.23i</code></pre><p>思路：</p>
<pre><code>将输入的复数模，与对应的叫反别转化为直角坐标下的实部与虚部。然后符合复数乘法即可。

注意：双精度浮点数输入输出时用%lf，单精度用%f，不能混合用不然输入或输出的数据可能会出错。</code></pre><p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
int main(){
    double a1,a2,b1,b2;
    double r1,r2,p1,p2;
    scanf(&quot;%lf %lf %lf %lf&quot;,&amp;r1,&amp;p1,&amp;r2,&amp;p2);
    a1=r1*cos(p1);
    a2=r1*sin(p1);
    b1=r2*cos(p2);
    b2=r2*sin(p2);
    double s1=a1*b1-a2*b2;
    double s2=a1*b2+a2*b1;
    if (fabs(s1) &lt; 0.001) s1 = 0;
    if (fabs(s2) &lt; 0.001) s2 = 0;
    if (s2 &gt;= 0)
        printf(&quot;%.2f+%.2fi&quot;, s1, s2);
    else
        printf(&quot;%.2f%.2fi&quot;, s1, s2);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1052</title>
    <url>/2019/09/28/PTA-Basic-1052/</url>
    <content><![CDATA[<p>题目：</p>
<p>萌萌哒表情符号通常由“手”、“眼”、“口”三个主要部分组成。简单起见，我们假设一个表情符号是按下列格式输出的：</p>
<pre><code>[左手]([左眼][口][右眼])[右手]</code></pre><p>现给出可选用的符号集合，请你按用户的要求输出表情。</p>
<p>输入格式：<br>输入首先在前三行顺序对应给出手、眼、口的可选符号集。每个符号括在一对方括号 []内。题目保证每个集合都至少有一个符号，并不超过 10 个符号；每个符号包含 1 到 4 个非空字符。</p>
<p>之后一行给出一个正整数 K，为用户请求的个数。随后 K 行，每行给出一个用户的符号选择，顺序为左手、左眼、口、右眼、右手——这里只给出符号在相应集合中的序号（从 1 开始），数字间以空格分隔。</p>
<p>输出格式：<br>对每个用户请求，在一行中输出生成的表情。若用户选择的序号不存在，则输出 Are you kidding me? @/@。</p>
<p>输入样例：</p>
<pre><code>[╮][╭][o][~\][/~]  [&lt;][&gt;]
 [╯][╰][^][-][=][&gt;][&lt;][@][⊙]
[Д][▽][_][ε][^]  ...
4
1 1 2 2 2
6 8 1 5 5
3 3 4 3 3
2 10 3 9 3</code></pre><p>输出样例：</p>
<pre><code>╮(╯▽╰)╭
&lt;(@Д=)/~
o(^ε^)o
Are you kidding me? @\/@</code></pre><p>思路：<br>第一行给出手的符号库，<br>第二行给出眼的符号库，<br>第三行给出口的符号库。<br>定义三个二维数组，每一行存储字符串。<br>然后存储输入进的数字，<br>根据每一行对手，眼，口的坐标选择，输出相应的字符串符号。若没有，则输出Are you kidding me? @/@<br>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main()
{
  char Hand[10][5]={0};
  char Eye[10][5]={0};
  char Mouth[10][5]={0};
  char temp=0;
  int iHand=0,iEye=0,iMouth=0;//字符计数
  while((temp=getchar())!=&apos;\n&apos;)
  {
    if(temp==&apos;[&apos;)
    {
      scanf(&quot;%[^]]&quot;,szHand[iHand++]);
    }
  }
  while((temp=getchar())!=&apos;\n&apos;)
  {
    if(temp==&apos;[&apos;)
    {
      scanf(&quot;%[^]]&quot;,szEye[iEye++]);
    }
  }
  while((temp=getchar())!=&apos;\n&apos;)
  {
    if(temp==&apos;[&apos;)
    {
      scanf(&quot;%[^]]&quot;,szMouth[iMouth++]);
    }
  }
  int iNum=0,iMood[5]={0};
  scanf(&quot;%d&quot;,&amp;iNum);
  for(int i=0;i&lt;iNum;i++)
  {
    for(int j=0;j&lt;5;j++)
    {
      scanf(&quot;%d&quot;,iMood+j);
    }
    //选择输出，注意表情是从1开始，数组是从0开始
    if(iMood[0]&gt;0&amp;&amp;iMood[0]&lt;=iHand
     &amp;&amp;iMood[1]&gt;0&amp;&amp;iMood[1]&lt;=iEye
     &amp;&amp;iMood[2]&gt;0&amp;&amp;iMood[2]&lt;=iMouth
     &amp;&amp;iMood[3]&gt;0&amp;&amp;iMood[3]&lt;=iEye
     &amp;&amp;iMood[4]&gt;0&amp;&amp;iMood[4]&lt;=iHand)
     {
       printf(&quot;%s(%s%s%s)%s&quot;,szHand[iMood[0]-1],szEye[iMood[1]-1],
           szMouth[iMood[2]-1],szEye[iMood[3]-1],szHand[iMood[4]-1]);
     }
     else
     {
       printf(&quot;Are you kidding me? @\\/@&quot;);
     }
     if(i!=iNum-1)
     {
       printf(&quot;\n&quot;);
     }
  }
  return 0;

}</code></pre><p>注意：<br>scanf函数有一种格式控制可以输入指定符号前的字符串，即%[^…]，其中…可以是任意字符，之前的任意多个字符会被输入，如果加上<em>，即%</em>[^…]，就是忽略…前的任意多字符。因为有[]两个字符作为数据的前后标记，因此可以用getchar试探读入，读入回车则结束，读入[则接收数据。<br>参考链接：<a href="https://blog.csdn.net/bawangtu/article/details/81287293">https://blog.csdn.net/bawangtu/article/details/81287293</a></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1054</title>
    <url>/2019/09/28/PTA-Basic-1054/</url>
    <content><![CDATA[<p>题目：</p>
<p>本题的基本要求非常简单：给定 N 个实数，计算它们的平均值。但复杂的是有些输入数据可能是非法的。一个“合法”的输入是 [−1000,1000] 区间内的实数，并且最多精确到小数点后 2 位。当你计算平均值的时候，不能把那些非法的数据算在内。</p>
<p>输入格式：<br>输入第一行给出正整数 N（≤100）。随后一行给出 N 个实数，数字间以一个空格分隔。</p>
<p>输出格式：<br>对每个非法输入，在一行中输出 ERROR: X is not a legal number，其中 X 是输入。最后在一行中输出结果：The average of K numbers is Y，其中 K 是合法输入的个数，Y 是它们的平均值，精确到小数点后 2 位。如果平均值无法计算，则用 Undefined 替换 Y。如果 K 为 1，则输出 The average of 1 number is Y。</p>
<p>输入样例 1：</p>
<pre><code>7
5 -3.2 aaa 9999 2.3.4 7.123 2.35</code></pre><p>输出样例 1：</p>
<pre><code>ERROR: aaa is not a legal number
ERROR: 9999 is not a legal number
ERROR: 2.3.4 is not a legal number
ERROR: 7.123 is not a legal number
The average of 3 numbers is 1.38</code></pre><p>输入样例 2：</p>
<pre><code>2

aaa -9999</code></pre><p>输出样例 2：</p>
<pre><code>ERROR: aaa is not a legal number
ERROR: -9999 is not a legal number
The average of 0 numbers is Undefined</code></pre><p>分析：</p>
<p>定义一个判断数字是否合法的函数（数字以数字或‘-’开头，不能只有‘-’，‘.’后面的数字长度不能大于2），注意如果输入数字中只有一个合法，不要不要用总和去除以1计算结果，而是直接输出The average of 1 number is ？。还有就是字符串赋值并不是想Java中的那样直接给就可以了，而是要调用函数复制。</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
int check(char* s);
int main(void){
    int n=0;
    scanf(&quot;%d&quot;,&amp;n);
    char str[n][10000];
    char s[10000];
    int i=0;
    double sum=0;
    int m=n;
    while(n--){
        scanf(&quot;%s&quot;,s);
        if(check(s)){
            sum+=atof(s);//函数atof将数字字符串转化为数字。
        }else{
            strcpy(str[i++],s);
        }
    }
    m=m-i;
    for(int k=0;k&lt;i;k++){
        printf(&quot;ERROR: %s is not a legal number\n&quot;,str[k]); 
    }
    if(m&gt;1)
    printf(&quot;The average of %d numbers is %.2lf\n&quot;,m,sum/m);
    if(m==0)
    printf(&quot;The average of 0 numbers is Undefined\n&quot;);
    if(m==1)
    printf(&quot;The average of 1 number is %.2lf&quot;,sum);
    return 0;
}
int  check(char* s){
    int sum=0;
    int n=0;
    for(int i=0;i&lt;strlen(s);i++){
        if(i==0){
            if(!(s[i]==&apos;-&apos;||(s[i]&lt;=&apos;9&apos;&amp;&amp;s[i]&gt;=&apos;0&apos;))){
                return 0;
            }else{
                if(strlen(s)==1&amp;&amp;s[i]==&apos;-&apos;){
                    return 0;
                }
            }
        }else{
            if(sum&gt;0){
                n++;
                if(n&gt;2){
                    return 0;
                }
            }
            if(s[i]==&apos;.&apos;){
                sum++;
                if(sum&gt;=2){
                    return 0;
                }
            }
        }
    }
    double res=atof(s);
    if(res&gt;1000||res&lt;-1000){
        return 0;
    }
    return 1;
} </code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1053</title>
    <url>/2019/09/28/PTA-Basic-1053/</url>
    <content><![CDATA[<p>在不打扰居民的前提下，统计住房空置率的一种方法是根据每户用电量的连续变化规律进行判断。判断方法如下：</p>
<p>在观察期内，若存在超过一半的日子用电量低于某给定的阈值 e，则该住房为“可能空置”；</p>
<p>若观察期超过某给定阈值 D 天，且满足上一个条件，则该住房为“空置”。</p>
<p>现给定某居民区的住户用电量数据，请你统计“可能空置”的比率和“空置”比率，即以上两种状态的住房占居民区住房总套数的百分比。</p>
<p>输入格式：<br>输入第一行给出正整数 N（≤1000），为居民区住房总套数；正实数 e，即低电量阈值；正整数 D，即观察期阈值。随后 N 行，每行按以下格式给出一套住房的用电量数据：</p>
<p>K E<br>​1<br>​​  E<br>​2<br>​​  … E<br>​K<br>​​ </p>
<p>其中 K 为观察的天数，E<br>​i<br>​​  为第 i 天的用电量。</p>
<p>输出格式：<br>在一行中输出“可能空置”的比率和“空置”比率的百分比值，其间以一个空格分隔，保留小数点后 1 位。</p>
<p>输入样例：</p>
<pre><code>5 0.5 10
6 0.3 0.4 0.5 0.2 0.8 0.6
10 0.0 0.1 0.2 0.3 0.0 0.8 0.6 0.7 0.0 0.5
5 0.4 0.3 0.5 0.1 0.7
11 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1
11 2 2 2 1 1 0.1 1 0.1 0.1 0.1 0.1</code></pre><p>输出样例：</p>
<pre><code>40.0% 20.0%</code></pre><p>（样例解释：第2、3户为“可能空置”，第4户为“空置”，其他户不是空置。）</p>
<p>分析：<br>按题目走。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int sum=0;
    double e,d;
    scanf(&quot;%d %lf %lf&quot;,&amp;sum,&amp;e,&amp;d);
    int maybe=0,must=0;
    for(int i=0;i&lt;sum;i++){
        int days=0;
        int sum=0;
        scanf(&quot;%d&quot;,&amp;days);
        for(int j=0;j&lt;days;j++){
            double en;
            scanf(&quot;%lf&quot;,&amp;en);
            if(en&lt;e){
                sum++;
            }
        }
        if(days&gt;d&amp;&amp;sum&gt;(int)(days/2)){
            must++;
        }else if(sum&gt;(int)(days/2)){
            maybe++;
        }else{    
        }
    }
    printf(&quot;%.1f&quot;,100*(maybe*1.0/sum));
    printf(&quot;%c &quot;,&apos;%&apos;);
    printf(&quot;%.1f&quot;,100*(must*1.0/sum));
    printf(&quot;%c&quot;,&apos;%&apos;);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1055</title>
    <url>/2019/09/29/PTA-Basic-1055/</url>
    <content><![CDATA[<p>题目:</p>
<p>拍集体照时队形很重要，这里对给定的 N 个人 K 排的队形设计排队规则如下：</p>
<p>每排人数为 N/K（向下取整），多出来的人全部站在最后一排；</p>
<p>后排所有人的个子都不比前排任何人矮；</p>
<p>每排中最高者站中间（中间位置为 m/2+1，其中 m 为该排人数，除法向下取整）；</p>
<p>每排其他人以中间人为轴，按身高非增序，先右后左交替入队站在中间人的两侧（例如5人身高为190、188、186、175、170，则队形为175、188、190、186、170。这里假设你面对拍照者，所以你的左边是中间人的右边）。</p>
<p>若多人身高相同，则按名字的字典序升序排列。这里保证无重名。</p>
<p>现给定一组拍照人，请编写程序输出他们的队形。</p>
<p>输入格式：<br>每个输入包含 1 个测试用例。每个测试用例第 1 行给出两个正整数 N（≤10<br>​4<br>​​ ，总人数）和 K（≤10，总排数）。随后 N 行，每行给出一个人的名字（不包含空格、长度不超过 8 个英文字母）和身高（[30, 300] 区间内的整数）。</p>
<p>输出格式：<br>输出拍照的队形。即K排人名，其间以空格分隔，行末不得有多余空格。注意：假设你面对拍照者，后排的人输出在上方，前排输出在下方。</p>
<p>输入样例：</p>
<pre><code>10 3
Tom 188
Mike 170
Eva 168
Tim 160
Joe 190
Ann 168
Bob 175
Nick 186
Amy 160
John 159</code></pre><p>输出样例：</p>
<pre><code>Bob Tom Joe Nick
Ann Mike Eva
Tim Amy John</code></pre><p>分析：</p>
<p>定一个一个结构体，其拥有姓名，身高。然后将输入的信息转化为人，然后根据题目要求降序排序，先输出最后一排，接着倒数第二排，每排定义适合题意的个数个人，然后根据题目，先将最大的人插入中间，接着依左右，左右（题目中的右左为面向摄像机的方向）赋值。<br>最后遍历输出。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt; 
#include&lt;stdlib.h&gt;
int cmp(const void *a ,const void *b);
typedef struct {
    char name[9];
    int height;
}human;
int main(void){
    int sum,n;
    scanf(&quot;%d %d&quot;,&amp;sum,&amp;n);
    human humen[sum];
    for(int i=0;i&lt;sum;i++){
        scanf(&quot;%s %d&quot;,&amp;humen[i].name,&amp;(humen[i].height));//输入到人的数组中去
        getchar();
    }
    qsort(humen,sum,sizeof(human),cmp);//对人的数组进行重大到小排序。
    int begin=0;
    int x=0;
    while(begin&lt;sum){
        if(begin==0){
             x=sum/n+sum%n;//如果是最后一排的话要将剩余的人数插入到其中
        }else{
             x=sum/n;//如果不是最后一排的话，直接得到人数。
        }
        int index=x/2;//中间的人，题目中的m/2+1是根据下标从1开始计算的。
            human hus[x];
            strcpy(hus[index--].name,humen[begin++].name);//先将中间的人赋值，并将人修改为左边的哪一个人。
            int step=1;//初始步长为1
            while(index&gt;-1&amp;&amp;index&lt;x){
                step++;//左右相距的人头数（刚进入是相距2个人头）
                strcpy(hus[index].name,humen[begin++].name);
                index=index+step;//每次操作完都要改变坐标此处是将下标由左边变化到右边
                if(!(index&gt;-1&amp;&amp;index&lt;x))//检验变化后的坐标是否合法。
                    break;
                strcpy(hus[index].name,humen[begin++].name);//给右边赋值
                step++;//每一次左右赋值完之后，后面一个左右的距离就多了一个人头。
                index=index-step;//将下标放到下一次要赋值的人头处。
            }
            for(int i=0;i&lt;x;i++){//输出这一排的人。
                printf(&quot;%s%c&quot;,hus[i].name,(i==x-1?&apos;\n&apos;:&apos; &apos;));
            }
    }
    return 0;
}
int cmp(const void *a,const void *b){//先依据身高排序（降序），如果身高相同依据姓名排序（升序）
    human human1=*(human *)a;
    human human2=*(human *)b;
    if(human1.height&gt;human2.height){
        return -1;
    }else{
        if(human1.height==human2.height){
            return strcmp(human1.name,human2.name);
        }else{
            return 1;
        }
    }
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1050</title>
    <url>/2019/09/27/PTA-Basic-1050/</url>
    <content><![CDATA[<p>本题要求将给定的 N 个正整数按非递增的顺序，填入“螺旋矩阵”。所谓“螺旋矩阵”，是指从左上角第 1 个格子开始，按顺时针螺旋方向填充。要求矩阵的规模为 m 行 n 列，满足条件：m×n 等于 N；m≥n；且 m−n 取所有可能值中的最小值。</p>
<p>输入格式：<br>输入在第 1 行中给出一个正整数 N，第 2 行给出 N 个待填充的正整数。所有数字不超过 10<br>​4<br>​​ ，相邻数字以空格分隔。</p>
<p>输出格式：<br>输出螺旋矩阵。每行 n 个数字，共 m 行。相邻数字以 1 个空格分隔，行末不得有多余空格。</p>
<p>输入样例：</p>
<pre><code>12
37 76 20 98 76 42 53 95 60 81 58 93</code></pre><p>输出样例：</p>
<pre><code>98 95 93
42 37 81
53 20 76
58 60 76</code></pre><p>分析：<br>    难点：</p>
<pre><code>1.求一个数字最接近的两个约数。//用于求行数与列数
2.每一层输出时可能会位置出错。</code></pre><p>思路：</p>
<pre><code>对一个数开平方，然后从它的根向下（包含跟）找

到的第一个能把它整除的数就是最接近的两个数字

中的小的哪一个，大的哪一个只要原数取整即可。且大的哪一个为行数，小的哪一个为列数。

对输入进来的数组进行排序，然后定义一个二维数组存储螺旋矩阵（从最外面一层开始，分为上部赋值，

右部赋值，下部赋值，左部赋值，然后进行第二层的赋值。。。）

把螺旋矩阵看成一个不断重复相同操作的过程。</code></pre><p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;math.h&gt;
//求一个数字最接近平方根的数字，就是其接近的约数。
int func(int n){
    int m=sqrt(n);
    while(m!=1){
        if(n%m==0){
            return m;
        }
        m--;
    }
    return 1;
}
int cmp(const void *a,const void *b){
    return *(int *)b-*(int *)a;
}
int main(){
    int N,n,m,t=0;
    scanf(&quot;%d&quot;,&amp;N);
    int a[N];
    while(t&lt;N){
        scanf(&quot;%d&quot;,&amp;a[t++]);
    }
    qsort(a,N,sizeof(int),cmp);//对数组排序从大到小
    n=func(N); //列数
    m=N/n;//获得行数，行数一定大于等于列数
    int b[m][n]; //定义一个二维矩阵
    int level=n/2+n%2; //一共有几层螺旋圈
    t=0;
    int j=0;
    for(int i=1;i&lt;=level;i++){
        //实现第i层的上面部分.
         for( j=i-1;j&lt;=n-i&amp;&amp;t&lt;N;j++){//行数为[i-1]列数为[i-1,n-i]
             b[i-1][j]=a[t++];
         }
         //实现第i层的右边
         for( j=i;j&lt;=(m-i)&amp;&amp;t&lt;N;j++){//行数为[i,m-i][n-i]
             b[j][n-i]=a[t++];
         }
         //实现第i层的下面
         for( j=n-i-1;j&gt;=(i-1)&amp;&amp;t&lt;N;j--){//行数为[m-i]列数为[n-i,i-1]
             b[m-i][j]=a[t++];
         }
         //实现第i层的左面
         for( j=m-i-1;j&gt;(i-1)&amp;&amp;t&lt;N;j--){//行数为[m-i-1，i]列数为[i-1]
             b[j][i-1]=a[t++];
         }
    }
    for(int i=0;i&lt;m;i++){
        for(int j=0;j&lt;n;j++){
            if(j!=0)
                printf(&quot; &quot;);
            printf(&quot;%d&quot;,b[i][j]);
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1058</title>
    <url>/2019/10/07/PTA-Basic-1058/</url>
    <content><![CDATA[<p>题目：</p>
<p>批改多选题是比较麻烦的事情，本题就请你写个程序帮助老师批改多选题，并且指出哪道题错的人最多。</p>
<p>输入格式：<br>输入在第一行给出两个正整数 N（ ≤ 1000）和 M（≤ 100），分别是学生人数和多选题的个数。随后 M 行，每行顺次给出一道题的满分值（不超过 5 的正整数）、选项个数（不少于 2 且不超过 5 的正整数）、正确选项个数（不超过选项个数的正整数）、所有正确选项。注意每题的选项从小写英文字母 a 开始顺次排列。各项间以 1 个空格分隔。最后 N 行，每行给出一个学生的答题情况，其每题答案格式为 (选中的选项个数 选项1 ……)，按题目顺序给出。注意：题目保证学生的答题情况是合法的，即不存在选中的选项数超过实际选项数的情况。</p>
<p>输出格式：<br>按照输入的顺序给出每个学生的得分，每个分数占一行。注意判题时只有选择全部正确才能得到该题的分数。最后一行输出错得最多的题目的错误次数和编号（题目按照输入的顺序从 1 开始编号）。如果有并列，则按编号递增顺序输出。数字间用空格分隔，行首尾不得有多余空格。如果所有题目都没有人错，则在最后一行输出 Too simple。</p>
<p>输入样例：</p>
<pre><code>3 4 
3 4 2 a c
2 5 1 b
5 3 2 b c
1 5 4 a b d e
(2 a c) (2 b d) (2 a c) (3 a b e)
(2 a c) (1 b) (2 a b) (4 a b d e)
(2 b d) (1 e) (2 b c) (4 a b c d)</code></pre><p>输出样例：</p>
<pre><code>6
5
2 
2 3 4</code></pre><p>分析：</p>
<p>定义一个非常大的数组存储所有可能的题目答案，定义一个非常大的数组存储每题的得分，定义一个非常大的数组存储每题出错的次数，定义一个非常大题目存储媒体正确答案的个数，定义一个非常大的学生数组。<br>在输入是就开始计算每一位学生的得分以及此题的出错次数。<br>最后输出每一位学生的分数，以及最高出错次数，和对应的题目（按升序排列）。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
int timu[100][5]={0};//定义一个二维数组存储题目正确的答案初始化每个都是0（表示错误）
int score[100]={0};//存储每一题目的得分
int time[100]={0};//存储每个题目的出错次数
int righttime[100]={0}; //存储每个题目标准答案的个数
int stu[1001]={0};//存储每个学生的得分
int main(void){
    int n=0,m=0;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);//输入学生数，与题目数。
    for(int i=0;i&lt;m;i++){
        int x=0;
        scanf(&quot;%d %*d %d&quot;,&amp;score[i],&amp;righttime[i]);//将每一个题目的分数存储到数组中去，并存储正确答案的个数以便下面计算答对的题目数是否为全部的正确数目
        char ch;
        while((ch=getchar())!=&apos;\n&apos;){//此处开始读取正确的选项。如果读到a就将timu数组的第0为赋值为1.
            if(ch&lt;=&apos;e&apos;&amp;&amp;ch&gt;=&apos;a&apos;){
                int k=ch-&apos;a&apos;;
                timu[i][k]=1;
            }
        }
    }
    int max=0; 
    for(int i=0;i&lt;n;i++){
        int t=0;
        char ch;
        int step0=0;//计算输入的选项的个数
        int step1=0;//计算选对的个数
        while((ch=getchar())!=&apos;\n&apos;){
            if(ch==&apos;(&apos;){ //读到这个就代表开始了新的一个题目，要将选项数目，答对数目初始化为0.
                step0=0;
                step1=0;
                continue;
            }else if(ch==&apos; &apos;){
                continue;
            }else if(ch&lt;=&apos;5&apos;&amp;&amp;ch&gt;=&apos;0&apos;){
                step0=ch-&apos;0&apos;; //计算选项数目
            }else{
                if(ch==&apos;)&apos;){//如果输入的选项都对但是总数不达标也不对。
                    if(step0==step1&amp;&amp;step0==righttime[t]){//对的步数符合初始化步数 
                        stu[i]+=score[t];//将分数加到第i为学生上去
                    }else{//否则此题就出错了
                        time[t]++;//这个题目的出错次数加1
                        if(time[t]&gt;max){
                            max=time[t];//如果比出错次数最大值大就交换值
                        }
                    }
                    t++;//下一题 
                }
                if(ch&lt;=&apos;e&apos;&amp;&amp;ch&gt;=&apos;a&apos;){
                    int k=ch-&apos;a&apos;;
                    if(timu[t][k]){//输入的选项对应的数组下标有值表示输入的答案是正确的
                        step1++;//对的步数加1 
                    }
                }
            }
        }
    }
    for(int i=0;i&lt;n;i++){
        printf(&quot;%d\n&quot;,stu[i]);//输出每一位学生的得分
    }
    if(max&gt;0){//如果最大值不为0就要统计出错的题目
    printf(&quot;%d&quot;,max);
        for(int i=0;i&lt;m;i++){
            if(time[i]==max){
                printf(&quot; %d&quot;,i+1);
            }
        }
    }else{//否则直接输出
        printf(&quot;Too simple&quot;);
    }
    return 0;
} </code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1057</title>
    <url>/2019/09/29/PTA-Basic-1057/</url>
    <content><![CDATA[<p>给定一串长度不超过 10<br>​5<br>​​  的字符串，本题要求你将其中所有英文字母的序号（字母 a-z 对应序号 1-26，不分大小写）相加，得到整数 N，然后再分析一下 N 的二进制表示中有多少 0、多少 1。例如给定字符串 PAT (Basic)，其字母序号之和为：16+1+20+2+1+19+9+3=71，而 71 的二进制是 1000111，即有 3 个 0、4 个 1。</p>
<p>输入格式：<br>输入在一行中给出长度不超过 10<br>​5<br>​​ 、以回车结束的字符串。</p>
<p>输出格式：<br>在一行中先后输出 0 的个数和 1 的个数，其间以空格分隔。</p>
<p>输入样例：</p>
<pre><code>PAT (Basic)</code></pre><p>输出样例：</p>
<pre><code>3 4</code></pre><p>分析：</p>
<p>一个一个字符读取并将输入的字符化为小写形式，如果是字母就将其对应的值加到和上。定义一个长度为2的整型数组，0位存储二进制中0的个数，1位存储二进制中1的个数，二进制位数数字除以2的余数，注意数字为0数二进制位的0位不为1，即数字为0时不计算其二进制位。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include&lt;string.h&gt;
int sum(char *a);
int main()
{
    char ch=&apos;\0&apos;;
    int total=0;
    while((ch=getchar())!=&apos;\n&apos;){
        ch=tolower(ch);
        if(ch&lt;=&apos;z&apos;&amp;&amp;ch&gt;=&apos;a&apos;){
            total=total+ch-&apos;a&apos;+1;
        }
    }
    int a[]={0,0};
    while(total){
            a[total%2]++;
            total=total/2;
    }
    printf(&quot;%d %d&quot;,a[0],a[1]);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1061</title>
    <url>/2019/10/07/PTA-Basic-1061/</url>
    <content><![CDATA[<p>题目：</p>
<p>判断题的评判很简单，本题就要求你写个简单的程序帮助老师判题并统计学生们判断题的得分。</p>
<p>输入格式：<br>输入在第一行给出两个不超过 100 的正整数 N 和 M，分别是学生人数和判断题数量。第二行给出 M 个不超过 5 的正整数，是每道题的满分值。第三行给出每道题对应的正确答案，0 代表“非”，1 代表“是”。随后 N 行，每行给出一个学生的解答。数字间均以空格分隔。</p>
<p>输出格式：</p>
<p>按照输入的顺序输出每个学生的得分，每个分数占一行。</p>
<p>输入样例：</p>
<pre><code>3 6
2 1 3 3 4 5
0 0 1 0 1 1
0 1 1 0 0 1
1 0 1 0 1 0
1 1 0 0 1 1</code></pre><p>输出样例：</p>
<pre><code>13
11
12</code></pre><p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int n=0,m=0;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    int score[2][m];
    int stu[n];
    int k=0;
    int x=0;
    for(int i=0;i&lt;n+2;i++){
            stu[x]=0;
        for(int j=0;j&lt;m;j++){
                scanf(&quot;%d&quot;,&amp;k);
            if(i==0){
            score[0][j]=k;
        }else if(i==1){
            score[1][j]=k;
        }else{
            if(k==score[1][j]){
                stu[x]+=score[0][j];
            }
        }
        }
        if(i!=0&amp;&amp;i!=1){
            x++;
        }
    }

    for(int i=0;i&lt;x;i++){
            printf(&quot;%d\n&quot;,stu[i]);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1059</title>
    <url>/2019/10/07/PTA-Basic-1059/</url>
    <content><![CDATA[<p>题目：<br>C 语言竞赛是浙江大学计算机学院主持的一个欢乐的竞赛。既然竞赛主旨是为了好玩，颁奖规则也就制定得很滑稽：</p>
<p>0、冠军将赢得一份“神秘大奖”（比如很巨大的一本学生研究论文集……）。<br>1、排名为素数的学生将赢得最好的奖品 —— 小黄人玩偶！<br>2、其他人将得到巧克力。<br>给定比赛的最终排名以及一系列参赛者的 ID，你要给出这些参赛者应该获得的奖品。</p>
<p>输入格式：<br>输入第一行给出一个正整数 N（≤10<br>​4<br>​​ ），是参赛者人数。随后 N 行给出最终排名，每行按排名顺序给出一位参赛者的 ID（4 位数字组成）。接下来给出一个正整数 K 以及 K 个需要查询的 ID。</p>
<p>输出格式：<br>对每个要查询的 ID，在一行中输出 ID: 奖品，其中奖品或者是 Mystery Award（神秘大奖）、或者是 Minion（小黄人）、或者是 Chocolate（巧克力）。如果所查 ID 根本不在排名里，打印 Are you kidding?（耍我呢？）。如果该 ID 已经查过了（即奖品已经领过了），打印 ID: Checked（不能多吃多占）。</p>
<p>输入样例：</p>
<pre><code>6
1111
6666
8888
1234
5555
0001
6
8888
0001
1111
2222
8888
2222</code></pre><p>输出样例：</p>
<pre><code>8888: Minion
0001: Chocolate
1111: Mystery Award
2222: Are you kidding?
8888: Checked
2222: Are you kidding?</code></pre><p>分析：题目要求根据输入的排名给出相应的奖品</p>
<pre><code>冠军-----Mystery Award
素数排名-----Minion
其他--------Chocolate
已经输入过一次的人-----Checked
没有的人------Are you kidding?


#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
int pops[2][1000000000];//定义一个二维数组
int isPrime(int n){//判断一个数是否是素数的函数第一行存储排名（从1开始不从0开始因为初始化数组是每个都是0）
    if(n==2){
        return 1;
    }else{
        if(n%2==0){
            return 0;
        }else{
            for(int i=3;i&lt;sqrt(n+1);i+=2){
                if(n%i==0){
                    return 0;
                }
            }
            return 1;
        }
    }
}
int main(void){
    int n=0;
    scanf(&quot;%d&quot;,&amp;n);
    int m=0;
    for(int i=1;i&lt;=n;i++){
        scanf(&quot;%d&quot;,&amp;m);
        pops[0][m]=i;//第一行存储排名，第二行存储查询的次数
    }
    scanf(&quot;%d&quot;,&amp;m);
    int k=0;
    for(int i=0;i&lt;m;i++){
        scanf(&quot;%d&quot;,&amp;k);
        printf(&quot;%04d: &quot;,k);
        if(pops[0][k]==0){//如果输入的数字对应的排名是0就表示选手中没有这个人
            printf(&quot;Are you kidding?&quot;);
        }else if(pops[1][k]==0){//否则如果查询次数为0，即一次都没有看过此人
            if(pops[0][k]==1){//如果排名为1
            printf(&quot;Mystery Award&quot;);
        }else if(isPrime(pops[0][k])){//如果排名是素数
            printf(&quot;Minion&quot;);
        }else{
            printf(&quot;Chocolate&quot;);//其他
        }
        pops[1][k]++;//将此人的查询次数加1
        }else{//下列就是查询次数超过1的输出
            printf(&quot;Checked&quot;);
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1062</title>
    <url>/2019/10/07/PTA-Basic-1062/</url>
    <content><![CDATA[<p>题目：<br>一个分数一般写成两个整数相除的形式：N/M，其中 M 不为0。最简分数是指分子和分母没有公约数的分数表示形式。</p>
<p>现给定两个不相等的正分数 N<br>​1<br>​​ /M<br>​1<br>​​  和 N<br>​2<br>​​ /M<br>​2<br>​​ ，要求你按从小到大的顺序列出它们之间分母为 K 的最简分数。</p>
<p>输入格式：</p>
<p>输入在一行中按 N/M 的格式给出两个正分数，随后是一个正整数分母 K，其间以空格分隔。题目保证给出的所有整数都不超过 1000。</p>
<p>输出格式：<br>在一行中按 N/M 的格式列出两个给定分数之间分母为 K 的所有最简分数，按从小到大的顺序，其间以 1 个空格分隔。行首尾不得有多余空格。题目保证至少有 1 个输出。</p>
<p>输入样例：</p>
<pre><code>7/18 13/20 12</code></pre><p>输出样例：</p>
<pre><code>5/12 7/12</code></pre><p>分析:</p>
<pre><code>此题不能使用浮点数的比较，而是使用分数的比较性质。
求两个数字的最大公约数，如果存在就跳此数。</code></pre><p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
int check(int n,int m){//求最大公约数的最简单方法
    if (m)//分母不为0
                while ((n %= m) &amp;&amp; (m %= n)) ;
        return n + m;
}
int main()
{
    int n1,m1,n2,m2,k,tmp;
    scanf(&quot;%d/%d %d/%d %d&quot;,&amp;n1,&amp;m1,&amp;n2,&amp;m2,&amp;k);
    if(n1*m2&gt;n2*m1){//如果输入的两个分数大小不为先大后小
         tmp=n1;
         n1=n2;
         n2=tmp;
         tmp=m1;
         m1=m2;
         m2=tmp;
    }
    int time=0;
    tmp=0;
    for(int i=n1*k/m1+1;i*m2&lt;n2*k;i++){//此处不加1可能会导致多输出一个不合适的结果。
        if(check(i,k)==1){//之间没有公约数（除了一以外）
            printf(&quot;%s%d/%d&quot;,time++?&quot; &quot;:&quot;&quot;,i,k);//从0开始计数为0不输出空格，其他输出。
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1056</title>
    <url>/2019/09/29/PTA-Basic-1056/</url>
    <content><![CDATA[<p>题目：</p>
<p>给定 N 个非 0 的个位数字，用其中任意 2 个数字都可以组合成 1 个 2 位的数字。要求所有可能组合出来的 2 位数字的和。例如给定 2、5、8，则可以组合出：25、28、52、58、82、85，它们的和为330。</p>
<p>输入格式：<br>输入在一行中先给出 N（1 &lt; N &lt; 10），随后给出 N 个不同的非 0 个位数字。数字间以空格分隔。</p>
<p>输出格式：<br>输出所有可能组合出来的2位数字的和。</p>
<p>输入样例：</p>
<pre><code>3 2 8 5</code></pre><p>输出样例：</p>
<pre><code>330</code></pre><p>分析：<br>用数组存储输入的数字，然后遍历数组，将情况分为为0不为0两种情况，<br>为0只要找十位的数字即可，不为0，找完十位和还要找个位。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int add(int a[],int n);
int main()
{
    int n;
    int *a=NULL;
    scanf(&quot;%d&quot;,&amp;n);
    a=malloc(sizeof(int)*n);
    int i=0;
    while(i&lt;n){
        scanf(&quot;%d&quot;,&amp;a[i++]);
    }
    int sum=0;
    sum=add(a,n);
    printf(&quot;%d&quot;,sum);
    return 0;
}
int add(int a[],int n){
    int sum=0;
    for(int i=0;i&lt;n;i++){
        if(a[i]!=0){
                for(int j=i+1;j&lt;n;j++){
                    sum=sum+a[i]*10+a[j];
                    sum=sum+a[i]+a[j]*10;
                }
        }else{
            for(int j=i+1;j&lt;n;j++){
                    sum=sum+a[i]+a[j]*10;
                }
        }
    }
    return sum;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1060</title>
    <url>/2019/10/07/PTA-Basic-1060/</url>
    <content><![CDATA[<p>题目：</p>
<p>英国天文学家爱丁顿很喜欢骑车。据说他为了炫耀自己的骑车功力，还定义了一个“爱丁顿数” E ，即满足有 E 天骑车超过 E 英里的最大整数 E。据说爱丁顿自己的 E 等于87。</p>
<p>现给定某人 N 天的骑车距离，请你算出对应的爱丁顿数 E（≤N）。</p>
<p>输入格式：</p>
<p>输入第一行给出一个正整数 N (≤10<br>​5<br>​​ )，即连续骑车的天数；第二行给出 N 个非负整数，代表每天的骑车距离。</p>
<p>输出格式：<br>在一行中给出 N 天的爱丁顿数。</p>
<p>输入样例：</p>
<pre><code>10
6 7 6 9 3 10 8 2 7 8</code></pre><p>输出样例：</p>
<pre><code>6</code></pre><p>分析：首先什么是爱丁顿数？<br>        对输入的一个数组满足有e个数子大于e的最大整数，正如样例：此数组中数字大于六的个数是六，六又是最大的，所以它是爱丁顿数。</p>
<pre><code>处理：对输入的数组进行由大到小倒序排序，然后遍历直到找到大于下标的位置处。（对于某一个数字如果它比对应的下标大，那么前面比它大的也比它的下标大，，就这么找下去直到找到不合适的下标）</code></pre><p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int cmp(const void *a,const void *b){
    return *(int *)b-*(int *)a;
}
int main(void){
    int n=0;
    scanf(&quot;%d&quot;,&amp;n);
    int nums[n];
    int i=0;
    for(i=0;i&lt;n;i++){
        scanf(&quot;%d&quot;,&amp;nums[i]);
    }
    qsort(nums,n,sizeof(int),cmp);//倒序排列
    for(i=0;i&lt;n&amp;&amp;nums[i]&gt;(i+1);i++);//空语句
    printf(&quot;%d&quot;,i);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1065</title>
    <url>/2019/10/07/PTA-Basic-1065/</url>
    <content><![CDATA[<p>“单身狗”是中文对于单身人士的一种爱称。本题请你从上万人的大型派对中找出落单的客人，以便给予特殊关爱。</p>
<p>输入格式：<br>输入第一行给出一个正整数 N（≤ 50 000），是已知夫妻/伴侣的对数；随后 N 行，每行给出一对夫妻/伴侣——为方便起见，每人对应一个 ID 号，为 5 位数字（从 00000 到 99999），ID 间以空格分隔；之后给出一个正整数 M（≤ 10 000），为参加派对的总人数；随后一行给出这 M 位客人的 ID，以空格分隔。题目保证无人重婚或脚踩两条船。</p>
<p>输出格式：<br>首先第一行输出落单客人的总人数；随后第二行按 ID 递增顺序列出落单的客人。ID 间用 1 个空格分隔，行的首尾不得有多余空格。</p>
<p>输入样例：</p>
<pre><code>3
11111 22222
33333 44444
55555 66666
7
55555 44444 10000 88888 22222 11111 23333</code></pre><p>输出样例：</p>
<pre><code>5
10000 23333 44444 55555 88888</code></pre><p>分析：<br>定义一个情侣数组，男方存储女方的编号，女方存放男方的编号，这样就可以通过一个人找到另一个人，并判断另一个人是否到场。定义一个flag数组用于标记某个人是否到场，定义一个数组用于存放单生狗。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int cmp(const void *a,const void *b){
return *(int *)a-*(int *)b;
}
int main()
{//测试点一是关于对象为0的情况
    int n=0,m=0,x=0,time=0;
    int pops[100000]={-1};/初始化数组，-1表示没有情侣，不能为0，如果为0，那么所有单身狗的情侣都是0.
    int flag[100000]={0};
    scanf(&quot;%d&quot;,&amp;n);
    int n1,n2;
    for(int i=0;i&lt;n;i++){
        scanf(&quot;%d %d&quot;,&amp;n1,&amp;n2);
        pops[n1]=n2;
        pops[n2]=n1;
    }
    scanf(&quot;%d&quot;,&amp;m);
    int result[m];
    int res[m];
    for(int i=0;i&lt;m;i++){
        scanf(&quot;%d&quot;,&amp;x);
        if(pops[x]!=-1){//此处如果将输入的每一个元对应的人都标记的话可能会导致下面去对应值时取到0的人头下标不为0可能会导致数据缺失。
            flag[x]=1;//如果有情侣，才有必要标记到场。
        }
        res[i]=x;
    }
    for(int i=0;i&lt;m;i++){
            x=res[i];
        if(pops[x]==-1){//如果对应的人没有情侣
                result[time]=x;
                time++;
        }else if(flag[x]+flag[pops[x]]!=2){//如果情侣的某一方到场二另一方没有到场，也为单身狗。
                result[time]=x;
                time++;
        }else{

        }
    }
    qsort(result,time,sizeof(int),cmp);//对单身狗进行排序
    printf(&quot;%d\n&quot;,time);
    for(int i=0;i&lt;time;i++){
        printf(&quot;%05d&quot;,result[i]);
        if(i!=time-1){
            printf(&quot; &quot;);
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1063</title>
    <url>/2019/10/07/PTA-Basic-1063/</url>
    <content><![CDATA[<p>在数学中，矩阵的“谱半径”是指其特征值的模集合的上确界。换言之，对于给定的 n 个复数空间的特征值 { a<br>​1<br>​​ +b<br>​1<br>​​ i,⋯,a<br>​n<br>​​ +b<br>​n<br>​​ i }，它们的模为实部与虚部的平方和的开方，而“谱半径”就是最大模。</p>
<p>现在给定一些复数空间的特征值，请你计算并输出这些特征值的谱半径。</p>
<p>输入格式：<br>输入第一行给出正整数 N（≤ 10 000）是输入的特征值的个数。随后 N 行，每行给出 1 个特征值的实部和虚部，其间以空格分隔。注意：题目保证实部和虚部均为绝对值不超过 1000 的整数。</p>
<p>输出格式：<br>在一行中输出谱半径，四舍五入保留小数点后 2 位。</p>
<p>输入样例：</p>
<pre><code>5
0 1
2 0
-1 0
3 3
0 -3</code></pre><p>输出样例：</p>
<pre><code>4.24</code></pre><p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include&lt;math.h&gt;
int main()
{
    int n=0;
    double real=0,imag=0;
    double max=0;
    double sub=0;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++){
        scanf(&quot;%lf %lf&quot;,&amp;real,&amp;imag);
        sub=sqrt(real*real+imag*imag);
        if(sub&gt;max){
            max=sub;
        }
    }
    printf(&quot;%.2f&quot;,max);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1066</title>
    <url>/2019/10/07/PTA-Basic-1066/</url>
    <content><![CDATA[<p>题目：<br>图像过滤是把图像中不重要的像素都染成背景色，使得重要部分被凸显出来。现给定一幅黑白图像，要求你将灰度值位于某指定区间内的所有像素颜色都用一种指定的颜色替换。</p>
<p>输入格式：<br>输入在第一行给出一幅图像的分辨率，即两个正整数 M 和 N（0&lt;M,N≤500），另外是待过滤的灰度值区间端点 A 和 B（0≤A&lt;B≤255）、以及指定的替换灰度值。随后 M 行，每行给出 N 个像素点的灰度值，其间以空格分隔。所有灰度值都在 [0, 255] 区间内。</p>
<p>输出格式：<br>输出按要求过滤后的图像。即输出 M 行，每行 N 个像素灰度值，每个灰度值占 3 位（例如黑色要显示为 000），其间以一个空格分隔。行首尾不得有多余空格。</p>
<p>输入样例：</p>
<pre><code>3 5 100 150 0
3 189 254 101 119
150 233 151 99 100
88 123 149 0 255</code></pre><p>输出样例：</p>
<pre><code>003 189 254 000 000
000 233 151 099 000
088 000 000 000 255</code></pre><p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    int n=0,m=0,a=0,b=0,replace=0,h=0;
    scanf(&quot;%d %d %d %d %d&quot;,&amp;m,&amp;n,&amp;a,&amp;b,&amp;replace);
    int dlex[m][n];
    for(int i=0;i&lt;m;i++){
        for(int j=0;j&lt;n;j++){
            scanf(&quot;%d&quot;,&amp;h);
            if(h&lt;=b&amp;&amp;h&gt;=a){
                h=replace;
            }
            dlex[i][j]=h;
        }
    }
    for(int i=0;i&lt;m;i++){
        for(int j=0;j&lt;n;j++){
            printf(&quot;%03d&quot;,dlex[i][j]);
            if(j!=n-1){
                printf(&quot; &quot;);
            }
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1064</title>
    <url>/2019/10/07/PTA-Basic-1064/</url>
    <content><![CDATA[<p>题目：<br>如果两个整数各位数字的和是一样的，则被称为是“朋友数”，而那个公共的和就是它们的“朋友证号”。例如 123 和 51 就是朋友数，因为 1+2+3 = 5+1 = 6，而 6 就是它们的朋友证号。给定一些整数，要求你统计一下它们中有多少个不同的朋友证号。</p>
<p>输入格式：<br>输入第一行给出正整数 N。随后一行给出 N 个正整数，数字间以空格分隔。题目保证所有数字小于 10<br>​4<br>​​ 。</p>
<p>输出格式：<br>首先第一行输出给定数字中不同的朋友证号的个数；随后一行按递增顺序输出这些朋友证号，数字间隔一个空格，且行末不得有多余空格。</p>
<p>输入样例：</p>
<pre><code>8
123 899 51 998 27 33 36 12</code></pre><p>输出样例：</p>
<pre><code>4
3 6 9 26</code></pre><p>分析：<br>因为题目说小于10^4所以所有朋友数最大为36，定义一个数组用下标表示朋友数，存储的数字代表是否出现此朋友数（0为没有出现其他为出现），遍历数组存储的数字依次输出下标。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main()
{
    int n=0;
    scanf(&quot;%d&quot;,&amp;n);
    int m=0;
    int friends[37]={0};
    int time=0;
    for(int i=0;i&lt;n;i++){
        int total=0;
        scanf(&quot;%d&quot;,&amp;m);
        while(m!=0){
            total+=m%10;
            m=m/10;
        }
        if(friends[total]==0){
            time++;
        }
        friends[total]++;
    }
    printf(&quot;%d\n&quot;,time);
    int i=0;
    for(i=0;i&lt;37;i++){
        if(friends[i]&gt;=1){
            printf(&quot;%d&quot;,i);
                if(time&gt;1){
                printf(&quot;%c&quot;,&apos; &apos;);
            }
        time--;
        }

    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1067</title>
    <url>/2019/10/07/PTA-Basic-1067/</url>
    <content><![CDATA[<p>题目：</p>
<p>当你试图登录某个系统却忘了密码时，系统一般只会允许你尝试有限多次，当超出允许次数时，账号就会被锁死。本题就请你实现这个小功能。</p>
<p>输入格式：<br>输入在第一行给出一个密码（长度不超过 20 的、不包含空格、Tab、回车的非空字符串）和一个正整数 N（≤ 10），分别是正确的密码和系统允许尝试的次数。随后每行给出一个以回车结束的非空字符串，是用户尝试输入的密码。输入保证至少有一次尝试。当读到一行只有单个 # 字符时，输入结束，并且这一行不是用户的输入。</p>
<p>输出格式：<br>对用户的每个输入，如果是正确的密码且尝试次数不超过 N，则在一行中输出 Welcome in，并结束程序；如果是错误的，则在一行中按格式输出 Wrong password: 用户输入的错误密码；当错误尝试达到 N 次时，再输出一行 Account locked，并结束程序。</p>
<p>输入样例 1：</p>
<pre><code>Correct%pw 3
correct%pw
Correct@PW
whatisthepassword!
Correct%pw
#</code></pre><p>输出样例 1：</p>
<pre><code>Wrong password: correct%pw
Wrong password: Correct@PW
Wrong password: whatisthepassword!
Account locked</code></pre><p>输入样例 2：</p>
<pre><code>cool@gplt 3
coolman@gplt
coollady@gplt
cool@gplt
try again
#</code></pre><p>输出样例 2：</p>
<pre><code>Wrong password: coolman@gplt
Wrong password: coollady@gplt
Welcome in</code></pre><p>分析：</p>
<pre><code>定义一个字符数组存储正确的密码，定义一个数字存储输入次数。
用C语言自带的字符串比较函数，如果结果为0，证明两个字符串相同，即密码正确。
此题目的坑比较多（用户输入密码长度不一定为21以内，且不一定不含空格，如果输入正确或次数已到则禁止输入。）</code></pre><p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char cpw[22]={&apos;\0&apos;};
    int time=0;
    scanf(&quot;%s %d&quot;,cpw,&amp;time);//密码中没有空格
    getchar();//吸取第一行的末尾的回车
    while(1){
        char pw[500]={&apos;\0&apos;};//输入密码的长度不一定为20
        gets(pw);//输入的字符串中可能有空格
        if(strlen(pw)==1&amp;&amp;pw[0]==&apos;#&apos;){
            break;
        }
        if(time&gt;0){
            if(!strcmp(cpw,pw)){
                printf(&quot;Welcome in\n&quot;);
                break;
            }else{
                printf(&quot;Wrong password: %s\n&quot;,pw);
                time--;
            }
        }
        if(time==0){
                printf(&quot;Account locked\n&quot;);
                break;
            }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1068</title>
    <url>/2019/10/07/PTA-Basic-1068/</url>
    <content><![CDATA[<p>题目:<br>对于计算机而言，颜色不过是像素点对应的一个 24 位的数值。现给定一幅分辨率为 M×N 的画，要求你找出万绿丛中的一点红，即有独一无二颜色的那个像素点，并且该点的颜色与其周围 8 个相邻像素的颜色差充分大。</p>
<p>输入格式：<br>输入第一行给出三个正整数，分别是 M 和 N（≤ 1000），即图像的分辨率；以及 TOL，是所求像素点与相邻点的颜色差阈值，色差超过 TOL 的点才被考虑。随后 N 行，每行给出 M 个像素的颜色值，范围在 [0,2<br>​24<br>​​ ) 内。所有同行数字间用空格或 TAB 分开。</p>
<p>输出格式：<br>在一行中按照 (x, y): color 的格式输出所求像素点的位置以及颜色值，其中位置 x 和 y 分别是该像素在图像矩阵中的列、行编号（从 1 开始编号）。如果这样的点不唯一，则输出 Not Unique；如果这样的点不存在，则输出 Not Exist。</p>
<p>输入样例 1：</p>
<pre><code>8 6 200
0      0       0        0        0          0           0        0
65280      65280    65280    16711479 65280    65280    65280    65280
16711479 65280    65280    65280    16711680 65280    65280    65280
65280      65280    65280    65280    65280    65280    165280   165280
65280      65280       16777015 65280    65280    165280   65480    165280
16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215</code></pre><p>输出样例 1：</p>
<pre><code>(5, 3): 16711680</code></pre><p>输入样例 2：</p>
<pre><code>4 5 2
0 0 0 0
0 0 3 0
0 0 0 0
0 5 0 0
0 0 0 0</code></pre><p>输出样例 2：</p>
<pre><code>Not Unique</code></pre><p>输入样例 3：</p>
<pre><code>3 3 5
1 2 3
3 4 5
5 6 7</code></pre><p>输出样例 3：</p>
<pre><code>Not Exist</code></pre><p>分析：定义一个足够大的数组用来存储像素点的次数，定义一个结构体用来表示像素点（有坐标，数值），每输入一个像素数值，就存入对应的像素点二维数组中，并在记录次数的数组中加1，然后定义一个判断像素点是否合格的函数，对每个像素点判断是否合格，并且是否只有一个。当这样的点超过1个是就可以不用继续找了。<br>此题目的一个坑就是在所有的点中查找独特的点不管它是否合格，再再独特的点中找合格的个数。而我陷入了这个坑认为不合格的像素点不用加到次数数组中。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include&lt;math.h&gt;
//定义一个二维数组存储像素点
//定义结构体存储合格的像素点，与坐标，次数，一共有多少个像素点
int map[2&lt;&lt;24]={0};
int pixels[1000][1000]={0};
typedef struct pixel{
    int x;
    int y;
    int id;
}pixel;
int check(int i,int j,int n,int m,int tol);
int main()
{
    int m,n,tol;//仿佛数组数目太大的变量只能声明为 全局变量，否则程序不会执行 
    scanf(&quot;%d %d %d&quot;,&amp;m,&amp;n,&amp;tol);
    for(int i=0;i&lt;n;i++){
        for(int j=0;j&lt;m;j++){
            scanf(&quot;%d&quot;,&amp;pixels[i][j]);
            map[pixels[i][j]]++;//将对应的像素点的个数加1.
        }
    }
    int time=0,x=0,y=0,id=0;//time用来记录独特点的个数
    for(int i=0;i&lt;n;i++){
        for(int j=0;j&lt;m;j++){
            if(map[pixels[i][j]]==1&amp;&amp;check(i,j,n,m,tol)){
                y=j+1;
                x=i+1;
                id=pixels[i][j];
                time++;
            }
            if(time==2){//优化当数目超过二是直接跳出循环
                break;
            }
        }
    }
        if(time==0){
            printf(&quot;Not Exist&quot;);
        }else if(time==1){
            printf(&quot;(%d, %d): %d&quot;,y,x,id);
        }else{
            printf(&quot;Not Unique&quot;);
        }
    return 0;
}
int check(int i,int j,int n,int m,int tol){//判断是否合格函数，有左上就看左上，没有就不看，其他一样。
            if(i-1&gt;=0&amp;&amp;j-1&gt;=0&amp;&amp;abs(pixels[i][j]-pixels[i-1][j-1])&lt;=tol){return 0;}//左上
            if(j-1&gt;=0&amp;&amp;abs(pixels[i][j]-pixels[i][j-1])&lt;=tol){return 0;}//左
            if(i+1&lt;n&amp;&amp;j-1&gt;=0&amp;&amp;abs(pixels[i][j]-pixels[i+1][j-1])&lt;=tol){return 0;}//左下
            if(i-1&gt;=0&amp;&amp;abs(pixels[i][j]-pixels[i-1][j])&lt;=tol){return 0;}//上
            if(i+1&lt;n&amp;&amp;abs(pixels[i][j]-pixels[i+1][j])&lt;=tol){return 0;}//下
            if(i-1&gt;=0&amp;&amp;j+1&lt;m&amp;&amp;abs(pixels[i][j]-pixels[i-1][j+1])&lt;=tol){return 0;}//右上
            if(j+1&lt;m&amp;&amp;abs(pixels[i][j]-pixels[i][j+1])&lt;=tol){return 0;}//右
            if(i+1&lt;n&amp;&amp;j+1&lt;m&amp;&amp;abs(pixels[i][j]-pixels[i+1][j+1])&lt;=tol){return 0;}
            return 1;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1069</title>
    <url>/2019/10/07/PTA-Basic-1069/</url>
    <content><![CDATA[<p>题目：</p>
<p>小明 PAT 考了满分，高兴之余决定发起微博转发抽奖活动，从转发的网友中按顺序每隔 N 个人就发出一个红包。请你编写程序帮助他确定中奖名单。</p>
<p>输入格式：<br>输入第一行给出三个正整数 M（≤ 1000）、N 和 S，分别是转发的总量、小明决定的中奖间隔、以及第一位中奖者的序号（编号从 1 开始）。随后 M 行，顺序给出转发微博的网友的昵称（不超过 20 个字符、不包含空格回车的非空字符串）。</p>
<p>注意：可能有人转发多次，但不能中奖多次。所以如果处于当前中奖位置的网友已经中过奖，则跳过他顺次取</p>
<p>下一位。</p>
<p>输出格式：</p>
<p>按照输入的顺序输出中奖名单，每个昵称占一行。如果没有人中奖，则输出 Keep going…。</p>
<p>输入样例 1：</p>
<pre><code>9 3 2
Imgonnawin!
PickMe
PickMeMeMeee
LookHere
Imgonnawin!
TryAgainAgain
TryAgainAgain
Imgonnawin!
TryAgainAgain</code></pre><p>输出样例 1：</p>
<pre><code>PickMe
Imgonnawin!
TryAgainAgain</code></pre><p>输入样例 2：</p>
<pre><code>2 3 5
Imgonnawin!
PickMe</code></pre><p>输出样例 2：</p>
<pre><code>Keep going...</code></pre><p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
char result[1000][21];
int check(char *str,int t){
    for(int j=0;j&lt;t;j++){
        if(strcmp(str,result[j])==0){//比较人数数组中是否已经有这个人了
            return 1;
        }
    }
    return 0;
}
int main()
{
    int m,n,s;
    scanf(&quot;%d%d%d&quot;,&amp;m,&amp;n,&amp;s);
    char str[21];
    int t=0;//用来存储有多少人得奖。
    for(int i=1;i&lt;=m;i++){
            scanf(&quot;%s&quot;,str);
            getchar();
        if(i==s){
                if(check(str,t)){//此人已经转发过了
                    s=s+1;//看看它的下一个人是否合适
                    continue;
                }else{
                    strcpy(result[t++],str);//此人没有转发过，就存入数组。
                    s=s+n;//并且到下一个相隔n的人。
                }
        }
    }
    if(t==0){
        printf(&quot;Keep going...&quot;);
    }else{
        for(int i=0;i&lt;t;i++){
            puts(result[i]);
        }
        }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1070</title>
    <url>/2019/10/07/PTA-Basic-1070/</url>
    <content><![CDATA[<p>题目：</p>
<p>给定一段一段的绳子，你需要把它们串成一条绳。每次串连的时候，是把两段绳子对折，再如下图所示套接在一起。这样得到的绳子又被当成是另一段绳子，可以再次对折去跟另一段绳子串连。每次串连后，原来两段绳子的长度就会减半。</p>
<p><img src="https://images.ptausercontent.com/46293e57-aa0e-414b-b5c3-7c4b2d5201e2.jpg" alt></p>
<p>给定 N 段绳子的长度，你需要找出它们能串成的绳子的最大长度。</p>
<p>输入格式：<br>每个输入包含 1 个测试用例。每个测试用例第 1 行给出正整数 N (2≤N≤10<br>​4<br>​​ )；第 2 行给出 N 个正整数，即原始绳段的长度，数字间以空格分隔。所有整数都不超过10<br>​4<br>​​ 。</p>
<p>输出格式：<br>在一行中输出能够串成的绳子的最大长度。结果向下取整，即取为不超过最大长度的最近整数。</p>
<p>输入样例：</p>
<pre><code>8
10 15 12 3 4 13 1 15</code></pre><p>输出样例：</p>
<pre><code>14</code></pre><p>思路：排序从小到大，不断折半。<br>代码:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int cmp(const void *a,const void *b){
return *(int *)a-*(int *)b;
}
int main()
{

    int n=0;

    scanf(&quot;%d&quot;,&amp;n);

    int nums[n];

    for(int i=0;i&lt;n;i++){
        scanf(&quot;%d&quot;,&amp;nums[i]);
    }

    qsort(nums,n,sizeof(int),cmp);

    int max=nums[0];

    for(int i=1;i&lt;n;i++){

        max=(max+nums[i])/2;

    }

    printf(&quot;%d&quot;,max);

    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1072</title>
    <url>/2019/10/08/PTA-Basic-1072/</url>
    <content><![CDATA[<p>题目：<br>下图是上海某校的新学期开学寄语：天将降大任于斯人也，必先删其微博，卸其 QQ，封其电脑，夺其手机，收其 ipad，断其 wifi，使其百无聊赖，然后，净面、理发、整衣，然后思过、读书、锻炼、明智、开悟、精进。而后必成大器也！</p>
<p><img src="https://images.ptausercontent.com/3b1d9f4a-778b-4942-a9e2-836262f363aa.JPG" alt="嘿嘿嘿"></p>
<p>本题要求你写个程序帮助这所学校的老师检查所有学生的物品，以助其成大器。</p>
<p>输入格式：</p>
<p>输入第一行给出两个正整数 N（≤ 1000）和 M（≤ 6），分别是学生人数和需要被查缴的物品种类数。第二行<br>给出 M 个需要被查缴的物品编号，其中编号为 4 位数字。随后 N 行，每行给出一位学生的姓名缩写（由 1-4 个大写英文字母组成）、个人物品数量 K（0 ≤ K ≤ 10）、以及 K 个物品的编号。</p>
<p>输出格式：<br>顺次检查每个学生携带的物品，如果有需要被查缴的物品存在，则按以下格式输出该生的信息和其需要被查缴的物品的信息（注意行末不得有多余空格）：</p>
<p>姓名缩写: 物品编号1 物品编号2 ……<br>最后一行输出存在问题的学生的总人数和被查缴物品的总数。</p>
<p>输入样例：</p>
<pre><code>4 2
2333 6666
CYLL 3 1234 2345 3456
U 4 9966 6666 8888 6666
GG 2 2333 7777
JJ 3 0012 6666 2333</code></pre><p>输出样例：</p>
<pre><code>U: 6666 6666
GG: 2333
JJ: 6666 2333
3 5</code></pre><p>分析：<br>定义一个图，存储被禁止的编号，然后对每一个输入判断，如果有不允许的，就标记一下此人，输入此人的姓名，与违禁品。注意输出格式为4位</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int forbid[10000]={0};
    int n,m,temp,k;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    for(int i=0;i&lt;m;i++){
        scanf(&quot;%d&quot;,&amp;temp);
        forbid[temp]=1;
    }
    int sum=0,fsum=0;
    for(int i=0;i&lt;n;i++){
        char name[5]={&apos;\0&apos;};
        scanf(&quot;%s %d&quot;,name,&amp;k);
        int flag=0;
        for(int j=0;j&lt;k;j++){
            scanf(&quot;%d&quot;,&amp;temp);
            if(forbid[temp]){
                if(!flag){
                    flag=1;
                    printf(&quot;%s:&quot;,name);
                    sum++;
                }
                printf(&quot; %04d&quot;,temp);
                fsum++;
            }
        }
        if(flag){
            printf(&quot;\n&quot;);
        }
    }
    printf(&quot;%d %d&quot;,sum,fsum);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1071</title>
    <url>/2019/10/08/PTA-Basic-1071/</url>
    <content><![CDATA[<p>题目：</p>
<p>常言道“小赌怡情”。这是一个很简单的小游戏：首先由计算机给出第一个整数；然后玩家下注赌第二个整数将会比第一个数大还是小；玩家下注 t 个筹码后，计算机给出第二个数。若玩家猜对了，则系统奖励玩家 t 个筹码；否则扣除玩家 t 个筹码。</p>
<p>注意：玩家下注的筹码数不能超过自己帐户上拥有的筹码数。当玩家输光了全部筹码后，游戏就结束。</p>
<p>输入格式：<br>输入在第一行给出 2 个正整数 T 和 K（≤ 100），分别是系统在初始状态下赠送给玩家的筹码数、以及需要处理的游戏次数。随后 K 行，每行对应一次游戏，顺序给出 4 个数字：</p>
<p>n1 b t n2<br>其中 n1 和 n2 是计算机先后给出的两个[0, 9]内的整数，保证两个数字不相等。b 为 0 表示玩家赌小，为 1 表示玩家赌大。t 表示玩家下注的筹码数，保证在整型范围内。</p>
<p>输出格式：<br>对每一次游戏，根据下列情况对应输出（其中 t 是玩家下注量，x 是玩家当前持有的筹码量）：</p>
<p>玩家赢，输出 Win t!  Total = x.；<br>玩家输，输出 Lose t.  Total = x.；<br>玩家下注超过持有的筹码量，输出 Not enough tokens.  Total = x.；<br>玩家输光后，输出 Game Over. 并结束程序。<br>输入样例 1：</p>
<pre><code>100 4
8 0 100 2
3 1 50 1
5 1 200 6
7 0 200 8</code></pre><p>输出样例 1：</p>
<pre><code>Win 100!  Total = 200.
Lose 50.  Total = 150.
Not enough tokens.  Total = 150.
Not enough tokens.  Total = 150.</code></pre><p>输入样例 2：</p>
<pre><code>100 4
8 0 100 2
3 1 200 1
5 1 200 6
7 0 200 8</code></pre><p>输出样例 2：</p>
<pre><code>Win 100!  Total = 200.
Lose 200.  Total = 0.
Game Over.</code></pre><p>分析：依据题目思考即可。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    int total,k;
    int n1,n2,b,t;
    scanf(&quot;%d %d&quot;,&amp;total,&amp;k);//存储总的筹码数，与游戏可能执行的最大次数
    for(int i=0;i&lt;k;i++){
    scanf(&quot;%d %d %d %d&quot;,&amp;n1,&amp;b,&amp;t,&amp;n2);
    if(t&gt;total){//判断如果此次的下注的筹码数大于自己有的，则跳过，继续下一次游戏。
        printf(&quot;Not enough tokens.  Total = %d.\n,total);
        continue;
    }
    int boolean=(n2&gt;n1);//用boolean存储n2是否大于n1
        if(boolean==b){//如果boolean 和猜的一样的则赢了此局
            total+=t;
            printf(&quot;Win %d!  Total = %d.\n&quot;,t,total);
        }else{//输了
            total-=t;//减去筹码，不用担心筹码为负数，因为下注数不可能大于筹码。
            printf(&quot;Lose %d.  Total = %d.\n&quot;,t,total);
            if(total==0){//如果扣去下注后的筹码为0，则结束游戏。
                printf(&quot;Game Over.\n&quot;);
                break;
            }
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1074</title>
    <url>/2019/10/09/PTA-Basic-1074/</url>
    <content><![CDATA[<p>分析：<br>地球人习惯使用十进制数，并且默认一个数字的每一位都是十进制的。而在 PAT 星人开挂的世界里，每个数字的每一位都是不同进制的，这种神奇的数字称为“PAT数”。每个 PAT 星人都必须熟记各位数字的进制表，例如“……0527”就表示最低位是 7 进制数、第 2 位是 2 进制数、第 3 位是 5 进制数、第 4 位是 10 进制数，等等。每一位的进制 d 或者是 0（表示十进制）、或者是 [2，9] 区间内的整数。理论上这个进制表应该包含无穷多位数字，但从实际应用出发，PAT 星人通常只需要记住前 20 位就够用了，以后各位默认为 10 进制。</p>
<p>在这样的数字系统中，即使是简单的加法运算也变得不简单。例如对应进制表“0527”，该如何计算“6203 + 415”呢？我们得首先计算最低位：3 + 5 = 8；因为最低位是 7 进制的，所以我们得到 1 和 1 个进位。第 2 位是：0 + 1 + 1（进位）= 2；因为此位是 2 进制的，所以我们得到 0 和 1 个进位。第 3 位是：2 + 4 + 1（进位）= 7；因为此位是 5 进制的，所以我们得到 2 和 1 个进位。第 4 位是：6 + 1（进位）= 7；因为此位是 10 进制的，所以我们就得到 7。最后我们得到：6203 + 415 = 7201。</p>
<p>输入格式：<br>输入首先在第一行给出一个 N 位的进制表（0 &lt; N ≤ 20），以回车结束。 随后两行，每行给出一个不超过 N 位的非负的 PAT 数。</p>
<p>输出格式：<br>在一行中输出两个 PAT 数之和。</p>
<p>输入样例：</p>
<pre><code>30527
06203
415</code></pre><p>输出样例：</p>
<pre><code>7201</code></pre><p>分析：<br>将输入的字符串存入字符数组，定义一个逆转字符串的函数，将每个字符串逆转，然后从头取对应的数字加起来在加上上一次运算的进数，然后对进制取余存入结果数组，取整作为下一次的进数，注意循环的次数，应该比进制字符串的长度大1，为了防止最高项加后超过进制数而导致进项丢失。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
char decimal[21];
char str1[21];
char str2[21];
char result[22];
char* strrev(char *str){//字符逆置函数。
    char *cs1=str;
    char *cs2=str+(strlen(str)-1);
    while(cs1&lt;cs2){
        char ch=*cs1;
        *cs1=*cs2;
        *cs2=ch;
        cs1++;
        cs2--;
    }
    return str;
}
int main()
{
    gets(decimal);//输入进制
    gets(str1);//输入数字1
    gets(str2);//输入数字2
    char *pdecimal=strrev(decimal);//逆置进制
    char *pstr1=strrev(str1);//逆置数字1
    char *pstr2=strrev(str2);//逆置数字2
    int max=strlen(decimal);//存储最大的字符长度。
    int next=0;
    for(int i=0;i&lt;max+1;i++){
            int n=0,m=0,k=0;
            if(pstr1[i]!=&apos;\0&apos;){//第一个数字的一位
                n=pstr1[i]-&apos;0&apos;;
            }
            if(pstr2[i]!=&apos;\0&apos;){//第二个数字的一位
                m=pstr2[i]-&apos;0&apos;;
            }
            if(pdecimal[i]==&apos;0&apos;){//当i达到max时k变为‘\0’-&apos;0&apos;=-48，而其他数字（不小于-48）对其取还是其他数字任何数字对负数取余的结果是那个数字对对应的整数取余的结果。
                k=10;
            }else{
                k=pdecimal[i]-&apos;0&apos;;
            }
            result[i]=(n+m+next)%k+&apos;0&apos;;
            next=(n+m+next)/k;
    }
    char *presult=strrev(result);
        while(*presult==&apos;0&apos;){//将开头的0都去掉，直到找到不为0的数字
        presult++;
    }
    if(strlen(presult)&gt;0)
     printf(&quot;%s&quot;,presult);
    else//测试点5为所有位数都是0，这是会去掉所有位数上的0，而导致字符串为0.长度为0，此时只需输出一个0即可。
        printf(&quot;0&quot;);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1073</title>
    <url>/2019/10/08/PTA-Basic-1073/</url>
    <content><![CDATA[<p>题目：<br>批改多选题是比较麻烦的事情，有很多不同的计分方法。有一种最常见的计分方法是：如果考生选择了部分正确选项，并且没有选择任何错误选项，则得到 50% 分数；如果考生选择了任何一个错误的选项，则不能得分。本题就请你写个程序帮助老师批改多选题，并且指出哪道题的哪个选项错的人最多。</p>
<p>输入格式：<br>输入在第一行给出两个正整数 N（≤1000）和 M（≤100），分别是学生人数和多选题的个数。随后 M 行，每行顺次给出一道题的满分值（不超过 5 的正整数）、选项个数（不少于 2 且不超过 5 的正整数）、正确选项个数（不超过选项个数的正整数）、所有正确选项。注意每题的选项从小写英文字母 a 开始顺次排列。各项间以 1 个空格分隔。最后 N 行，每行给出一个学生的答题情况，其每题答案格式为 (选中的选项个数 选项1 ……)，按题目顺序给出。注意：题目保证学生的答题情况是合法的，即不存在选中的选项数超过实际选项数的情况。</p>
<p>输出格式：<br>按照输入的顺序给出每个学生的得分，每个分数占一行，输出小数点后 1 位。最后输出错得最多的题目选项的信息，格式为：错误次数 题目编号（题目按照输入的顺序从1开始编号）-选项号。如果有并列，则每行一个选项，按题目编号递增顺序输出；再并列则按选项号递增顺序输出。行首尾不得有多余空格。如果所有题目都没有人错，则在最后一行输出 Too simple。</p>
<p>输入样例 1：</p>
<pre><code>3 4 
3 4 2 a c
2 5 1 b
5 3 2 b c
1 5 4 a b d e
(2 a c) (3 b d e) (2 a c) (3 a b e)
(2 a c) (1 b) (2 a b) (4 a b d e)
(2 b d) (1 e) (1 c) (4 a b c d)</code></pre><p>输出样例 1：</p>
<pre><code>3.5
6.0
2.5
2 2-e
2 3-a
2 3-b</code></pre><p>输入样例 2：</p>
<pre><code>2 2 
3 4 2 a c
2 5 1 b
(2 a c) (1 b)
(2 a c) (1 b)</code></pre><p>输出样例 2：</p>
<pre><code>5.0
5.0
Too simple</code></pre><p>分析：<br>定义一个非常大的二维数组，一维用来表示题目号，二维用来存储答案，用0位表示a，1位表示b,2位表示c,…其存储的数值0-表示正确的选项中没有，1表示正确的选项中有。<br>定义一个非常大的浮点数数组存储每位学生的成绩，再定义一个非常大的二维数组用来存储每个题目每个选项的出错次数，然后找出最大的次数。对于每一个学生的每一题，统计其输入中的对的项数，如果与总的输入次数相同则这题没有错，但是不保证全对，如果此题的step相同则全对。不管某个选项对不对，在flag中记录下此题此人选择的搜友选项，然后与题目一开始输入正确选项对比，找找有没有没选的正确选项，有则在对应的错误次数上加1，题目中不是值统计出错最多的选项还要统计没选的正确选项最多的选项。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
double stu[1000];//存储每个学生的成绩
int score[100];//存储每题目的分数
int step[100];//存储每题目的正确的选项数目。
int map[100][5];//存储每个题目正确的选项
int flag[5];//统计每个人每个题目输入的选项
int time[100][5];//用来计算每道题目，每个选项的出错次数,与总的出错次数
int main()
{   int n,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    for(int i=0;i&lt;m;i++){
        scanf(&quot;%d %*d %d&quot;,&amp;score[i],&amp;step[i]);
        char ch;
        while((ch=getchar())!=&apos;\n&apos;){
            if(ch&lt;=&apos;f&apos;&amp;&amp;ch&gt;=&apos;a&apos;){
            int k=ch-&apos;a&apos;;
            map[i][k]=1;
            }
        }
    }
    int max=0;
    for(int i=0;i&lt;n;i++){
        char ch;
        int step1=0;
        int totalstep=0;
        int t=-1;
        while((ch=getchar())!=&apos;\n&apos;){
            if(ch==&apos; &apos;){
                continue;
            }else if(ch==&apos;(&apos;){
                    t++;
                    step1=0;
                    totalstep=0;
            }else if(ch==&apos;)&apos;){
                    if(totalstep==step1){
                            if(step1==step[t]){
                                stu[i]+=score[t]*1.0;
                            }else{
                                stu[i]+=score[t]*0.5;
                            }
                    }
                    for(int i=0;i&lt;5;i++){
                        if(flag[i]==0&amp;&amp;map[t][i]==1){//选的最多的和没选最多的，此处统计没选的且为正确的最多的选项。
                            time[t][i]++;
                            if(time[t][i]&gt;max){
                                max=time[t][i];
                            }
                        }else{
                            flag[i]=0;
                        }
                    }
            }else if(ch&lt;=&apos;5&apos;&amp;&amp;ch&gt;=&apos;0&apos;){
                totalstep=ch-&apos;0&apos;;
            }else{
                int k=ch-&apos;a&apos;;
               if(map[t][k]==0){
                   time[t][k]++;
                   if(time[t][k]&gt;max){
                        max=time[t][k];
                    }
                }else{//选对的话将对应下标的数值-1
                    step1++;
                }
                flag[k]=1;
            }
        }
    }
    for(int i=0;i&lt;n;i++){
        printf(&quot;%.1f\n&quot;,stu[i]);
    }
    if(max&gt;0){
        for(int i=0;i&lt;m;i++)
                for(int j=0;j&lt;5;j++){
                    if(time[i][j]==max)
                        printf(&quot;%d %d-%c\n&quot;,max,i+1,j+&apos;a&apos;);
                }
    }else{//如果最大值则都是满分
        printf(&quot;Too simple&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1077</title>
    <url>/2019/10/09/PTA-Basic-1077/</url>
    <content><![CDATA[<p>题目：</p>
<p>在浙大的计算机专业课中，经常有互评分组报告这个环节。一个组上台介绍自己的工作，其他组在台下为其表现评分。最后这个组的互评成绩是这样计算的：所有其他组的评分中，去掉一个最高分和一个最低分，剩下的分数取平均分记为 G<br>​1<br>​​ ；老师给这个组的评分记为 G<br>​2<br>​​ 。该组得分为 (G<br>​1<br>​​ +G<br>​2<br>​​ )/2，最后结果四舍五入后保留整数分。本题就要求你写个程序帮助老师计算每个组的互评成绩。</p>
<p>输入格式：<br>输入第一行给出两个正整数 N（&gt; 3）和 M，分别是分组数和满分，均不超过 100。随后 N 行，每行给出该组得到的 N 个分数（均保证为整型范围内的整数），其中第 1 个是老师给出的评分，后面 N−1 个是其他组给的评分。合法的输入应该是 [0,M] 区间内的整数，若不在合法区间内，则该分数须被忽略。题目保证老师的评分都是合法的，并且每个组至少会有 3 个来自同学的合法评分。</p>
<p>输出格式：<br>为每个组输出其最终得分。每个得分占一行。</p>
<p>输入样例：</p>
<pre><code>6 50
42 
36 51 50 28 -1 3049 49 35 38 41
40 36 41 33 47 49
30 250 -25 27 45 31
48 0 0 50 50 1234
43 41 36 29 42 29</code></pre><p>输出样例：</p>
<pre><code>42
33
41
31
37
39</code></pre><p>分析：<br>先存储行数（亦是列数），再存储总分，定义一个判断函数，然后对于每一行每一个数据进行判断，合适的第一个数赋值给老师，剩余存储到数组中去，对数组排序，从第二个元素开始，到倒数第二个元素求平均值，然后再与老师的分数值取平均值，对此品均值进行四舍五入，注意整型与整型除法的结果为整型。继续下一行的数据的输入与处理。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int cmp(const void *a,const void *b){
    return *(int *)a-*(int *)b;
}
int check(int n,int m){
        if(n&lt;=m&amp;&amp;n&gt;=0){
            return 1;
        }
        return 0;
}
int main()
{
    int n,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    for(int i=0;i&lt;n;i++){
            int n0=0;
            int time=-1;
            int a[n-1];
        for(int j=0;j&lt;n;j++){
                int k;
            scanf(&quot;%d&quot;,&amp;k);
            if(check(k,m)){
                if(time==-1){
                    n0=k;
                }else{
                    a[time]=k;
                }
                time++;
            }else{
                continue;
            }
        }
        qsort(a,time,sizeof(int),cmp);
        int sum=0;
        for(int j=1;j&lt;time-1;j++){
            sum=sum+a[j];
        }
        if(sum!=0){
            sum=sum/(time-2);
        }
        printf(&quot;%d\n&quot;,(int)((sum+n0)*1.0/2+0.5));//必须*1.0，防止整形运算的区别
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1075</title>
    <url>/2019/10/16/PTA-Basic-1075/</url>
    <content><![CDATA[<p>题目：</p>
<p>给定一个单链表，请编写程序将链表元素进行分类排列，使得所有负值元素都排在非负值元素的前面，而 [0, K] 区间内的元素都排在大于 K 的元素前面。但每一类内部元素的顺序是不能改变的。例如：给定链表为 18→7→-4→0→5→-6→10→11→-2，K 为 10，则输出应该为 -4→-6→-2→7→0→5→10→18→11。</p>
<p>输入格式：<br>每个输入包含一个测试用例。每个测试用例第 1 行给出：第 1 个结点的地址；结点总个数，即正整数N (≤10^5 )；以及正整数K (≤10^3)。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。</p>
<p>接下来有 N 行，每行格式为：</p>
<p>Address Data Next<br>其中 Address 是结点地址；Data 是该结点保存的数据，为 [−10^5​,10^5] 区间内的整数；Next 是下一结点的地址。题目保证给出的链表不为空。</p>
<p>输出格式：<br>对每个测试用例，按链表从头到尾的顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。</p>
<p>输入样例：</p>
<pre><code>00100 9 10
23333 10 27777
00000 0 99999
00100 18 12309
68237 -6 23333
33218 -4 00000
48652 -2 -1
99999 5 68237
27777 11 48652
12309 7 33218</code></pre><p>输出样例：</p>
<pre><code>33218 -4 68237
68237 -6 48652
48652 -2 12309
12309 7 00000
00000 0 99999
99999 5 23333
23333 10 00100
00100 18 27777
27777 11 -1</code></pre><p>思路：分三次，每次找合适的数据。<br>代码：</p>
<pre><code>#include&lt;stdio.h&gt;

int main()
{
  int iNext=0,iN=0,iK=0;//对应的是首地址，节点的个数，K的值
  int iData[100000][2]={0};//用一个足够大的数组存放数据以及下一个节点的地址，下标就是它的地址
  scanf(&quot;%d%d%d&quot;,&amp;iNext,&amp;iN,&amp;iK);//输入信息
  int iAddr=0,iNum=0,iNAddr=0;
  for(int i=0;i&lt;iN;i++)
  {
    scanf(&quot;%d%d%d&quot;,&amp;iAddr,&amp;iNum,&amp;iNAddr);//存放当前地址，数据，下一个节点的地址
    iData[iAddr][0]=iNum;//存放数据
    iData[iAddr][1]=iNAddr;//存放下一节点地址
  }
  int iOrder[iN];//存放排序好的地址
  int p=0,next=iNext;
  //3次遍历筛选排序
  while(next!=-1)//第一次从首地址出发找出负数的地址。
  {
    if(iData[next][0]&lt;0)//当前节点的数据
    {
      iOrder[p++]=next;
    }
    next=iData[next][1];//将地址存放下一个节点的地址
  }
  next=iNext;//继续从首地址出发
  while(next!=-1)//第二次找&lt;=K的非负数
  {
    if(iData[next][0]&gt;=0&amp;&amp;iData[next][0]&lt;=iK)
    {
      iOrder[p++]=next;
    }
    next=iData[next][1];
  }
  next=iNext;
  while(next!=-1)//第三次找大于等于K的数据
  {
    if(iData[next][0]&gt;iK)
    {
      iOrder[p++]=next;
    }
    next=iData[next][1];
  }
  //循环输出，注意控制范围
  for(int i=0;i&lt;p-1;i++)
  {
    printf(&quot;%05d %d %05d\n&quot;,iOrder[i],iData[iOrder[i]][0],iOrder[i+1]);//输出地址，地址对应的数据以及下一个地址。
  }
  printf(&quot;%05d %d -1&quot;,iOrder[p-1],iData[iOrder[p-1]][0]);//最后一个节点的数据直接输出，并输出-1表示结束。
  return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1076</title>
    <url>/2019/10/09/PTA-Basic-1076/</url>
    <content><![CDATA[<p>题目：</p>
<p>下面是微博上流传的一张照片：“各位亲爱的同学们，鉴于大家有时需要使用 wifi，又怕耽误亲们的学习，现将 wifi 密码设置为下列数学题答案：A-1；B-2；C-3；D-4；请同学们自己作答，每两日一换。谢谢合作！！~”—— 老师们为了促进学生学习也是拼了…… 本题就要求你写程序把一系列题目的答案按照卷子上给出的对应关系翻译成 wifi 的密码。这里简单假设每道选择题都有 4 个选项，有且只有 1 个正确答案。</p>
<p><img src="https://images.ptausercontent.com/7e56be3f-caba-45f1-b9cb-38a96d44de76.jpg" alt></p>
<p>输入格式：<br>输入第一行给出一个正整数 N（≤ 100），随后 N 行，每行按照 编号-答案 的格式给出一道题的 4 个选项，T 表示正确选项，F 表示错误选项。选项间用空格分隔。</p>
<p>输出格式：<br>在一行中输出 wifi 密码。</p>
<p>输入样例：</p>
<pre><code>8
A-T B-F C-F D-F
C-T B-F A-F D-F
A-F D-F C-F B-T
B-T A-F C-F D-F
B-F D-T A-F C-F
A-T C-F B-F D-F
D-T B-F C-F A-F
C-T A-F B-F D-F</code></pre><p>输出样例：</p>
<pre><code>13224143</code></pre><p>直接对每对字符判断因为输入的一个题目的答案只有一个所有直接判断并输出对应的数字。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main()
{
    int n=0;
    scanf(&quot;%d&quot;,&amp;n);
    char ch1,ch2;
    getchar();//吸收换行符
    for(int i=0;i&lt;n;i++){
        for(int j=0;j&lt;4;j++){
            scanf(&quot;%c-%c&quot;,&amp;ch1,&amp;ch2);
            getchar();//吸收空格与换行符
            if(ch2==&apos;T&apos;){
                    int re=0;
                switch(ch1){
                    case &apos;A&apos;:re=1;break;
                    case &apos;B&apos;:re=2;break;
                    case &apos;C&apos;:re=3;break;
                    case &apos;D&apos;:re=4;break;
                }
                printf(&quot;%d&quot;,re);
            }
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1078</title>
    <url>/2019/10/11/PTA-Basic-1078/</url>
    <content><![CDATA[<p>题目：<br>文本压缩有很多种方法，这里我们只考虑最简单的一种：把由相同字符组成的一个连续的片段用这个字符和片段中含有这个字符的个数来表示。例如 ccccc 就用 5c 来表示。如果字符没有重复，就原样输出。例如 aba 压缩后仍然是 aba。</p>
<p>解压方法就是反过来，把形如 5c 这样的表示恢复为 ccccc。</p>
<p>本题需要你根据压缩或解压的要求，对给定字符串进行处理。这里我们简单地假设原始字符串是完全由英文字母和空格组成的非空字符串。</p>
<p>输入格式：<br>输入第一行给出一个字符，如果是 C 就表示下面的字符串需要被压缩；如果是 D 就表示下面的字符串需要被解压。第二行给出需要被压缩或解压的不超过 1000 个字符的字符串，以回车结尾。题目保证字符重复个数在整型范围内，且输出文件不超过 1MB。</p>
<p>输出格式：<br>根据要求压缩或解压字符串，并在一行中输出结果。</p>
<p>输入样例 1：</p>
<pre><code>C

TTTTThhiiiis isssss a   tesssst CAaaa as</code></pre><p>输出样例 1：</p>
<pre><code>5T2h4is i5s a3 te4st CA3a as</code></pre><p>输入样例 2：</p>
<pre><code>D

5T2h4is i5s a3 te4st CA3a as10Z</code></pre><p>输出样例 2：</p>
<pre><code>TTTTThhiiiis isssss a   tesssst CAaaa asZZZZZZZZZZ</code></pre><p>分析：</p>
<p>首先根据题目要求知道要求我们解压与压缩，解压-&gt;将字符串中的数字转换成其后面紧跟的字符的个数，注</p>
<p>意，此处数字可能大于10。然后输出n个字符。</p>
<p>压缩过程：将连续的n个字符（n&gt;1）表达成‘n字符’的形式。</p>
<p>注意：此题的一个坑，输入中可能会有空格。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include&lt;string.h&gt;
#include &lt;stdlib.h&gt;
void c(char *s){//压缩函数
    char *p=s;
    char cur=*p;//保存当前的字符
    p++;
    int time=1;//默认的字符长度为1
    while(cur){
        char ch=*p;//存储下一个字符
        if(cur==ch){//当前字符与下一个字符比较
            time++;
        }else{//不同时，表示连续的已经断开
            if(time&gt;1){
                printf(&quot;%d%c&quot;,time,cur);
            }else{
                printf(&quot;%c&quot;,cur);
            }
            time=1;//重新将字符设置为1
            cur=ch;//将后一个字符给当前字符。
        }
        p++;//指针指向后面一个字符。
    }
}
void d(char *s){//解压
    char *p=s;
    int time=0;
    while(*p){
        if((*p)&lt;=&apos;9&apos;&amp;&amp;(*p)&gt;=&apos;0&apos;){//将字符串中的数字转化为int型。
            time=time*10+(*p)-&apos;0&apos;;//
        }else
        {
            if(time==0){//如果此处不给time赋值为1，且time==0，那么字母前面没有数字的就会被丢掉。
                time=1;
            }
            for(int i=0;i&lt;time;i++){
                printf(&quot;%c&quot;,*p);
            }
            time=0;//防止遇到数字为两位或更高位的。
        }
        p++;
    }
}
int main()
{
    char ch;
    scanf(&quot;%c&quot;,&amp;ch);
    getchar();
    char str[1001];
    gets(str);
    switch(ch){
    case &apos;C&apos;:c(str);break;
    case &apos;D&apos;:d(str);break;
    default:break;
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1079</title>
    <url>/2019/10/11/PTA-Basic-1079/</url>
    <content><![CDATA[<p>给定一个 k+1 位的正整数 N，写成 a<br>​k<br>​​ ⋯a<br>​1<br>​​ a<br>​0<br>​​  的形式，其中对所有 i 有 0≤a<br>​i<br>​​ &lt;10 且 a<br>​k<br>​​ &gt;0。N 被称为一个回文数，当且仅当对所有 i 有 a<br>​i<br>​​ =a<br>​k−i<br>​​ 。零也被定义为一个回文数。</p>
<p>非回文数也可以通过一系列操作变出回文数。首先将该数字逆转，再将逆转数与该数相加，如果和还不是一个回文数，就重复这个逆转再相加的操作，直到一个回文数出现。如果一个非回文数可以变出回文数，就称这个数为延迟的回文数。（定义翻译自 <a href="https://en.wikipedia.org/wiki/Palindromic_number">https://en.wikipedia.org/wiki/Palindromic_number</a> ）</p>
<p>给定任意一个正整数，本题要求你找到其变出的那个回文数。</p>
<p>输入格式：<br>输入在一行中给出一个不超过1000位的正整数。</p>
<p>输出格式：<br>对给定的整数，一行一行输出其变出回文数的过程。每行格式如下</p>
<p>A + B = C<br>其中 A 是原始的数字，B 是 A 的逆转数，C 是它们的和。A 从输入的整数开始。重复操作直到 C 在 10 步以内变成回文数，这时在一行中输出 C is a palindromic number.；或者如果 10 步都没能得到回文数，最后就在一行中输出 Not found in 10 iterations.。</p>
<p>输入样例 1：</p>
<pre><code>97152</code></pre><p>输出样例 1：</p>
<pre><code>97152 + 25179 = 122331
122331 + 133221 = 255552
255552 is a palindromic number.</code></pre><p>输入样例 2：</p>
<pre><code>196</code></pre><p>输出样例 2：</p>
<pre><code>196 + 691 = 887
887 + 788 = 1675
1675 + 5761 = 7436
7436 + 6347 = 13783
13783 + 38731 = 52514
52514 + 41525 = 94039
94039 + 93049 = 187088
187088 + 880781 = 1067869
1067869 + 9687601 = 10755470
10755470 + 07455701 = 18211171
Not found in 10 iterations.</code></pre><p>分析：<br>定一个判断字符串是否回文字符串的函数，定义一个反转字符串的函数。<br>首先对输入的字符串判断是否是回文字符串，然后定义一个比它长1的字符数组，防止最高位进位，将当前字符串复制到另一个，然后用复制后的字符串与反转字符串相加。然后将结果输出，赋值给第一个字符串重复此操作，直到找到或达到10次。<br>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include&lt;string.h&gt;
#include &lt;stdlib.h&gt;//虽然题目说字符串的长度在0-1000之间但是他们相加后的长度就可能大于1000了所以要定义比1001大的
int isReserve(char* s){//判断是否是回文字符串的函数。
    int i=0;
    int j=strlen(s)-1;
    while(i&lt;j){
        if(s[i]!=s[j]){
            return 0;
        }
        i++;
        j--;
    }
    return 1;
}
char * strrev(char *str){
    int i=0,j=strlen(str)-1;//对源字符串直接操作，
    char ch;
    while(i&lt;j){
        ch=str[j];
        str[j]=str[i];
        str[i]=ch;
        i++;
        j--;
    }
    return str;
}
int main()
{
    char str[1050];
    gets(str);
    int i=0;
    for(;i&lt;10;i++){
        if(isReserve(str)){
            printf(&quot;%s is a palindromic number.&quot;,str);
            break;
        }else{
            char strcopy[1050];//保留反转前的字符串
            strcpy(strcopy,str);
            strrev(str);//反转str中的字符串
            printf(&quot;%s + %s = &quot;,strcopy,str);
            char res[1050]={&apos;\0&apos;};//定义结果数组。
            int k=0;
            int max=strlen(str);
            for(int j=0;j&lt;max;j++){//因为字符串是与反转字符串相加，唯一不同的就是如果最高位有进位，进位就存在右边了，此时需要反转一下。
                int sum=0;
                if(strcopy[j]){
                    sum=sum+strcopy[j]-&apos;0&apos;;
                }
                if(str[j]){
                    sum=sum+str[j]-&apos;0&apos;;
                }
                sum=sum+k;
                res[j]=sum%10+&apos;0&apos;;
                k=sum/10;
                if(j==max-1&amp;&amp;k!=0){//如果高位有进位，就要存下他。
                    res[j+1]=k+&apos;0&apos;;//
                }
            }
            strrev(res);//反转结果数组
            puts(res);//输出
            strcpy(str,res);//将结果赋值给str继续操作。
        }
    }
    if(i==10){
        printf(&quot;Not found in 10 iterations.&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1080</title>
    <url>/2019/10/11/PTA-Basic-1080/</url>
    <content><![CDATA[<p>题目：<br>对于在中国大学MOOC（<a href="http://www.icourse163.org/">http://www.icourse163.org/</a> ）学习“数据结构”课程的学生，想要获得一张合格证书，必须首先获得不少于200分的在线编程作业分，然后总评获得不少于60分（满分100）。总评成绩的计算公式为 G=(G<br>​mid−term<br>​​ ×40%+G<br>​final<br>​​ ×60%)，如果 G<br>​mid−term<br>​​ &gt;G<br>​final<br>​​ ；否则总评 G 就是 G<br>​final<br>​​ 。这里 G<br>​mid−term<br>​​  和 G<br>​final<br>​​  分别为学生的期中和期末成绩。</p>
<p>现在的问题是，每次考试都产生一张独立的成绩单。本题就请你编写程序，把不同的成绩单合为一张。</p>
<p>输入格式：<br>输入在第一行给出3个整数，分别是 P（做了在线编程作业的学生数）、M（参加了期中考试的学生数）、N（参加了期末考试的学生数）。每个数都不超过10000。</p>
<p>接下来有三块输入。第一块包含 P 个在线编程成绩 G<br>​p<br>​​ ；第二块包含 M 个期中考试成绩 G<br>​mid−term<br>​​ ；第三块包含 N 个期末考试成绩 G<br>​final<br>​​ 。每个成绩占一行，格式为：学生学号 分数。其中学生学号为不超过20个字符的英文字母和数字；分数是非负整数（编程总分最高为900分，期中和期末的最高分为100分）。</p>
<p>输出格式：<br>打印出获得合格证书的学生名单。每个学生占一行，格式为：</p>
<p>学生学号 G<br>​p<br>​​  G<br>​mid−term<br>​​  G<br>​final<br>​​  G</p>
<p>如果有的成绩不存在（例如某人没参加期中考试），则在相应的位置输出“−1”。输出顺序为按照总评分数（四舍五入精确到整数）递减。若有并列，则按学号递增。题目保证学号没有重复，且至少存在1个合格的学生。</p>
<p>输入样例：</p>
<pre><code>6 6 7
01234 880
a1903 199
ydjh2 200
wehu8 300
dx86w 220
missing 400
ydhfu77 99
wehu8 55
ydjh2 98
dx86w 88
a1903 86
01234 39
ydhfu77 88
a1903 66
01234 58
wehu8 84
ydjh2 82
missing 99
dx86w 81</code></pre><p>输出样例：</p>
<pre><code>missing 400 -1 99 99
ydjh2 200 98 82 88
dx86w 220 88 81 84
wehu8 300 55 84 84</code></pre><p>分析：<br>定义一个学生的结构体。<br>首先输入6+6+7行数据，将此输入分为三块，第一块存储平时分合格（》=200）人的名字，与分数，第二部分存储，根据输入的名字在第一部分的结果数组中找到相应的人的下标，将其中成绩赋值，第三部分同第二但是此外还要加上对总评分数的计算，期中期末未来的人分数为-1，依据题目计算总评分，然后首先根据成绩降序排序，然后根据姓名升序排序。</p>
<p>代码：<br>第一次代码：<br>此处最后一个测试点会运行超时，这是因为在查找时，耗时过多，因此必须采用更好的查找算法（先排序（快排），再二分查找）。</p>
<pre><code>//#include&lt;stdio.h&gt;
//#include&lt;string.h&gt;
//#include&lt;stdlib.h&gt;
//typedef struct Stu{
//    char name[21];
//    int gp;
//    int gm;
//    int gt;
//    int g;
//};
//int search(Stu* stus,int total,char *name){
//    for(int i=0;i&lt;total;i++){
//        if(strcmp(stus[i].name,name)==0){
//            return i;
//        }
//    }
//    return -1;
//}
//int cmp(const void *a,const void *b){
//    struct Stu s1=*(struct Stu *)a;
//    struct Stu s2=*(struct Stu *)b;
//    if(s1.g&lt;s2.g){}
//        return 1;
//    }else if(s1.g&gt;s2.g){
//        return -1;
//    }else{
//        return strcmp(s1.name,s2.name);
//    }
//}
//int main(void){
//    int n,m,p;
//    scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;p);
//    struct Stu stus[n];
//    int time=0;
//    char name[21];
//    int k=0;
//    for(int i=0;i&lt;n;i++){
//        scanf(&quot;%s %d&quot;,name,&amp;k);
//        if(k&gt;=200){
//            strcpy(stus[time].name,name);
//            stus[time].gp=k;
//            stus[time].gm=-1;
//            stus[time].gt=-1;
//            stus[time].g=-1;
//            time++;
//        }
//    }
//    for(int i=0;i&lt;m;i++){
//        scanf(&quot;%s %d&quot;,name,&amp;k);
//        int index=search(stus,time,name);
//        if(index&gt;-1){
//            stus[index].gm=k;
//        }
//    }
//    for(int i=0;i&lt;p;i++){
//        scanf(&quot;%s %d&quot;,name,&amp;k);
//        int index=search(stus,time,name);
//        if(index&gt;-1){
//            stus[index].gt=k;
//            if(stus[index].gm&gt;stus[index].gt){
//                stus[index].g=(int)(0.4*stus[index].gm+0.6*stus[index].gt+0.5);
//            }else{
//                stus[index].g=stus[index].gt;
//            }
//        }
//    }
//    qsort(stus,time,sizeof(struct Stu),cmp);
//    for(int i=0;i&lt;time;i++){
//        if(stus[i].g&gt;=60)
//        printf(&quot;%s %d %d %d %d\n&quot;,stus[i].name,stus[i].gp,stus[i].gm,stus[i].gt,stus[i].g);
//    }
//    return 0;
//}</code></pre><p>第二次代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
typedef struct Stu{
    char name[21];
    int gp;//平时成绩
    int gm;//期中成绩
    int gt;//期末成绩
    int g;//总评成绩
};
int search(struct Stu* stus,int total,char *name){//二分查找返回存在的人的下标，不存在就返回-1
    int start=0,end=total-1;
    while(start&lt;=end){
         int mid=(start+end)/2;
         int res=strcmp(stus[mid].name,name);
        if(res==0){
            return mid;
        }else if(res&gt;0){
            end=mid-1;
        } else{
            start=mid+1;
        }
    }
    return -1;
}
int cmp(const void *a,const void *b){
    struct Stu s1=*(struct Stu *)a;
    struct Stu s2=*(struct Stu *)b;
    if(s1.g&lt;s2.g){
        return 1;
    }else if(s1.g&gt;s2.g){
        return -1;
    }else{
        return strcmp(s1.name,s2.name);
    }
}
int tcmp(const void *a,const void *b){//用于二分查找的排序比较算法
    struct Stu s1=*(struct Stu *)a;
    struct Stu s2=*(struct Stu *)b;
    return strcmp(s1.name,s2.name);
    }
int main(void){
    int n,m,p;
    scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;p);
    struct Stu stus[n];
    int time=0;
    char name[21];
    int k=0;
    for(int i=0;i&lt;n+m+p;i++){
        scanf(&quot;%s %d&quot;,name,&amp;k);
        if(i&lt;n){
            if(k&gt;=200){//平时成绩合格才有资格
                strcpy(stus[time].name,name);//首先初始化时将每个人的每个考试成绩都赋值为-1。
                stus[time].gp=k;
                stus[time].gm=-1;
                stus[time].gt=-1;
                stus[time].g=-1;
                time++;
            }
        }else{
            if(i==n){//第n个输入说明所有有资格的人都已经输入完毕，对其排序，以便于二分查找。
                qsort(stus,time,sizeof(struct Stu),tcmp);
            }
            int index=search(stus,time,name);
            if(index&gt;-1){//如果有这个人
                if(i&lt;m+n){
                    stus[index].gm=k;
                }else{
                    stus[index].gt=k;
                    if(stus[index].gm&gt;stus[index].gt){
                        stus[index].g=(int)(0.4*stus[index].gm+0.6*stus[index].gt+0.5);
                    }else{
                        stus[index].g=stus[index].gt;
                    }
                }
            }
        }
    }
    qsort(stus,time,sizeof(struct Stu),cmp);
    for(int i=0;i&lt;time;i++){
        if(stus[i].g&gt;=60)
        printf(&quot;%s %d %d %d %d\n&quot;,stus[i].name,stus[i].gp,stus[i].gm,stus[i].gt,stus[i].g);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1085</title>
    <url>/2019/10/16/PTA-Basic-1085/</url>
    <content><![CDATA[<p>题目：<br>每次 PAT 考试结束后，考试中心都会发布一个考生单位排行榜。本题就请你实现这个功能。</p>
<p>输入格式：<br>输入第一行给出一个正整数 N（≤10<br>​5<br>​​ ），即考生人数。随后 N 行，每行按下列格式给出一个考生的信息：</p>
<p>准考证号 得分 学校<br>其中准考证号是由 6 个字符组成的字符串，其首字母表示考试的级别：B代表乙级，A代表甲级，T代表顶级；得分是 [0, 100] 区间内的整数；学校是由不超过 6 个英文字母组成的单位码（大小写无关）。注意：题目保证每个考生的准考证号是不同的。</p>
<p>输出格式：<br>首先在一行中输出单位个数。随后按以下格式非降序输出单位的排行榜：</p>
<p>排名 学校 加权总分 考生人数<br>其中排名是该单位的排名（从 1 开始）；学校是全部按小写字母输出的单位码；加权总分定义为乙级总分/1.5 + 甲级总分 + 顶级总分*1.5的整数部分；考生人数是该属于单位的考生的总人数。</p>
<p>学校首先按加权总分排行。如有并列，则应对应相同的排名，并按考生人数升序输出。如果仍然并列，则按单位码的字典序输出。</p>
<p>输入样例：</p>
<pre><code>10
A57908 85 Au
B57908 54 LanX
A37487 60 au
T28374 67 CMU
T32486 24 hypu
A66734 92 cmu
B76378 71 AU
A47780 45 lanx
A72809 100 pku
A03274 45 hypu</code></pre><p>输出样例：</p>
<pre><code>5
1 cmu 192 2
1 au 192 3
3 pku 100 1
4 hypu 81 2
4 lanx 81 2</code></pre><p>分析：<br>定义一个结构体（包含学校名字（不分大小写），学校出席人数，学校总分（浮点数）），定义两个数组一个用来存储所有学校的（包含重复的内容）信息，然后再利用快排对第一个数组进行排序，再定义另一个数组用来合并名字相同的学校信息，然后每行输出一个学校的信息，排名从1开始，如果遇到不同的就+1。实话实说，这个代码是我抄的，我的思路固化了。<br>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
typedef struct{
  char szSchool[7];
  double fScore;
  int iNumofStu;
} SCHOOL;
int cmp_sch(const void *a, const void *b)//利用学校的名字进行的排序
{
  SCHOOL *p=(SCHOOL *)a;//将a转化为结构体的指针，同样对b也是这样做。
  SCHOOL *q=(SCHOOL *)b;
  return strcmp(p-&gt;szSchool,q-&gt;szSchool);//对数组进行名字升序排序
}
int cmp(const void *a, const void *b)//依据题目排序，先对成绩降序，再对人数升序，再对学校名字升序。
{
  SCHOOL *p=(SCHOOL *)a;
  SCHOOL *q=(SCHOOL *)b;
  int flag=0;
  int iscorep=(int)p-&gt;fScore,iscoreq=(int)q-&gt;fScore;
  if(iscorep&lt;iscoreq)
  {
    flag=1;
  }
  else if(iscorep==iscoreq)
  {
    if(p-&gt;iNumofStu&gt;q-&gt;iNumofStu)
    {
      flag=1;
    }
    else if(p-&gt;iNumofStu==q-&gt;iNumofStu)
    {
      if(strcmp(p-&gt;szSchool,q-&gt;szSchool)&gt;0)
      {
        flag=1;
      }
    }
  }
  return flag;
}
int main()
{
  int iN=0,iNumofSchool=0;
  scanf(&quot;%d&quot;,&amp;iN);
  SCHOOL school[iN],result[iN];
  memset(school,0,iN*sizeof(SCHOOL));//初始化含重复数据数组。
  memset(result,0,iN*sizeof(SCHOOL));//初始化存储无重复数据的数组
  int pos=0;
  char szTempID[7]={0},szTempSch[7]={0};
  double fTempScore=0;
  for(int i=0;i&lt;iN;i++)
  {
    getchar();
    scanf(&quot;%s %lf %s&quot;,szTempID,&amp;fTempScore,szTempSch);
    if(szTempID[0]==&apos;B&apos;)//依据考试的等级进行分数统计。
    {
      fTempScore/=1.5;
    }
    else if(szTempID[0]==&apos;T&apos;)
    {
      fTempScore*=1.5;
    }
    for(int j=0;j&lt;strlen(szTempSch);j++)//将名字变为小写
    {
      if(szTempSch[j]&gt;=&apos;A&apos;&amp;&amp;szTempSch[j]&lt;=&apos;Z&apos;)
      {
        szTempSch[j]+=&apos;a&apos;-&apos;A&apos;;
      }
    }
    strcpy(school[i].szSchool,szTempSch);
    school[i].fScore=fTempScore;
    school[i].iNumofStu=1;//存储到数组中去。
  }
  qsort(school,iN,sizeof(SCHOOL),cmp_sch);
  result[0]=school[0];//首先将第一个学校数据给宁外一个数组
  for(int i=1;i&lt;iN;i++)//从第一个开始，第0个已经给了另一个数组了，
  {
    if(strcmp(school[i].szSchool,school[i-1].szSchool)==0)
    {//用后面的跟前面的比较，姓名一样就说明与前一个相同学校。
      result[pos].fScore+=school[i].fScore;
      result[pos].iNumofStu++;
    }
    else//不一样就说明另外一个学校，那么另一个数组的下标就要加1.
    {
      pos++;
      result[pos]=school[i];
    }
  }
  qsort(result,pos+1,sizeof(SCHOOL),cmp);//用题目条件排序。
  int cnt=1;
  printf(&quot;%d\n&quot;,pos+1);
  printf(&quot;%d %s %d %d&quot;,cnt,result[0].szSchool,(int)result[0].fScore,result[0].iNumofStu);
  for(int i=1;i&lt;=pos;i++)
  {
    if((int)result[i].fScore!=(int)result[i-1].fScore)
    {
      cnt=i+1;
    }
    printf(&quot;\n%d %s %d %d&quot;,cnt,result[i].szSchool,(int)result[i].fScore,result[i].iNumofStu);
  }
  return 0;
}</code></pre><p>原来代码的错误分析：首先说一下运行结果，前三个测试点过去了，后两个运行超时，说明思路是对的，就是解决方法补恰当。</p>
<pre><code>#include &lt;stdio.h&gt;
#include&lt;string.h&gt;
#include &lt;stdlib.h&gt;
typedef struct school{//学校结构体
    char name[8];//名字
    double score;//学校分数
    int time;//出席人数
};
struct school schools[100001];
int cmp(const void *a,const void *b);
int cnmp(const void *a,const void *b);
void toLowerCase(char *s);
int search(int nn,char *n);
int main()
{
    char name[8]={&apos;\0&apos;};
    int scor=0;
    char id[8]={&apos;\0&apos;};
    int n;
    int time=0;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++){
        getchar();
        scanf(&quot;%s %d %s&quot;,id,&amp;scor,name);
        toLowerCase(name);//变为小写
        int index=search(time,name);//这里甚至采用了二人分查找依然没有逃过运行超时的命运，遍历已有的数组看看有没有这个名字有就返回下标没有返回-1。
        if(index==-1){//返回-1，表示数组中要加一个新的学校了。
            strcpy(schools[time].name,name);
            index=time;//将已经有几个学校的数目给index，index就是新加进来的学校在数组中的位置
            time++;//time加1，表示有加了一个新的学校
        }
        schools[index].time++;//出席人数加一
        if(id[0]==&apos;A&apos;){//根据等级对分数计算
            schools[index].score=schools[index].score+scor;
        }else if(id[0]==&apos;B&apos;){
            schools[index].score=schools[index].score+scor*1.0*2/3;
        }else{
            schools[index].score=schools[index].score+scor*1.0*3/2;
        }
        qsort(schools,time,sizeof(struct school),cnmp);//快速排序
    }
    qsort(schools,time,sizeof(struct school),cmp);
    int max=-1;
    int paiming=0;
    int lastpaiming;
    printf(&quot;%d\n&quot;,time);
    for(int i=0;i&lt;time;i++){
        paiming++;
        if((int)(schools[i].score)==max){
            printf(&quot;%d %s %d %d\n&quot;,lastpaiming,schools[i].name,(int)schools[i].score,schools[i].time);
            continue;
        }else{
            max=(int)schools[i].score;
            printf(&quot;%d %s %d %d\n&quot;,paiming,schools[i].name,(int)schools[i].score,schools[i].time);
        }
        lastpaiming=paiming;
    }
    return 0;
}
int search(int time,char *name){
    int start=0,end=time;
    while(start&lt;=end){
        int mid=(start+end)/2;
        int n=strcmp(schools[mid].name,name);
        if(n==0){
            return mid;
        }else if(n&gt;0){
            end=mid-1;
        }else{
            start=mid+1;
        }
    }
    return -1;
}
int cmp(const void *a1,const void *b1){
    struct school sc1=*(struct school *)a1;
    struct school sc2=*(struct school *)b1;
    int a=(int)sc1.score;
    int b=(int)sc2.score;
    if(a&gt;b){
        return -1;
    }else if(a&lt;b){
        return 1;
    }else{
        if(sc1.time&gt;sc2.time){
            return 1;
        }else if(sc1.time&lt;sc2.time){
        return -1;
        }else{
            return strcmp(sc1.name,sc2.name);
        }
    }
}
void toLowerCase(char *s){//将名字变为小写的函数
    while((*s)!=&apos;\0&apos;){
        if(*s&lt;=&apos;Z&apos;&amp;&amp;*s&gt;=&apos;A&apos;){
            *s=(*s)-&apos;A&apos;+&apos;a&apos;;
        }
        s++;
    }
}
int cnmp(const void *a,const void *b){
    struct school sch1=*(struct school*)a;
    struct school sch2=*(struct school*)b;
    return strcmp(sch1.name,sch2.name);
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1083</title>
    <url>/2019/10/11/PTA-Basic-1083/</url>
    <content><![CDATA[<p>题目：<br>给定 N 张卡片，正面分别写上 1、2、……、N，然后全部翻面，洗牌，在背面分别写上 1、2、……、N。将每张牌的正反两面数字相减（大减小），得到 N 个非负差值，其中是否存在相等的差？</p>
<p>输入格式：<br>输入第一行给出一个正整数 N（2 ≤ N ≤ 10 000），随后一行给出 1 到 N 的一个洗牌后的排列，第 i 个数表示正面写了 i 的那张卡片背面的数字。</p>
<p>输出格式：<br>按照“差值 重复次数”的格式从大到小输出重复的差值及其重复的次数，每行输出一个结果。</p>
<p>输入样例：</p>
<pre><code>8
3 5 8 6 2 1 4 7</code></pre><p>输出样例：</p>
<pre><code>5 2
3 3
2 2</code></pre><p>分析：定义一个非常大的数组就命名为差值数组，用数组下标存储差值，数组元素值存储此差值出现了多少次，<br>对第i个输入的数字，将其与其i值做差，取绝对值，存入差值数组中。最后倒序遍历输出数组下标与对应的值（大于1的）。<br>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
//而全局变量则可以全部自动初始化为0
int main(void){
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    int time[10002]={0};//如果不手动初始化数组，那么最大初始化为0的长度是7921
    int x,y;
    int z;
    for(int i=0;i&lt;n;i++){
        scanf(&quot;%d&quot;,&amp;x);
        z=abs(x-i-1);
        time[z]++;
    }
    for(int i=n-1;i&gt;=0;i--){
        if(time[i]&gt;1){
            printf(&quot;%d %d\n&quot;,i,time[i]);
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1082</title>
    <url>/2019/10/11/PTA-Basic-1082/</url>
    <content><![CDATA[<p>题目：</p>
<p>本题目给出的射击比赛的规则非常简单，谁打的弹洞距离靶心最近，谁就是冠军；谁差得最远，谁就是菜鸟。本题给出一系列弹洞的平面坐标(x,y)，请你编写程序找出冠军和菜鸟。我们假设靶心在原点(0,0)。</p>
<p>输入格式：<br>输入在第一行中给出一个正整数 N（≤ 10 000）。随后 N 行，每行按下列格式给出：</p>
<p>ID x y<br>其中 ID 是运动员的编号（由 4 位数字组成）；x 和 y 是其打出的弹洞的平面坐标(x,y)，均为整数，且 0 ≤ |x|, |y| ≤ 100。题目保证每个运动员的编号不重复，且每人只打 1 枪。</p>
<p>输出格式：<br>输出冠军和菜鸟的编号，中间空 1 格。题目保证他们是唯一的。</p>
<p>输入样例：</p>
<pre><code>3
0001 5 7
1020 -1 3
0233 0 -1</code></pre><p>输出样例：</p>
<pre><code>0233 0001</code></pre><p>分析：<br>直接对输入的每一行数据进行与最大值，最小值对比，然后变换。此处都是int型也是可以的。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    int maxid=0,minid=0;
    long lenmax=0,lenmin=20000;
    long id=0,x=0,y=0;
    for(int i=0;i&lt;n;i++){
        scanf(&quot;%ld %ld %ld&quot;,&amp;id,&amp;x,&amp;y);
        long len=x*x+y*y;
        if(len&gt;lenmax){
            lenmax=len;
            maxid=id;
        }
        if(len&lt;lenmin){
            lenmin=len;
            minid=id;
        }
    }
    printf(&quot;%04ld %04ld&quot;,minid,maxid);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1081</title>
    <url>/2019/10/11/PTA-Basic-1081/</url>
    <content><![CDATA[<p>题目：</p>
<p>本题要求你帮助某网站的用户注册模块写一个密码合法性检查的小功能。该网站要求用户设置的密码必须由不少于6个字符组成，并且只能有英文字母、数字和小数点 .，还必须既有字母也有数字。</p>
<p>输入格式：<br>输入第一行给出一个正整数 N（≤ 100），随后 N 行，每行给出一个用户设置的密码，为不超过 80 个字符的非空字符串，以回车结束。</p>
<p>输出格式：<br>对每个用户的密码，在一行中输出系统反馈信息，分以下5种：</p>
<p>如果密码合法，输出Your password is wan mei.；<br>如果密码太短，不论合法与否，都输出Your password is tai duan le.；<br>如果密码长度合法，但存在不合法字符，则输出Your password is tai luan le.；<br>如果密码长度合法，但只有字母没有数字，则输出Your password needs shu zi.；<br>如果密码长度合法，但只有数字没有字母，则输出Your password needs zi mu.。<br>输入样例：</p>
<pre><code>5
123s
zheshi.wodepw
1234.5678
WanMei23333
pass*word.6</code></pre><p>输出样例：</p>
<pre><code>Your password is tai duan le.
Your password needs shu zi.
Your password needs zi mu.
Your password is wan mei.
Your password is tai luan le.</code></pre><p>代码：<br>#include&lt;stdio.h&gt;<br>#include&lt;string.h&gt;<br>int main(void){<br>    int n;<br>    scanf(“%d”,&amp;n);//测试点二，是第一行的末尾的空格输入下一个。<br>    //scanf()函数则会保留换行符所以必须用getchar()吸收，防止作为一个输入行。<br>    getchar();<br>    char password[85];<br>    for(int i=0;i&lt;n;i++){<br>        int zifuflag=0;<br>        int zimuflag=0;<br>        int shuziflag=0;<br>        gets(password);//gets()函数会将换行符转换为‘\0’输入字符数组。<br>        int len=strlen(password);<br>        if(len&lt;6){<br>            printf(“Your password is tai duan le.\n”);<br>            continue;<br>        }<br>        for(int j=0;j&lt;len;j++){<br>            char ch=password[j];<br>            if((ch&gt;=’a’&amp;&amp;ch&lt;=’z’)||(ch&gt;=’A’&amp;&amp;ch&lt;=’Z’)){<br>                zimuflag=1;<br>            }<br>            if(ch&gt;=’0’&amp;&amp;ch&lt;=’9’){<br>                shuziflag=1;<br>            }<br>            if(ch!=’.’&amp;&amp;!(ch&lt;=’9’&amp;&amp;ch&gt;=’0’)&amp;&amp;!((ch&gt;=’a’&amp;&amp;ch&lt;=’z’)||(ch&gt;=’A’&amp;&amp;ch&lt;=’Z’))){<br>                zifuflag=1;<br>                break;<br>            }<br>        }<br>        if(zifuflag){<br>            printf(“Your password is tai luan le.\n”);<br>            continue;<br>        }<br>        if(zimuflag&amp;&amp;!shuziflag){<br>            printf(“Your password needs shu zi.\n”);<br>            continue;<br>        }<br>        if(!zimuflag&amp;&amp;shuziflag){<br>            printf(“Your password needs zi mu.\n”);<br>            continue;<br>        }<br>        if(zimuflag&amp;&amp;shuziflag){<br>            printf(“Your password is wan mei.\n”);<br>        }<br>    }<br>}</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1088</title>
    <url>/2019/10/16/PTA-Basic-1088/</url>
    <content><![CDATA[<p>题目：<br>当自然数 n 依次取 1、2、3、……、N 时，算式 ⌊n/2⌋+⌊n/3⌋+⌊n/5⌋ 有多少个不同的值？（注：⌊x⌋ 为取整函数，表示不超过 x 的最大自然数，即 x 的整数部分。）</p>
<p>输入格式：<br>输入给出一个正整数 N（2≤N≤10<br>​4<br>​​ ）。</p>
<p>输出格式：<br>在一行中输出题面中算式取到的不同值的个数。</p>
<p>输入样例：</p>
<pre><code>2017</code></pre><p>输出样例：</p>
<pre><code>1480</code></pre><p>思路：利用此函数的递增性。<br>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int n;
    int time=0;
    int last=-1;//初始一个数为-1，因为n为任何正数，值都不可能为-1
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++){
        int k=i/2+i/3+i/5;
        if(k==last){//如果与上一个相同就跳过此次
            continue;
        }else{
            time++;
            last=k;
        }
    }
    printf(&quot;%d&quot;,time);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1084</title>
    <url>/2019/10/11/PTA-Basic-1084/</url>
    <content><![CDATA[<p>题目：<br>外观数列是指具有以下特点的整数序列：</p>
<p>d, d1, d111, d113, d11231, d112213111, …<br>它从不等于 1 的数字 d 开始，序列的第 n+1 项是对第 n 项的描述。比如第 2 项表示第 1 项有 1 个 d，所以就是 d1；第 2 项是 1 个 d（对应 d1）和 1 个 1（对应 11），所以第 3 项就是 d111。又比如第 4 项是 d113，其描述就是 1 个 d，2 个 1，1 个 3，所以下一项就是 d11231。当然这个定义对 d = 1 也成立。本题要求你推算任意给定数字 d 的外观数列的第 N 项。</p>
<p>输入格式：<br>输入第一行给出 [0,9] 范围内的一个整数 d、以及一个正整数 N（≤ 40），用空格分隔。</p>
<p>输出格式：<br>在一行中给出数字 d 的外观数列的第 N 项。</p>
<p>输入样例：</p>
<pre><code>1 8</code></pre><p>输出样例：</p>
<pre><code>1123123111</code></pre><p>分析：做此题时，一定要在旁边自己演算一边推算过程，不要只看不动手。对于i-1项，从左边到右边读取，如果有连续的（n个）’d’就记作dn，第一个字符不算它是个特殊字符，不要把他与后面混为一谈，他始终是一个记作d1。<br>处理：</p>
<p>对于一个给定的字符，对其进行从1到n之间的推演，首先将此字符存储入数组，然后对此数组进行n次的推演。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
int main(void){
    int n;
    char ch;
    scanf(&quot;%c %d&quot;,&amp;ch,&amp;n);
    char res[100000]={0};//这个会非常大非常非常大。 
    char crs[100000]={0};
    res[0]=ch;
    for(int i=1;i&lt;n;i++){
        int time=0;
        int begin=0;
        for(int len=0;len&lt;strlen(res);len++){
            time++;
            if(res[len+1]==res[len]){//如果下一个字符还等于当前字符，继续数个数
                continue;
            }else{
                crs[begin++]=res[len];//首先存入字符再存入数字
                crs[begin++]=&apos;0&apos;+time;//这边我一开始担心有次数超过10的情况，但是那种处理起来有点麻烦，而且根据题目要求没看出来有大于10可能性的存在，就没考虑。
                time=0;//time赋值为0用于下一次的计算有多少个
            }
        }
        strcpy(res,crs);//将此次推演的结果存入res中用于下一次的推演。
    }
    printf(&quot;%s&quot;,res);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1086</title>
    <url>/2019/10/16/PTA-Basic-1086/</url>
    <content><![CDATA[<p>题目：</p>
<p>做作业的时候，邻座的小盆友问你：“五乘以七等于多少？”你应该不失礼貌地围笑着告诉他：“五十三。”本题就要求你，对任何一对给定的正整数，倒着输出它们的乘积。</p>
<p><img src="https://images.ptausercontent.com/0c3a4497-27c3-45ea-9c8e-5a1ab2df48af.jpg" alt></p>
<p>输入格式：<br>输入在第一行给出两个不超过 1000 的正整数 A 和 B，其间以空格分隔。</p>
<p>输出格式：<br>在一行中倒着输出 A 和 B 的乘积。</p>
<p>输入样例：</p>
<pre><code>5 7</code></pre><p>输出样例：</p>
<pre><code>53</code></pre><p>分析：不超过1000，那么乘积就不会超过1000000，int足够了。计算乘积存入数组，对结果不断取余，不断存入数组，直到为0，最后倒着输出数组。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main(void){
    int n,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    int c=n*m;
    int i=0;
    int result[20];
    int re=0;
    if(c==0){//注意为0是，直接输，出有一个测试点对应这个。
        printf(&quot;%d&quot;,c);
        return 0;
    }
    while(c!=0){
        result[i++]=c%10; 
        c=c/10;
    }
    for(int j=0;j&lt;i;j++){
        re=re*10+result[j];
    }
    printf(&quot;%d&quot;,re);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1087</title>
    <url>/2019/10/16/PTA-Basic-1087/</url>
    <content><![CDATA[<p>题目：</p>
<p>子曰：“三人行，必有我师焉。择其善者而从之，其不善者而改之。”</p>
<p>本题给定甲、乙、丙三个人的能力值关系为：甲的能力值确定是 2 位正整数；把甲的能力值的 2 个数字调换位置就是乙的能力值；甲乙两人能力差是丙的能力值的 X 倍；乙的能力值是丙的 Y 倍。请你指出谁比你强应“从之”，谁比你弱应“改之”。</p>
<p>输入格式：<br>输入在一行中给出三个数，依次为：M（你自己的能力值）、X 和 Y。三个数字均为不超过 1000 的正整数。</p>
<p>输出格式：<br>在一行中首先输出甲的能力值，随后依次输出甲、乙、丙三人与你的关系：如果其比你强，输出 Cong；平等则输出 Ping；比你弱则输出 Gai。其间以 1 个空格分隔，行首尾不得有多余空格。</p>
<p>注意：如果解不唯一，则以甲的最大解为准进行判断；如果解不存在，则输出 No Solution。</p>
<p>输入样例 1：</p>
<pre><code>48 3 7</code></pre><p>输出样例 1：</p>
<pre><code>48 Ping Cong Gai</code></pre><p>输入样例 2：</p>
<pre><code>48 11 6</code></pre><p>输出样例 2：</p>
<pre><code>No Solution</code></pre><p>分析：<br>输入的是自己的分数，x,y.<br>处理：从99到10假设甲的成绩，利用甲的成绩计算乙的成绩，看看这两个数是否符合条件，符合就计算丙的成绩，之后进行对比。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
int main(void){
    int n,x,y;
    scanf(&quot;%d %d %d&quot;,&amp;n,&amp;x,&amp;y);
    int a=10,b=0;//甲乙成绩肯定是整数
    double c=0;//丙的成绩不一定为整数。即（10-99）
    for(a=99;a&gt;9;a--){//因为甲是两位数，又以甲的最大值为唯一答案，所以要倒序。
        b=(a/10)+(a%10)*10;//利用甲的成绩计算乙的成绩
        if(abs(a-b)*y==x*b){//如果符合此条件那么丙的成绩就可以算出来了。
            c=abs(a-b)*1.0/x;//计算丙的成绩
            printf(&quot;%d &quot;,a);//先输出a的成绩
            if(a==n){//输出对比结果
                printf(&quot;Ping &quot;);
            }else if(a&gt;n){
                printf(&quot;Cong &quot;);
            }else{
                printf(&quot;Gai &quot;);
            }
            if(b==n){
                printf(&quot;Ping &quot;);
            }else if(b&gt;n){
                printf(&quot;Cong &quot;);
            }else{
                printf(&quot;Gai &quot;);
            }
            if(c==n*1.0){//c的成绩可能为浮点数，所以左右多应该为浮点数
                printf(&quot;Ping&quot;);
            }else if(c&gt;n*1.0){
                printf(&quot;Cong&quot;);
            }else{
                printf(&quot;Gai&quot;);
            }
            return 0;//找到即可退出程序。
        }
    }
    printf(&quot;No Solution&quot;);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1090</title>
    <url>/2019/10/16/PTA-Basic-1090/</url>
    <content><![CDATA[<p>题目：</p>
<p>集装箱运输货物时，我们必须特别小心，不能把不相容的货物装在一只箱子里。比如氧化剂绝对不能跟易燃液体同箱，否则很容易造成爆炸。</p>
<p>本题给定一张不相容物品的清单，需要你检查每一张集装箱货品清单，判断它们是否能装在同一只箱子里。</p>
<p>输入格式：<br>输入第一行给出两个正整数：N (≤10<br>​4<br>​​ ) 是成对的不相容物品的对数；M (≤100) 是集装箱货品清单的单数。</p>
<p>随后数据分两大块给出。第一块有 N 行，每行给出一对不相容的物品。第二块有 M 行，每行给出一箱货物的清单，格式如下：</p>
<p>K G[1] G[2] … G[K]<br>其中 K (≤1000) 是物品件数，G[i] 是物品的编号。简单起见，每件物品用一个 5 位数的编号代表。两个数字之间用空格分隔。</p>
<p>输出格式：<br>对每箱货物清单，判断是否可以安全运输。如果没有不相容物品，则在一行中输出 Yes，否则输出 No。</p>
<p>输入样例：</p>
<pre><code>6 3
20001 20002
20003 20004
20005 20006
20003 20001
20005 20004
20004 20006
4 00001 20004 00002 20003
5 98823 20002 20003 20006 10010
3 12345 67890 23333</code></pre><p>输出样例：</p>
<pre><code>No
Yes
Yes</code></pre><p>分析：定义一个结构体，包含此物体的不能放在一起的物品的个数，与它不能放在一起的物体的数组。定义一个图，用于标记出现过的危险品，然后对后来的危险品，先在图中看看有没有出现过，有就遍历它之后的数组部分看看后面的部分有没有它的危险品。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int contains(int key,int value);
typedef struct danger{
    int time;
    int op[999];
};
int map[100000];//用于标记某个危险品是否出现过
struct danger dangers[100000];
int main(void){
    int n,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    int key,value;
    for(int i=0;i&lt;n;i++){
        scanf(&quot;%d %d&quot;,&amp;key,&amp;value);
        if(map[key]==0)//此物品之前没有与它不能放在一起的物体
            dangers[key].time=0;//将对应的下标置为0
        if(map[value]==0)//同上
            dangers[value].time=0;
        dangers[key].op[dangers[key].time]=value;//此处为互相标记
        dangers[key].time++;
        dangers[value].op[dangers[value].time]=key;
        dangers[value].time++;
        map[key]=1;
        map[value]=1;
    }
    for(int i=0;i&lt;m;i++){
        int num=0;
        scanf(&quot;%d&quot;,&amp;num);
        int things[num];
        int flag=0;
        for(int j=0;j&lt;num;j++){//将某一行的危险品全部存入数组
            scanf(&quot;%d&quot;,&amp;things[j]);
        }
        for(int j=0;j&lt;num;j++){//遍历数组查看有没有排斥的
            if(map[things[j]]==0){//图中没有说明之前没有出现过
                continue;
            }else{//图中有说明之前出先过了，遍历它之后的部分看看有没有危险品
                for(int index=j+1;index&lt;num;index++){
                    if(contains(things[j],things[index])){//后面有危险品就标记一下，并跳出
                        flag=1;
                        break;
                    }
                }
            }
            if(flag){//如果标记过了
                    printf(&quot;No\n&quot;);
                    break;
                }
        }
        if(!flag){
            printf(&quot;Yes\n&quot;);
        }
    }
    return 0;
} 
int contains(int key,int value){
    for(int i=0;i&lt;dangers[key].time;i++){
        if(dangers[key].op[i]==value){
            return 1;
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1089</title>
    <url>/2019/10/16/PTA-Basic-1089/</url>
    <content><![CDATA[<p>题目：</p>
<p>以下文字摘自《灵机一动·好玩的数学》：“狼人杀”游戏分为狼人、好人两大阵营。在一局“狼人杀”游戏中，1 号玩家说：“2 号是狼人”，2 号玩家说：“3 号是好人”，3 号玩家说：“4 号是狼人”，4 号玩家说：“5 号是好人”，5 号玩家说：“4 号是好人”。已知这 5 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。扮演狼人角色的是哪两号玩家？</p>
<p>本题是这个问题的升级版：已知 N 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。要求你找出扮演狼人角色的是哪几号玩家？</p>
<p>输入格式：<br>输入在第一行中给出一个正整数 N（5≤N≤100）。随后 N 行，第 i 行给出第 i 号玩家说的话（1≤i≤N），即一个玩家编号，用正号表示好人，负号表示狼人。</p>
<p>输出格式：<br>如果有解，在一行中按递增顺序输出 2 个狼人的编号，其间以空格分隔，行首尾不得有多余空格。如果解不唯一，则输出最小序列解 —— 即对于两个序列 A=a[1],…,a[M] 和 B=b[1],…,b[M]，若存在 0≤k&lt;M 使得 a[i]=b[i] （i≤k），且 a[k+1]&lt;b[k+1]，则称序列 A 小于序列 B。若无解则输出 No Solution。</p>
<p>输入样例 1：</p>
<pre><code>5
-2
+3
-4
+5
+4</code></pre><p>输出样例 1：</p>
<pre><code>1 4</code></pre><p>输入样例 2：</p>
<pre><code>6
+6
+3
+1
-5
-2
+4</code></pre><p>输出样例 2（解不唯一）：</p>
<pre><code>1 5</code></pre><p>输入样例 3：</p>
<pre><code>5
-2
-3
-4
-5
-1</code></pre><p>输出样例 3：</p>
<pre><code>No Solution</code></pre><p>分析：<br>定义一个数组存储每个人说的话，定义一个身份数组存储每个人的身份初始为1，每个人都是村民。然后双重循环，假设第i与第j个人是狼人。之后在已经有狼人的情况下统计说谎的次数（此处题目的合格条件：村民中有一个说假话，狼人中有一个人说谎话）如果找到合格的输出终止程序，没找到输出No Solution。<br>注意：第i个说的可以是第任意个人，而不是顺序说下一个。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;//此题目中我们的两个数组都舍弃了一个空间为了方便思考
#include&lt;math.h&gt;
int main(void){
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    int a[n+1];
    int b[n+1];
    for(int i=1;i&lt;=n;i++){
        scanf(&quot;%d&quot;,&amp;a[i]);
        b[i]=1;//顺便初始化身份数组
    }
    for(int i=1;i&lt;=n;i++){
        for(int j=i+1;j&lt;=n;j++){//假设i,j个人是狼人
            b[i]=0;
            b[j]=0;
            int langtime=0;//狼人的说谎次数
            int time=0;//好人的说谎次数
            for(int x=1;x&lt;=n;x++){
                if((a[x]&gt;0&amp;&amp;b[abs(a[x])]==0)||(a[x]&lt;0&amp;&amp;b[abs(a[x])]==1)){
                    if(x==i||x==j)
                        langtime++;
                    else
                        time++;
                }
            }
            if(time==1&amp;&amp;langtime==1){//如果符合题目条件
                printf(&quot;%d %d&quot;,i,j);
                return 0;
            }//否则还原身份数组
            b[i]=1;
            b[j]=1;

        }
    }
    printf(&quot;No Solution&quot;);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1092</title>
    <url>/2019/10/16/PTA-Basic-1092/</url>
    <content><![CDATA[<p>题目：</p>
<p>月饼是久负盛名的中国传统糕点之一，自唐朝以来，已经发展出几百品种。</p>
<p>mk.jpg</p>
<p>若想评比出一种“最好吃”的月饼，那势必在吃货界引发一场腥风血雨…… 在这里我们用数字说话，给出全国各地各种月饼的销量，要求你从中找出销量冠军，认定为最好吃的月饼。</p>
<p>输入格式：<br>输入首先给出两个正整数 N（≤1000）和 M（≤100），分别为月饼的种类数（于是默认月饼种类从 1 到 N 编号）和参与统计的城市数量。</p>
<p>接下来 M 行，每行给出 N 个非负整数（均不超过 1 百万），其中第 i 个整数为第 i 种月饼的销量（块）。数字间以空格分隔。</p>
<p>输出格式：<br>在第一行中输出最大销量，第二行输出销量最大的月饼的种类编号。如果冠军不唯一，则按编号递增顺序输出并列冠军。数字间以 1 个空格分隔，行首尾不得有多余空格。</p>
<p>输入样例：</p>
<pre><code>5 3
1001 992 0 233 6
8 0 2018 0 2008
36 18 0 1024 4</code></pre><p>输出样例：</p>
<pre><code>2018
3 5</code></pre><p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
long long moonBin[1000];
int main(void){
    int n,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    long val;
    long long maxsale=0;
    for(int i=0;i&lt;m;i++){
        for(int j=0;j&lt;n;j++){
            scanf(&quot;%ld&quot;,&amp;val);
            moonBin[j]=moonBin[j]+val;
            if(moonBin[j]&gt;maxsale){
                maxsale=moonBin[j];
            }
        }
    }
    printf(&quot;%ld\n&quot;,maxsale);
    int flag=0;
    for(int i=0;i&lt;n;i++){
        if(maxsale==moonBin[i]){
            if(flag){
                printf(&quot; &quot;);
            }else{
                flag=1;
            }
            printf(&quot;%d&quot;,i+1);
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1091</title>
    <url>/2019/10/16/PTA-Basic-1091/</url>
    <content><![CDATA[<p>题目：<br>如果某个数 K 的平方乘以 N 以后，结果的末尾几位数等于 K，那么就称这个数为“N-自守数”。例如 3×92<br>​2<br>​​ =25392，而 25392 的末尾两位正好是 92，所以 92 是一个 3-自守数。</p>
<p>本题就请你编写程序判断一个给定的数字是否关于某个 N 是 N-自守数。</p>
<p>输入格式：<br>输入在第一行中给出正整数 M（≤20），随后一行给出 M 个待检测的、不超过 1000 的正整数。</p>
<p>输出格式：<br>对每个需要检测的数字，如果它是 N-自守数就在一行中输出最小的 N 和 N*K^<br>​2<br>​​  的值，以一个空格隔开；否则输出 No。注意题目保证 N&lt;10。</p>
<p>输入样例：</p>
<pre><code>3
92 5 233</code></pre><p>输出样例：</p>
<pre><code>3 25392
1 25
No</code></pre><p>分析：题目说了保证n&lt;10，即在1-9之中找就可以了，定义一个判断是不是字守数的函数，然后对每个数字判断就可以了。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
int re(long value,long contains);
int main(void){
    int n;
    int key;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++){
        scanf(&quot;%d&quot;,&amp;key);
        int k=1;
        for(;k&lt;10;k++){
            if(re(key*key*k,key)){
                printf(&quot;%d %ld\n&quot;,k,key*key*k);
                break;
            }
        }
        if(k&gt;9){
            printf(&quot;No\n&quot;);
        }
    }
}
int re(long value,long contains){
    int i=0;
    long key=contains;
    do{
        i++;
        key=key/10;
    }while(key);
    if((value-contains)%((int)pow(10,i))==0){
        return 1;
    }    
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1093</title>
    <url>/2019/10/16/PTA-Basic-1093/</url>
    <content><![CDATA[<p>题目：<br>给定两个字符串 A 和 B，本题要求你输出 A+B，即两个字符串的并集。要求先输出 A，再输出 B，但重复的字符必须被剔除。</p>
<p>输入格式：<br>输入在两行中分别给出 A 和 B，均为长度不超过 10<br>​6<br>​​ 的、由可见 ASCII 字符 (即码值为32~126)和空格组成的、由回车标识结束的非空字符串。</p>
<p>输出格式：<br>在一行中输出题面要求的 A 和 B 的和。</p>
<p>输入样例：</p>
<pre><code>This is a sample test
to show you_How it works</code></pre><p>输出样例：</p>
<pre><code>This ampletowyu_Hrk</code></pre><p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
char a[2000002];
char b[1000001];
char *del(char *s,char c){
    char *src,*dst;
    for(src=dst=s;*src!=&apos;\0&apos;;src++){
        *dst=*src;
        if(*dst!=c)
            dst++;
    }
    *dst=&apos;\0&apos;;
    return dst;
} 
int main(void){
    gets(a);
    char *s=a;//如果先先连接再去重复的话操作时间比对每个先去重再连接再去重用的时间长。
    while(*s){
        del(s+1,*s);
        s++;
    }
    gets(b);
    s=b;
    while(*s){
        del(s+1,*s);
        s++;
    }
    strcat(a,b);
    s=a;
    while(*s){
        del(s+1,*s);
        s++;
    }
    puts(a);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1094</title>
    <url>/2019/10/16/PTA-Basic-1094/</url>
    <content><![CDATA[<p>###题目描述</p>
<p>2004 年 7 月，谷歌在硅谷的 101 号公路边竖立了一块巨大的广告牌（如下图）用于招聘。内容超级简单，就是一个以 .com 结尾的网址，而前面的网址是一个 10 位素数，这个素数是自然常数 e 中最早出现的 10 位连续数字。能找出这个素数的人，就可以通过访问谷歌的这个网站进入招聘流程的下一步。</p>
<p><img src="https://images.ptausercontent.com/57148679-d574-4f49-b048-775c6c07791c.jpg" alt></p>
<p>自然常数 e 是一个著名的超越数，前面若干位写出来是这样的：e = 2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427427466391932003059921… 其中粗体标出的 10 位数就是答案。</p>
<p>本题要求你编程解决一个更通用的问题：从任一给定的长度为 L 的数字中，找出最早出现的 K 位连续数字所组成的素数。</p>
<p>输入格式：<br>输入在第一行给出 2 个正整数，分别是 L（不超过 1000 的正整数，为数字长度）和 K（小于 10 的正整数）。接下来一行给出一个长度为 L 的正整数 N。<br>###格式<br>输出格式：<br>在一行中输出 N 中最早出现的 K 位连续数字所组成的素数。如果这样的素数不存在，则输出 404。注意，原始数字中的前导零也计算在位数之内。例如在 200236 中找 4 位素数，0023 算是解；但第一位 2 不能被当成 0002 输出，因为在原始数字中不存在这个 2 的前导零。<br>###样例<br>输入样例 1：</p>
<pre><code>20 5
23654987725541023819</code></pre><p>输出样例 1：</p>
<pre><code>49877</code></pre><p>输入样例 2：</p>
<pre><code>10 3

2468024680</code></pre><p>输出样例 2：</p>
<pre><code>404</code></pre><p>代码：</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1095</title>
    <url>/2019/10/16/PTA-Basic-1095/</url>
    <content><![CDATA[<p>题目：</p>
<p>PAT 准考证号由 4 部分组成：</p>
<p>第 1 位是级别，即 T 代表顶级；A 代表甲级；B 代表乙级；<br>第 2<del>4 位是考场编号，范围从 101 到 999；<br>第 5</del>10 位是考试日期，格式为年、月、日顺次各占 2 位；<br>最后 11~13 位是考生编号，范围从 000 到 999。<br>现给定一系列考生的准考证号和他们的成绩，请你按照要求输出各种统计信息。</p>
<p>输入格式：<br>输入首先在一行中给出两个正整数 N（≤10<br>​4<br>​​ ）和 M（≤100），分别为考生人数和统计要求的个数。</p>
<p>接下来 N 行，每行给出一个考生的准考证号和其分数（在区间 [0,100] 内的整数），其间以空格分隔。</p>
<p>考生信息之后，再给出 M 行，每行给出一个统计要求，格式为：类型 指令，其中</p>
<p>类型 为 1 表示要求按分数非升序输出某个指定级别的考生的成绩，对应的 指令 则给出代表指定级别的字母；<br>类型 为 2 表示要求将某指定考场的考生人数和总分统计输出，对应的 指令 则给出指定考场的编号；<br>类型 为 3 表示要求将某指定日期的考生人数分考场统计输出，对应的 指令 则给出指定日期，格式与准考证上日期相同。<br>输出格式：<br>对每项统计要求，首先在一行中输出 Case #: 要求，其中 # 是该项要求的编号，从 1 开始；要求 即复制输入给出的要求。随后输出相应的统计结果：</p>
<p>类型 为 1 的指令，输出格式与输入的考生信息格式相同，即 准考证号 成绩。对于分数并列的考生，按其准考证号的字典序递增输出（题目保证无重复准考证号）；<br>类型 为 2 的指令，按 人数 总分 的格式输出；<br>类型 为 3 的指令，输出按人数非递增顺序，格式为 考场编号 总人数。若人数并列则按考场编号递增顺序输出。<br>如果查询结果为空，则输出 NA。</p>
<p>输入样例：</p>
<pre><code>8 4
B123180908127 99
B102180908003 86
A112180318002 98
T107150310127 62
A107180908108 100
T123180908010 78
B112160918035 88
A107180908021 98
1 A
2 107
3 180908
2 999</code></pre><p>输出样例：</p>
<pre><code>Case 1: 1 A
A107180908108 100
A107180908021 98
A112180318002 98
Case 2: 2 107
3 260
Case 3: 3 180908
107 2
123 2
102 1
Case 4: 2 999
NA</code></pre><p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

struct id{
        char str[14];
        char level[2];
        int room;
        int date;
        int num;
        int score;
};

int cmp(const void *a, const void *b)
{
        struct id *ida = (struct id*)a, *idb = (struct id*)b;
        if (ida-&gt;score != idb-&gt;score)
                return idb-&gt;score - ida-&gt;score;
        return strcmp(ida-&gt;str, idb-&gt;str);
}

int type1(struct id ids[], int n, int i);
int type2(struct id ids[], int n, int i);
int type3(struct id ids[], int n, int i);

int main()
{
        struct id ids[10000];
        int n, m, type;
        int i;
        char level[2];

        scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
        for (i = 0; i &lt; n; i++) {
                scanf(&quot;%s %d&quot;, ids[i].str, &amp;ids[i].score);
                sscanf(ids[i].str, &quot;%1s%3d%6d%3d&quot;, ids[i].level,
                                &amp;ids[i].room, &amp;ids[i].date, &amp;ids[i].num);
        }

        qsort(ids, n, sizeof(ids[0]), cmp);

        for (i = 0; i &lt; m; i++) {
                scanf(&quot;%d&quot;, &amp;type);
                if (type == 1)
                        type1(ids, n, i);
                else if (type == 2)
                        type2(ids, n, i);
                else if (type == 3)
                        type3(ids, n, i);
        }

        return 0;
}

int type1(struct id ids[], int n, int i)
{
        char level[2];
        int f = 1, j;
        scanf(&quot;%1s&quot;, level);
        printf(&quot;Case %d: %d %c\n&quot;, i + 1, 1, level[0]);
        for (j = 0; j &lt; n; j++)
                if (ids[j].level[0] == level[0]) {
                        f = 0;
                        printf(&quot;%s %d\n&quot;, ids[j].str,ids[j].score);
                }
        if (f)
                puts(&quot;NA&quot;);
        return 0;
}

int type2(struct id ids[], int n, int i)
{
        int room, sum = 0, count = 0;
        int j, f = 1;

        scanf(&quot;%d&quot;, &amp;room);
        printf(&quot;Case %d: %d %d\n&quot;, i + 1, 2, room);
        for (j = 0; j &lt; n; j++)
                if (ids[j].room == room) {
                        f = 0;
                        count++;
                        sum += ids[j].score;
                }
        if (f)
                puts(&quot;NA&quot;);
        else
                printf(&quot;%d %d\n&quot;, count, sum);

        return 0;
}

int type3(struct id ids[], int n, int i)
{
        int date, max = 0, rooms[1000] = {0};
        int f = 1, j;

        scanf(&quot;%d&quot;, &amp;date);
        printf(&quot;Case %d: %d %06d\n&quot;, i + 1, 3, date);
        for (j = 0; j &lt; n; j++)
                if (ids[j].date == date) {
                        f = 0;
                        rooms[ids[j].room]++;
                        if (max &lt; rooms[ids[j].room])
                                max = rooms[ids[j].room];
                }
        if (f)
                puts(&quot;NA&quot;);
        else
                for (; max &gt; 0; max--)
                        for (j = 101; j &lt; 1000; j++)
                                if (rooms[j] == max)
                                        printf(&quot;%d %d\n&quot;, j, max);

        return 0;
}</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-39</title>
    <url>/2020/07/02/LeetCode-39/</url>
    <content><![CDATA[<p><img src="/2020/07/02/LeetCode-39/1.png" alt></p>
]]></content>
      <tags>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-40</title>
    <url>/2020/07/02/LeetCode-40/</url>
    <content><![CDATA[<p><img src="/2020/07/02/LeetCode-40/1.png" alt></p>
]]></content>
      <tags>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>降低nodejs版本</title>
    <url>/2021/01/08/%E9%99%8D%E4%BD%8Enodejs%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="使用hexo上传博文时出现异常"><a href="#使用hexo上传博文时出现异常" class="headerlink" title="使用hexo上传博文时出现异常"></a>使用hexo上传博文时出现异常</h2><a id="more"></a>

<p><img src="/2021/01/08/%E9%99%8D%E4%BD%8Enodejs%E7%89%88%E6%9C%AC/image-20210108115116863.png" alt="image-20210108115116863"></p>
<p>原因：node版本太高且向前兼容性不好导致文件解析失败</p>
<p>解决：降低node的版本</p>
<ol>
<li>cmd中输入where node</li>
</ol>
<p><img src="/2021/01/08/%E9%99%8D%E4%BD%8Enodejs%E7%89%88%E6%9C%AC/clip_image001.png" alt="img"></p>
<ol start="2">
<li>删除exe所在文件目录中所有内容</li>
</ol>
<p><img src="/2021/01/08/%E9%99%8D%E4%BD%8Enodejs%E7%89%88%E6%9C%AC/clip_image002.png" alt="img"></p>
<ol start="3">
<li>控制面板中卸载node.js</li>
</ol>
<p><img src="/2021/01/08/%E9%99%8D%E4%BD%8Enodejs%E7%89%88%E6%9C%AC/clip_image004.jpg" alt="img"></p>
<ol start="4">
<li>安装第版本的node</li>
</ol>
<p>版本入口：<a href="https://nodejs.org/download/release">https://nodejs.org/download/release</a> [注意选择下载.msi后缀结尾的文件这是Windows](<a href="https://nodejs.org/download/release，">https://nodejs.org/download/release，</a> 注意选择下载.msi后缀结尾的文件这是Windows)的安装文件，注意不要下载zip文件因为</p>
<ol>
<li><p>msi 为安装版本，安装过程中自动配置</p>
</li>
<li><p>zip 为压缩版本，安装过程中手动配置</p>
</li>
</ol>
<p>最后按照教程安装即可。</p>
<p>如果出现npm版本过高的情况，如下图</p>
<p><img src="/2021/01/08/%E9%99%8D%E4%BD%8Enodejs%E7%89%88%E6%9C%AC/image-20210108115611951.png" alt="image-20210108115611951"></p>
<p>只需要，cmd中安装合适的版本即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g npm@推荐的版本即可 </span><br><span class="line"><span class="comment">##推荐的版本可以到官网上查找</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯算法解析</title>
    <url>/2020/07/02/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="什么是回溯算法？"><a href="#什么是回溯算法？" class="headerlink" title="什么是回溯算法？"></a>什么是回溯算法？</h1><a id="more"></a>
<blockquote>
<p>回溯算法实际上是一种类似与枚举的搜索尝试过程，主要是在搜索尝试的过程寻找问题的<br>解，如果已经发现某个搜索尝试分支不可能得出正确的答案就回溯（返回），尝试别的<br>路径进行搜索。本质上是一种<strong>选优搜索法</strong>，按照某个条件向前搜索，以达到目标。</p>
</blockquote>
<h1 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h1><p>回溯算法，实际上就是一种在<strong>问题的解空间</strong>中，查找<strong>有效的解子空间</strong>的过程。</p>
<h1 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h1><ol>
<li>确定问题的解空间，这个空间包含了问题的有效解，与无效解。</li>
<li>利用适合搜索的方法组织解空间（即考虑采用何种思路，来设计一个有效解的产生过程）</li>
<li>利用深度优先搜索法搜索解空间</li>
<li>利用<strong>剪枝函数</strong>来避免无效解所在的路径</li>
</ol>
<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><blockquote>
<p>从一条路往前走，能进则进，不能进则退回来，换一条路再试。本质上就是一种模拟人的<br>解决思路的算法。</p>
</blockquote>
<h1 id="经典问题：八皇后问题"><a href="#经典问题：八皇后问题" class="headerlink" title="经典问题：八皇后问题"></a>经典问题：八皇后问题</h1><blockquote>
<p>在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一<br>行、同一列或同一斜线上，问有多少种摆法。</p>
</blockquote>
<p><img src="/2020/07/02/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/1.PNG" alt="八皇后问题的一个解"></p>
<p>按照回溯算法的思路：</p>
<ol>
<li>放置皇后x在任意棋盘上的一个格子中</li>
<li>然后再剩余的合理的棋盘格子中任选一个放置皇后x+1</li>
<li>重复以上过程，如果皇后x放置后，剩余的皇后没有合理的放置位置，那么就改变当前皇后的位置，继续重复1，2过程。直到所有皇后均被放置后即得到一个解，然后返回临近的上一个编号的皇后的位置，继续改变它所有的可能。</li>
</ol>
<h1 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h1><p><strong>代码来源于百度词库</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_number = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> ColumnIndex[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++ i)</span><br><span class="line"> </span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length; ++ j)</span><br><span class="line"> </span><br><span class="line">        &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>((i - j == ColumnIndex[i] - ColumnIndex[j])</span><br><span class="line"> </span><br><span class="line">                || (j - i == ColumnIndex[i] - ColumnIndex[j]))</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintQueen</span><span class="params">(<span class="keyword">int</span> ColumnIndex[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Solution %d\n"</span>, g_number);</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, ColumnIndex[i]);</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="keyword">int</span> ColumnIndex[], <span class="keyword">int</span> length, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(index == length)</span><br><span class="line"> </span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(Check(ColumnIndex, length))</span><br><span class="line"> </span><br><span class="line">        &#123;</span><br><span class="line"> </span><br><span class="line">            ++ g_number;</span><br><span class="line"> </span><br><span class="line">            PrintQueen(ColumnIndex, length);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"> </span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; length; ++ i)</span><br><span class="line"> </span><br><span class="line">        &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">int</span> temp = ColumnIndex[i];</span><br><span class="line"> </span><br><span class="line">            ColumnIndex[i] = ColumnIndex[index];</span><br><span class="line"> </span><br><span class="line">            ColumnIndex[index] = temp;</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">            Permutation(ColumnIndex, length, index + <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">            temp = ColumnIndex[index];</span><br><span class="line"> </span><br><span class="line">            ColumnIndex[index] = ColumnIndex[i];</span><br><span class="line"> </span><br><span class="line">            ColumnIndex[i] = temp;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EightQueen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> queens = <span class="number">8</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> ColumnIndex[queens];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queens; ++ i)</span><br><span class="line"> </span><br><span class="line">        ColumnIndex[i] = i+<span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">    Permutation(ColumnIndex, queens, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	EightQueen();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>队列详解</title>
    <url>/2021/01/09/%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="队列数据结构详解"><a href="#队列数据结构详解" class="headerlink" title="队列数据结构详解"></a>队列数据结构详解</h2><a id="more"></a>

<p>定义：队列是一种<strong>操作受限的线性表</strong>，就像日常生活中的排队一样。</p>
<p>特点：只允许对队首进行删除，对队尾进行插入操作。先进先出的操作特点。</p>
<p>组成：</p>
<p>​    队头(front)：队列两端中允许进行删除的一端</p>
<p>​    队尾(rear)：两端中允许进行插入的一端</p>
<p>​    enQueue(元素):入队，返回插入的结果</p>
<p>​    deQueue():出队，返回队首的元素</p>
<p>实现方式：</p>
<p>一、顺序队列</p>
<p>使用数组实现，开始时队首指针和队尾指针指向同一个位置，然后当有新的元素加入队列的时候，通过移动游标rear来加入新的元素。</p>
<ul>
<li>初始化：指针front和rear都指向0</li>
<li>入队：<code>队不满</code>，<code>数组不越界</code>，先入队，再队尾下标+1</li>
<li>出队：队不空，先取队头位置元素，在队头+1</li>
</ul>
<p>优点：</p>
<p>​    简单，容易实现</p>
<p>缺点：</p>
<p>​    空间利用率极低，由于是 移动游标的方式，因此一旦元素被删除之后，以前存放的空间就不可以再用了。</p>
<p>二、循环队列</p>
<p>解决了第一种实现方式空间利用率不高的问题。将队列收尾向连线程一个环状结构，当容量达到队列最大值的时候就插入到原来的队首处。</p>
<ul>
<li>初始化：数组的front和rear都指向0.</li>
<li>入队：<code>队</code>不满，先队尾位置传值，再<code>rear=(rear + 1) % maxsize;</code></li>
<li>出队：队不空，先取队头位置元素，<code>front=(front + 1)%maxsize;</code></li>
<li>是否为空：<code>return rear == front;</code></li>
<li>大小：<code>return (rear+maxsize-front)%maxsize;</code></li>
</ul>
<p>代码实现：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">public class seqQueue&lt;T&gt; &#123;</span><br><span class="line">	private T data[];</span><br><span class="line">	private int front;</span><br><span class="line">	private int rear;</span><br><span class="line">	private int maxsize;</span><br><span class="line"></span><br><span class="line">	public seqQueue(int i)</span><br><span class="line">	&#123;</span><br><span class="line">		data = (T[]) new Object[i+1];</span><br><span class="line">		front = 0;</span><br><span class="line">		rear = 0;</span><br><span class="line">		maxsize = i+1;</span><br><span class="line">	&#125;</span><br><span class="line">	public int  lenth() &#123;</span><br><span class="line">		return (rear+maxsize-front)%maxsize;</span><br><span class="line">	&#125;</span><br><span class="line">	public boolean isempty() &#123;</span><br><span class="line">		return rear == front;</span><br><span class="line">	&#125;</span><br><span class="line">	public boolean isfull() &#123;</span><br><span class="line">		return (rear + 1) % maxsize == front;</span><br><span class="line">	&#125;</span><br><span class="line">	public void enQueue(T i) throws Exception</span><br><span class="line">	&#123;</span><br><span class="line">		if (isfull())</span><br><span class="line">			throw new Exception("已满");</span><br><span class="line">		else &#123;</span><br><span class="line">			data[rear] = i;</span><br><span class="line">			rear=(rear + 1) % maxsize;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public T deQueue() throws Exception</span><br><span class="line">	&#123;</span><br><span class="line">		if (isempty())</span><br><span class="line">			throw new Exception("已空");</span><br><span class="line">		else &#123;</span><br><span class="line">			T va=data[front];</span><br><span class="line">			front=(front+1)%maxsize;</span><br><span class="line">			return va;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public String toString()</span><br><span class="line">	&#123;</span><br><span class="line">		String va="队头: ";</span><br><span class="line">		int lenth=lenth();</span><br><span class="line">		for(int i=0;i&lt;lenth;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			va+=data[(front+i)%maxsize]+" ";</span><br><span class="line">		&#125;</span><br><span class="line">		return va;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种队列对比</p>
<p><img src="/2021/01/09/%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3/image-20210109233548793.png" alt="image-20210109233548793"></p>
<p>​    三、链式队列</p>
<p>前面两种实现的缺点，空间总是有限的，即使是循环队列，当队列中的元素操作预先设定好的最大容量时也会发生元素替换的非法情况，因此有了队列的链式实现。</p>
<p>实现方式：以链表头作为队首，保存一个指向队尾的执政，当有元素插入的时候，就移动队尾的指针向后移动，然后。当有元素删除的时候就直接移动队首指针，使它指向下一个节点。</p>
<p>代码；</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">public class listQueue&lt;T&gt; &#123;</span><br><span class="line">	static class node&lt;T&gt; &#123;</span><br><span class="line">		T data;// 节点的结果</span><br><span class="line">		node next;// 下一个连接的节点</span><br><span class="line">		public node() &#123;&#125;</span><br><span class="line">		public node(T data) &#123;</span><br><span class="line">			this.data = data;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	node front;//相当于head 带头节点的</span><br><span class="line">	node rear;//相当于tail/<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">public</span> listQueue() &#123;</span><br><span class="line">		front=<span class="keyword">new</span> node&lt;T&gt;();</span><br><span class="line">		rear=front;</span><br><span class="line">	&#125;</span><br><span class="line">	public int  lenth() &#123;</span><br><span class="line">		int len=0;</span><br><span class="line">		node team=front;</span><br><span class="line">		while(team!=rear)</span><br><span class="line">		&#123;</span><br><span class="line">			len++;team=team.next;</span><br><span class="line">		&#125;</span><br><span class="line">		return len;</span><br><span class="line">	&#125;</span><br><span class="line">	public boolean isempty() &#123;</span><br><span class="line">		return rear == front;</span><br><span class="line">	&#125;</span><br><span class="line">	public void enQueue(T value) // 入队.尾部插入</span><br><span class="line">	&#123;</span><br><span class="line">		node va=new node&lt;T&gt;(value);</span><br><span class="line">		rear.next=va;</span><br><span class="line">		rear=va;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public T deQueue() throws Exception// 出队</span><br><span class="line">	&#123;</span><br><span class="line">		if (isempty())</span><br><span class="line">			throw new Exception("已空");</span><br><span class="line">		else &#123;</span><br><span class="line">			T va=(T) front.next.data;</span><br><span class="line">			front.next=front.next.next;</span><br><span class="line">			return va;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public String toString()</span><br><span class="line">	&#123;</span><br><span class="line">		node team=front.next;</span><br><span class="line">		String va="队头： ";</span><br><span class="line">		while(team!=null)</span><br><span class="line">		&#123;</span><br><span class="line">			va+=team.data+" ";</span><br><span class="line">			team=team.next;</span><br><span class="line">		&#125;</span><br><span class="line">		return va;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考资料</p>
<p>1.<a href="https://www.cnblogs.com/bigsai/p/11363071.html">https://www.cnblogs.com/bigsai/p/11363071.html</a></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>电脑网络故障排查步骤</title>
    <url>/2021/01/08/%E7%94%B5%E8%84%91%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<h2 id="电脑网络故障排查"><a href="#电脑网络故障排查" class="headerlink" title="电脑网络故障排查"></a>电脑网络故障排查</h2><a id="more"></a>

<ol>
<li><p>网络故障排查:</p>
<p> 硬件故障：网卡自身故障、网卡未正确安装、网卡故障、集线器故障…</p>
<p> 软件故障：表现：网卡的信号指示灯不亮</p>
<p>控制面板&gt;系统和安全&gt;硬件与声音&gt;设备管理器（不同电脑可能不同）进入后点击网络适配器在常规选项卡中查看各个适配的的工作状态</p>
<p>具体如图：</p>
<p><img src="/2021/01/08/%E7%94%B5%E8%84%91%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E6%AD%A5%E9%AA%A4/clip_image002.jpg" alt="img">)<img src="/2021/01/08/%E7%94%B5%E8%84%91%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E6%AD%A5%E9%AA%A4/clip_image004.jpg" alt="img">…</p>
<p>如果驱动有问题，那么重新下载安装即可。安装之后在查看一次</p>
</li>
<li><p>如果上一步已经解决，还是有问题，那么接下来检查网络协议</p>
<p>a)   控制面板&gt;网络&gt;配置各种协议是否安装成功</p>
<p>Ping 本地循环 地址看看网卡是否正常工作</p>
<p>​    Ping 127.0.0.1</p>
<p><img src="/2021/01/08/%E7%94%B5%E8%84%91%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E6%AD%A5%E9%AA%A4/clip_image005.png" alt="img"></p>
<p>如果正常接受数据说明TCP/IP协议正常工作</p>
<p> 如果不正常工作说明TCP/IP协议出现了问题</p>
</li>
</ol>
<p>​    使用ipconfig查看本地的IP地址，ping该IP地址如果IP地址如果成功ping通说明网络适配器工作正常，如果不是则说明网络适配器出现了问题。如网络适配器并没有问题那么进入下一个步骤进行测试。</p>
<p>​    Ping 本地的网关地址，如果 不同说明与网关之间的连线出现了问题。同时也可ping以下与自己连线的路由在本网段的IP地址如果不通说明，线路有问题。</p>
<p>如果通最后在ping一下目的机器的ip地址如果ping通了，但是ping域名没通说明DNS出现了问题，</p>
<p>总结：</p>
<p>1.首先进入命令行模式，通过 ping 127.0.0.1 来判断 TCP/IP 协议是否</p>
<p>正确安装，不通则重新安装设置。</p>
<p>2.输入 IPCONFIG 获得本机 IP 网关，通过 PING 本机 IP 判断网卡是否</p>
<p>有问题 如果不通 重新安装驱动．</p>
<p>3.前两步已经判断工作正常，可查看线路问题还是出在远程服务器或路</p>
<p>由器线路上 执行 PINF 网关 IP 地址，如果不通则说明问题基本出在线</p>
<p>路上，这个时可查看 RJ45 水晶头是否扭断和更换网线测试，如果通则说</p>
<p>明从本机到服务器或路由器的远程连接正常，问题在电信方面，与本机</p>
<p>无关。 </p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>电脑维修</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql用户权限不足</title>
    <url>/2020/07/16/MySql%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E4%B8%8D%E8%B6%B3/</url>
    <content><![CDATA[<p>MySQL建立表时出现：1044 - Access denied for user ‘root’@’localhost’ to database ‘xxx’<br>原因：root账号没有在xxx数据库里面进行建表的权限，可能xxx数据库是系统数据库，而root账户的权限不足。<br>解决：修改使用的数据库</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>DBMS</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中使用错误的代理导致类型转化异常</title>
    <url>/2020/07/16/Spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%94%99%E8%AF%AF%E7%9A%84%E4%BB%A3%E7%90%86%E5%AF%BC%E8%87%B4%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>Bean named ‘userService’ is expected to be of type ‘com.eju.service.impl.UserServiceImpl’ but was actually of type ‘com.sun.proxy.$Proxy13’</p>
<p>原因：由于通知类的方法中将代理对象转化为具体的Spring默认使用的是JDK动态代理，jdk的动态代理不支持类注入，只支持接口方式注入。<br>解决：改变配置，使用Cglib动态代理。</p>
]]></content>
      <categories>
        <category>后端</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Spring整合MyBatis时遇到的bugs</title>
    <url>/2020/07/12/%E4%BD%BF%E7%94%A8Spring%E6%95%B4%E5%90%88MyBatis%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84bugs/</url>
    <content><![CDATA[<h1 id="在整合Spring与MyBatis时遇到的bugs"><a href="#在整合Spring与MyBatis时遇到的bugs" class="headerlink" title="在整合Spring与MyBatis时遇到的bugs"></a>在整合Spring与MyBatis时遇到的bugs</h1><a id="more"></a>

<h2 id="1未找到Class文件异常"><a href="#1未找到Class文件异常" class="headerlink" title="1未找到Class文件异常"></a>1未找到Class文件异常</h2><p><img src="/2020/07/12/%E4%BD%BF%E7%94%A8Spring%E6%95%B4%E5%90%88MyBatis%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84bugs/a.png" alt="异常截图"></p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>根据错误提示，应该是 相关的class 没有找到，确认Java类没有编程出错，各种XML配置文件没有配置出错，但是启动Tomcat加载项目的时候仍然报了此错误，就感到很奇怪。于是就去查看项目的classes目录下是否存在报错提示的那个class，一看才知道项目的classes目录竟然什么都没有，这下就明白出错的原因了，是项目没有正确的生成class。</p>
<h2 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h2><p>首先要到eclipse的工作空间中找到这个项目，查看是否生成了class文件，<br>工作路径：Eclipse.metadata.plugins\org.eclipse.wst.server.core</p>
<blockquote>
<p><img src="/2020/07/12/%E4%BD%BF%E7%94%A8Spring%E6%95%B4%E5%90%88MyBatis%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84bugs/b.png" alt></p>
</blockquote>
<p>每当配置了一个新服务器都会生成一个temp文件夹用来存放web项目，很显然，我的项目使用的temp1目录，打开后进入wtpwebapps目录就可以看到发布到目录中的项目，进入项目后发现classes中一个文件也没有。</p>
<p><img src="/2020/07/12/%E4%BD%BF%E7%94%A8Spring%E6%95%B4%E5%90%88MyBatis%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84bugs/c.png" alt></p>
<p>然后查看代码，与配置文件没有任何错误，jar包也没有导错版本。那么<strong>极有可能是eclipse工具的问题</strong>，他它没有及时的对代码进行编译成classes文件，清理项目后(project-&gt;clean-&gt;清理当前项目)，再重启eclipse后，解决了问题。</p>
]]></content>
      <categories>
        <category>后端</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-41</title>
    <url>/2020/07/05/LeetCode-41/</url>
    <content><![CDATA[<p>##题目:<br><img src="/2020/07/05/LeetCode-41/1.png" alt><br>##本题难点<br>本题主要是将数组元素对应位置处的数字做一个标记，那么这个标记如何做呢？只能通过把值赋值为相反数来做标记，前提是把原数组中所有的非正数化为正数。<br>##代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len=nums.length;</span><br><span class="line">		<span class="comment">//将数组中小于等于0的数字都化为大于len的数字便于做标记</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(nums[i]&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">				nums[i]=len+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//遍历数组将数组中的小于等于len的数字对应位置存储的数字化为相反数</span></span><br><span class="line">		<span class="comment">//这样做不会影响后面的遍历</span></span><br><span class="line">		<span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">			temp=Math.abs(nums[i]);</span><br><span class="line">			<span class="keyword">if</span>(temp&lt;=len)&#123;</span><br><span class="line">				nums[temp-<span class="number">1</span>]=-Math.abs(nums[temp-<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//经过以上两步，遍历数组中不是负数的位置+1即是答案</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(nums[i]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> len+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##tips<br>O(2n)也是O(n)的时间复杂度</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-1021</title>
    <url>/2020/08/15/LeetCode-1021/</url>
    <content><![CDATA[<h1 id="1021删除最外层的括号"><a href="#1021删除最外层的括号" class="headerlink" title="1021删除最外层的括号"></a>1021删除最外层的括号</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p><img src="/2020/08/15/LeetCode-1021/content.PNG" alt="题目"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><pre><code>根据题目意思，只需要从左向右遍历字符串，然后将每个原语最外
层的()之间的字符串追加到结果上就行了，而原语的获取可以直接
根据temp数量来指示一个原语的结束。此处原语的判断可以用栈实现，而我所用的数字，只不过是栈的替代品，功能与栈一致。</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeOuterParentheses</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> l=<span class="number">0</span>,r=l,temp=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">char</span> chs[]=S.toCharArray();</span><br><span class="line">		StringBuilder res=<span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">		<span class="keyword">for</span>(;r&lt;chs.length;++r)&#123;</span><br><span class="line">			<span class="keyword">if</span>(chs[r]==<span class="string">'('</span>)&#123;</span><br><span class="line">				++temp;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				--temp;</span><br><span class="line">                <span class="keyword">if</span>(temp==<span class="number">0</span>)&#123;</span><br><span class="line">                    res.append(S.substring(l+<span class="number">1</span>, r));</span><br><span class="line">                    l=r+<span class="number">1</span>;</span><br><span class="line">			    &#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><pre><code>O(n)</code></pre><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><pre><code>O(n)</code></pre><h2 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h2><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeOuterParentheses</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">		StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:S.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">')'</span>)--count;</span><br><span class="line">            <span class="keyword">if</span>(count&gt;=<span class="number">1</span>)res.append(ch);</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">'('</span>)++count;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> res.toString();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><pre><code>按理来说&quot;if(ch==&apos;(&apos;)++count;&quot;应该放到&quot;if(count&gt;=1)res.append(ch);&quot;前，那为什么没有呢？这是为了避免原语以为
(开头的漏洞。</code></pre><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><pre><code>O(n)</code></pre><h3 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><pre><code>O(n)</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式为什么要双重检查null</title>
    <url>/2020/07/16/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5null/</url>
    <content><![CDATA[<h2 id="单例设计模式（懒汉式）为什么要进行双重检测锁定"><a href="#单例设计模式（懒汉式）为什么要进行双重检测锁定" class="headerlink" title="单例设计模式（懒汉式）为什么要进行双重检测锁定?"></a>单例设计模式（懒汉式）为什么要进行双重检测锁定?</h2><a id="more"></a>
<h3 id="懒汉式代码："><a href="#懒汉式代码：" class="headerlink" title="懒汉式代码："></a>懒汉式代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">  	<span class="comment">//静态变量，方便外部获取</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleTon singleTon;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//构造器私有化避免外部创建</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// TODOAuto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//对外提供一个获取实例的静态方法（因为外部无法创建实例）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(singleTon == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span>(SingleTon<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">             <span class="keyword">if</span>(singleTon == <span class="keyword">null</span>) &#123;</span><br><span class="line">                singleTon =<span class="keyword">new</span> SingleTon();</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> singleTon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设两个线程获取单例对象，即同时调用getInstance() 方法，此时由于singleTon&#x3D;&#x3D; null ，所以很明显，两个线程都可以通过第一重的 singleTon&#x3D;&#x3D; null ，进入第一重 if语句后，由于存在锁机制，所以会有一个线程进入 lock 语句并进入第二重 singleTon&#x3D;&#x3D; null，</span><br><span class="line"></span><br><span class="line">而另外的一个线程则会在lock 语句的外面等待。而当第一个线程执行完new  SingleTon（）语句后，便会退出锁定区域，此时，第二个线程便可以进入lock 语句块，此时，如果没有第二重singleTon&#x3D;&#x3D; null 的话，那么第二个线程直接调用 new  SingleTon（）语句，这样第二个线程也会创建一个SingleTon实例，这样也还是违背了单例模式的初衷的，所以这里必须要使用双重检查锁定。</span><br><span class="line"></span><br><span class="line">当然如果**去掉第一重singleton &#x3D;&#x3D; null ，程序还是可以在多线程下完好的运行的**，考虑在没有第一重singleton &#x3D;&#x3D; null 的情况下，当有两个线程同时两个线程获取单例对象，此时，由于lock 机制的存在，第一个线程会进入 lock 语句块，并且可以顺利执行 new SingleTon（），当第一个线程退出lock 语句块时， singleTon 这个静态变量已不为 null 了，所以当第二个线程进入 lock 时，还是会被第二重singleton &#x3D;&#x3D; null 挡在外面，而无法执行 new Singleton（），所以在没有第一重singleton &#x3D;&#x3D; null 的情况下，也是可以实现单例模式的。</span><br><span class="line"></span><br><span class="line">**那么为什么需要第一重 singleton &#x3D;&#x3D; null呢？**</span><br><span class="line"></span><br><span class="line">这里就涉及一个性能问题了，因为对于单例模式的话，newSingleTon（）只需要执行一次就 OK 了，而如果没有第一重singleTon &#x3D;&#x3D; null 的话，每一次有线程进入getInstance（）时，均会执行锁定操作来实现线程同步，这是非常耗费性能的，而如果我加上第一重singleTon &#x3D;&#x3D; null 的话，那么就只有在第一次，也就是singleTton &#x3D;&#x3D;null 成立时的情况下执行一次锁定以实现线程同步，而以后的话，便只要直接返回Singleton 实例就 OK 了而根本无需再进入 lock语句块了，这样就可以解决由线程同步带来的性能问题了。</span><br><span class="line"></span><br><span class="line">简而言之：第一重检测就是避免了多线程情况下，单例对象不为为null的子线程进行多余等待。</span><br></pre></td></tr></table></figure>
<h2 id="补充单例设计模式的饿汉式实现："><a href="#补充单例设计模式的饿汉式实现：" class="headerlink" title="补充单例设计模式的饿汉式实现："></a>补充单例设计模式的饿汉式实现：</h2><h2 id="优点：解决了懒汉式多线程访问中效率低下的问题。"><a href="#优点：解决了懒汉式多线程访问中效率低下的问题。" class="headerlink" title="优点：解决了懒汉式多线程访问中效率低下的问题。"></a>优点：解决了懒汉式多线程访问中效率低下的问题。</h2><h3 id="饿汉式代码："><a href="#饿汉式代码：" class="headerlink" title="饿汉式代码："></a>饿汉式代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">  	<span class="comment">//在类加载时被实例化，此操作是线程安全的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleTon singleTon=<span class="keyword">new</span> SingleTon();</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//构造器私有化避免外部创建</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//对外提供一个获取实例的静态方法（因为外部无法创建实例）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> singleTon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>后端</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal使用不当导致的执行器关闭异常问题</title>
    <url>/2020/06/30/ThreadLocal%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E7%9A%84%E6%89%A7%E8%A1%8C%E5%99%A8%E5%85%B3%E9%97%AD%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="MyBatis使用过程中产生执行器异常："><a href="#MyBatis使用过程中产生执行器异常：" class="headerlink" title="MyBatis使用过程中产生执行器异常："></a>MyBatis使用过程中产生执行器异常：</h2><blockquote>
<p>Cause:org.apache.ibatis.executor.ExecutorException: Executor was closed.</p>
</blockquote>
<a id="more"></a>
<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>在完成一个小的飞机航班查询的业务时，使用了MyBatis+Jsp+…等技术发现了，当多个请求同时进行的时候会发生ExecutorException。分析后得知。</p>
<h3 id="相关的类"><a href="#相关的类" class="headerlink" title="相关的类"></a><strong>相关的类</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisUtil</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory factory;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SqlSession&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;SqlSession&gt;();</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			InputStream is = Resources.getResourceAsStream(<span class="string">"myBatis.xml"</span>);</span><br><span class="line">			factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(is);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取SqlSession的方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">		SqlSession session = tl.get();</span><br><span class="line">		<span class="keyword">if</span>(session==<span class="keyword">null</span>)&#123;</span><br><span class="line">			tl.set(factory.openSession());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tl.get();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">		SqlSession session = tl.get();</span><br><span class="line">		<span class="keyword">if</span>(session!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			session.close();</span><br><span class="line">			tl.remove();</span><br><span class="line">		&#125;</span><br><span class="line">		tl.set(<span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@WebFilter</span>(<span class="string">"/*"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenSessionInView</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Logger.getLogger(<span class="keyword">this</span>.getClass()).info(<span class="string">"监听器被销毁"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse resp, FilterChain chain)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">		SqlSession session = MyBatisUtil.getSession();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			req.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">			chain.doFilter(req, resp);</span><br><span class="line">			session.commit();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			session.rollback();</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;			</span><br><span class="line"><span class="comment">//			**session.close();**</span></span><br><span class="line">			MyBatisUtil.closeSession();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig arg0)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">		Logger.getLogger(<span class="keyword">this</span>.getClass()).info(<span class="string">"初始化监听器"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决途径</strong>：</p>
<ul>
<li>翻阅各种资料、网文。<br>原因分析：<br>首先理解：Web服务器接收到请求时线程的情况？<br>服务器处理请求的几种模式：</li>
</ul>
<ol>
<li>阻塞式的单线程模型， 对于每一个请求直接处理，不开启线程，所以其他的请求必须等待前面的请求得到响应之后才能得到处理，如果请求没有处理完服务器就会阻塞。</li>
<li>非阻塞式的多线程模型，服务器对于每个请求开启一个线程去处理请求，当主线程返回时，继续处理下一个任务。实际上这种方式也是阻塞的，只不过确保了主线程一定不会阻塞，但是每个新开启的线程必须等待主线程处理完毕才能成为下一个主线程。</li>
<li>类似模式2，但是使用线程池的方式创建线程。一个线程完毕之后，归还给线程池供下一个请求使用。避免了模式2频繁创建线程的问题</li>
<li>基于Java NIO实现的服务器模型，这种方式只需要少量的线程就可以粗合理大量的请求。性能上远大于BIO（以上三种阻塞IO）。<br>而Tomcat默认采用的是模式2，所以当某个线程结束时并没有被销毁而是被归还给线程池了。<br>然后了解ThreadLocal的原理：<br>每个线程内部有个ThreadLocalMap变量（名为ThreadLocals），这个变量初始为null，用来存储当前线程的j局部变量，供线程中的不同节点使用。这个变量的key是ThreadLocal（线程容器类型：说是容器但实际上就是类似于指引的存在）类型的变量，value是ThreadLocal对应泛型的类型，那么当调用ThreadLocal变量的set方法时，如果当前线程已经有了ThreadLocalMap实例时那么就直接存储键值对到map中。如果没有，ThreadLocal就调用createMap方法创建实例，然后再在该方法内部存储键值对。以下是源码：<blockquote>
<p>public void set(T value){<br>  Thread t = Thread.currentThread();<br>  ThreadLocalMap map=getMap(t);<br>  if(map!=null){</p>
<pre><code>map.set(this,value);</code></pre><p>  }<br>  else{</p>
<pre><code>createMap(t,value);</code></pre><p>  }<br>}<br>void createMap(Thread t,T firstValue){<br>   t.threadLocals=new ThreadLocalMap(this,firstValue);</p>
<p>}<br>当调用get方法时根据当前的ThreadLocal对象，获取当前线程中存储的泛型对应的实例。<br>也就是说，ThreadLocal对象实际上只有一个。每一个线程内部都有一个ThreadLocalMap类型的变量ThreadLocals，用于数据的存储。而不同线程之间的变量共享则是通过唯一的ThreadLocal变量的。<br>理解了以上这些，然后我们分析如果只用session.close();方法，显然session引用的实例的执行器被关闭了，但是当前线程对应的session仍然存储在当前线程的ThreadLocalsMap中，并且ThreadLocal对象并没有被销毁，所以其他请求获得线程池中的对象时（这个线程如果被用过了），这个线程内部的ThreadLocalMap中仍然存储有上某次请求处理用的session对象，那么显然这个对象又被获取了一次，那么这个session肯定已经被关闭了，再去调用它的执行器执行就肯定会报Executor was closed.<br>解决办法：当session关闭时，同时将当前线程ThreadLocalMap中的变量设置为null，避免再被获取到。<br>即：如下代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">	SqlSession session = tl.get();</span><br><span class="line">	<span class="keyword">if</span>(session!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		session.close();</span><br><span class="line">		tl.remove();</span><br><span class="line">	&#125;</span><br><span class="line">	tl.set(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>后端</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-09</title>
    <url>/2020/08/15/%E5%89%91%E6%8C%87offer-09/</url>
    <content><![CDATA[<h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><pre><code>![](剑指offer-09/捕获.PNG)</code></pre><p>##思路<br>    创建两个栈分别负责存和取数据，当取数据的时候，将存数据的那个栈<br>    中的数据依次取出再全部放到负责取数据的那个栈，然后从取数据的那<br>    个栈的栈定取出数据即可。<br>##代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; in=<span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> Stack&lt;Integer&gt; out=<span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		in=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		out=<span class="keyword">new</span> Stack&lt;&gt;();	</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		in.push(value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(in.isEmpty()&amp;&amp;out.isEmpty())<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		<span class="comment">//以上一句进行了优化，避免了不必要的执行</span></span><br><span class="line">		<span class="keyword">if</span>(out.isEmpty())&#123;</span><br><span class="line">			<span class="keyword">while</span>(!in.isEmpty())&#123;</span><br><span class="line">				out.push(in.pop());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> out.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-1047</title>
    <url>/2020/08/17/LeetCode-1047/</url>
    <content><![CDATA[<h1 id="删除重复字符串中的所有相邻重复项"><a href="#删除重复字符串中的所有相邻重复项" class="headerlink" title="删除重复字符串中的所有相邻重复项"></a>删除重复字符串中的所有相邻重复项</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><pre><code>![](LeetCode-1047/a.PNG)</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><pre><code>使用双指针，队字符串进行一次重复删除，并记录是否发生了删除：
如果没有，返回原字符串；
如果有递归调用方法并返回值，递归结束于没有发生删除事件的那一次调用。</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicates</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[]chs=S.toCharArray();</span><br><span class="line">        StringBuilder res=<span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;chs.length-<span class="number">1</span>&amp;&amp;r&lt;chs.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chs[l]!=chs[r])&#123;</span><br><span class="line">                res.append(chs[l]);</span><br><span class="line">                l++;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l=r+<span class="number">1</span>;</span><br><span class="line">                r=r+<span class="number">2</span>;</span><br><span class="line">                flag=<span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l==chs.length-<span class="number">1</span>)&#123;</span><br><span class="line">            res.append(chs[l]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">return</span> S;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> removeDuplicates(res.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><pre><code>2n*(1-(1/2)^(logn))=O(n)</code></pre><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><pre><code>O(n)</code></pre><h2 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h2><h3 id="方法一：替换函数"><a href="#方法一：替换函数" class="headerlink" title="方法一：替换函数"></a>方法一：替换函数</h3><p>我们可以用字符串自带的替换函数，由于字符串仅包含小写字母，因此只有 26 种不同的重复项。</p>
<p>将 aa 到 zz 的 26 种重复项放入集合中；遍历这 26 种重复项，并用字符串的替换函数把重复</p>
<p>项替换成空串。</p>
<p>注意，在进行过一次替换之后，可能会出现新的重复项。例如对于字符串 abbaca，如果替换了重复项 bb，字符串会变为 aaca，出现了新的重复项 aa。因此，上面的过程需要背重复若干次，直到字符串在一整轮替换过程后保持不变（即长度不变）为止。<br>    <img src="/2020/08/17/LeetCode-1047/b.PNG" alt></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicates</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// generate 26 possible duplicates</span></span><br><span class="line">        HashSet&lt;String&gt; duplicates = <span class="keyword">new</span> HashSet();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> i = <span class="string">'a'</span>; i &lt;= <span class="string">'z'</span>; ++i) &#123;</span><br><span class="line">            sb.setLength(<span class="number">0</span>);</span><br><span class="line">            sb.append(i); sb.append(i);</span><br><span class="line">            duplicates.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> prevLength = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (prevLength != S.length()) &#123;</span><br><span class="line">            prevLength = S.length();</span><br><span class="line">            <span class="keyword">for</span> (String d : duplicates) S = S.replace(d, <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><pre><code>O(N^2)</code></pre><h3 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><pre><code>O(N)</code></pre><h3 id="方法二：栈"><a href="#方法二：栈" class="headerlink" title="方法二：栈"></a>方法二：栈</h3><p>我们可以用栈来维护没有重复项的字母序列：</p>
<p>若当前的字母和栈顶的字母相同，则弹出栈顶的字母；</p>
<p>若当前的字母和栈顶的字母不同，则放入当前的字母。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicates</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> sbLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> character : S.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sbLength != <span class="number">0</span> &amp;&amp; character == sb.charAt(sbLength - <span class="number">1</span>))</span><br><span class="line">                sb.deleteCharAt(sbLength-- - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(character);</span><br><span class="line">                sbLength++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><pre><code>O(N)</code></pre><h3 id="空间复杂度-2"><a href="#空间复杂度-2" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><pre><code>O(N)</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>化栈为队</title>
    <url>/2020/08/17/%E5%8C%96%E6%A0%88%E4%B8%BA%E9%98%9F/</url>
    <content><![CDATA[<h1 id="化队为栈"><a href="#化队为栈" class="headerlink" title="化队为栈"></a>化队为栈</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><pre><code>![化队为栈](化队为栈/a.PNG)</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><pre><code>首先，前提是任何操作均是合理且合法的，即不肯能队列中为空，还让出队。
创建两个栈，一个用来新增数据，另一个用来取出数据。当取出数据的时候，把用来存入数据的栈倒置给用来输出的栈，这样栈顶元素就是对应队
列的队首元素啦。</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt;in;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt;out;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        in=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        out=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        in.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(out.isEmpty())</span><br><span class="line">    		copyFormIn2Out(in, out);</span><br><span class="line">    	<span class="keyword">return</span> out.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(out.isEmpty())</span><br><span class="line">    		copyFormIn2Out(in, out);</span><br><span class="line">    	<span class="keyword">return</span> out.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> in.isEmpty()&amp;&amp;out.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFormIn2Out</span><span class="params">(Stack&lt;Integer&gt; in,Stack&lt;Integer&gt;out)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">while</span>(!in.isEmpty())&#123;</span><br><span class="line">			out.push(in.pop());</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-682</title>
    <url>/2020/08/17/LeetCode-682/</url>
    <content><![CDATA[<h1 id="棒球比赛"><a href="#棒球比赛" class="headerlink" title="棒球比赛"></a>棒球比赛</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><pre><code>![](LeetCode-682/a.PNG)</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><pre><code>直接根据指令操作栈即可。</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calPoints</span><span class="params">(String[] ops)</span> </span>&#123;</span><br><span class="line">            Stack&lt;Integer&gt; chs=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String ch:ops)&#123;</span><br><span class="line">            <span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"C"</span>:chs.pop();<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"D"</span>:chs.push(chs.peek()*<span class="number">2</span>);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"+"</span>:<span class="keyword">int</span> temp=chs.pop();<span class="keyword">int</span> ttemp=temp+chs.peek();chs.push(temp);chs.push(ttemp);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:chs.push(Integer.parseInt(ch));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!chs.isEmpty())&#123;</span><br><span class="line">        	res+=chs.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><pre><code>O(N)</code></pre><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><pre><code>O(N)</code></pre><h2 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><pre><code>用数组代替栈进行操作</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calPoints</span><span class="params">(String[] ops)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res[]=<span class="keyword">new</span> <span class="keyword">int</span>[ops.length];</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String s:ops)&#123;</span><br><span class="line">            <span class="keyword">switch</span>(s)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"C"</span>:i=i-<span class="number">2</span>;<span class="keyword">break</span>;<span class="comment">//-2是为了覆盖前一个数字</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">"D"</span>:res[i]=<span class="number">2</span>*res[i-<span class="number">1</span>];<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"+"</span>:res[i]=res[i-<span class="number">1</span>]+res[i-<span class="number">2</span>];<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:res[i]=Integer.parseInt(s);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            temp+=res[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><pre><code>O(N)</code></pre><h3 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><pre><code>O(N)</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-1441</title>
    <url>/2020/08/21/LeetCode-1441/</url>
    <content><![CDATA[<h1 id="用栈操作构建数组"><a href="#用栈操作构建数组" class="headerlink" title="用栈操作构建数组"></a>用栈操作构建数组</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><pre><code>![](LeetCode-1441/a.PNG)</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><pre><code>观察得知，当每次遍历的索引与taget数组的当前值不同时放入&quot;Push&quot;&amp;&quot;Pop&quot;，相同时放入&quot;Push&quot;到结果数组中。
因此只要遍历时判断以下即可。</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">buildArray</span><span class="params">(<span class="keyword">int</span>[] target, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n&amp;&amp;index&lt;target.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target[index]==i)&#123;</span><br><span class="line">                res.add(<span class="string">"Push"</span>);</span><br><span class="line">                **index++;**</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.add(<span class="string">"Push"</span>);</span><br><span class="line">                res.add(<span class="string">"Pop"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：此题要确保没有合适的index就不要改变target数组的当前索引指向的位置</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><pre><code>O(N) N为n的大小</code></pre><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><pre><code>O(N)</code></pre><h2 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h2><p>无</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-496</title>
    <url>/2020/08/17/LeetCode-496/</url>
    <content><![CDATA[<h1 id="下一个更大的元素I"><a href="#下一个更大的元素I" class="headerlink" title="下一个更大的元素I"></a>下一个更大的元素I</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><pre><code>![](LeetCode-496/a.PNG)</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><pre><code>两层循环，在nums2中找nums1中元素符合题意得元素</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        int [] res&#x3D;new int[nums1.length];</span><br><span class="line">        for(int i&#x3D;0;i&lt;nums1.length;i++)&#123;</span><br><span class="line">            int temp&#x3D;0;</span><br><span class="line">            for(int j&#x3D;0;j&lt;nums2.length;j++)&#123;</span><br><span class="line">                if(temp!&#x3D;0)&#123;</span><br><span class="line">                   break;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    if(nums2[j]&#x3D;&#x3D;nums1[i])&#123;</span><br><span class="line">                        temp&#x3D;-1;</span><br><span class="line">                        while(j&lt;nums2.length)&#123;</span><br><span class="line">                            if(nums2[j]&gt;nums1[i])&#123;</span><br><span class="line">                                temp&#x3D;nums2[j];</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            j++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i]&#x3D;temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><pre><code>O(NM)</code></pre><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><pre><code>O(N)</code></pre><h2 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h2><h3 id="方法一：单调栈"><a href="#方法一：单调栈" class="headerlink" title="方法一：单调栈"></a>方法一：单调栈</h3><p>利用单调栈将nums中元素得后一个大值均找出来放到HashMap中，然后遍历nums找到元素存入结果数组即可</p>
<p>我们可以忽略数组 nums1，先对将 nums2 中的每一个元素，求出其下一个更大的元素。随后对于将这些答案放入哈希映射（HashMap）中，再遍历数组 nums1，并直接找出答案。对于 nums2，我们可以使用单调栈来解决这个问题。</p>
<p>我们首先把第一个元素 nums2[1] 放入栈，随后对于第二个元素 nums2[2]，如果 nums2[2] &gt; nums2[1]，那么我们就找到了 nums2[1] 的下一个更大元素 nums2[2]，此时就可以把 nums2[1] 出栈并把 nums2[2] 入栈；如果 nums2[2] &lt;= nums2[1]，我们就仅把 nums2[2] 入栈。对于第三个元素 nums2[3]，此时栈中有若干个元素，那么所有比 nums2[3] 小的元素都找到了下一个更大元素（即 nums2[3]），因此可以出栈，在这之后，我们将 nums2[3] 入栈，以此类推。</p>
<p>可以发现，我们维护了一个单调栈，栈中的元素从栈顶到栈底是单调不降的。当我们遇到一个新的元素 nums2[i] 时，我们判断栈顶元素是否小于 nums2[i]，如果是，那么栈顶元素的下一个更大元素即为 nums2[i]，我们将栈顶元素出栈。重复这一操作，直到栈为空或者栈顶元素大于 nums2[i]。此时我们将 nums2[i] 入栈，保持栈的单调性，并对接下来的 nums2[i + 1], nums2[i + 2] … 执行同样的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">		<span class="keyword">int</span> res[] = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">        <span class="keyword">if</span>(nums1.length==<span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">		HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">		Stack&lt;Integer&gt; temp = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> a : nums2) &#123;</span><br><span class="line">			<span class="keyword">while</span> (!temp.isEmpty() &amp;&amp; a &gt; temp.peek()) &#123;</span><br><span class="line">				map.put(temp.pop(), a);</span><br><span class="line">			&#125;</span><br><span class="line">			temp.push(a);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">while</span>(!temp.isEmpty())map.put(temp.pop(),-<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums1.length;i++)&#123;</span><br><span class="line">			res[i]=map.get(nums1[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><pre><code>O(M+N)</code></pre><h3 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><pre><code>O(N)</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-155</title>
    <url>/2020/08/21/LeetCode-155/</url>
    <content><![CDATA[<h1 id="最小栈-栈的最小值-包含min函数的栈"><a href="#最小栈-栈的最小值-包含min函数的栈" class="headerlink" title="最小栈/栈的最小值/包含min函数的栈"></a>最小栈/栈的最小值/包含min函数的栈</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><pre><code>![](LeetCode-155/a.PNG)</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><pre><code>此题是栈设计类的题目，目的是设计一个栈，栈支持push，pop，还支持从当前栈中取出最小元素
的min操作，这个min操作是动态的（即入栈和出栈可能会改变min操作的结果）三种不同的思路。</code></pre><p><strong>第一种 双栈法</strong><br>    一个栈用来存放元素，另一个栈用来存放当前元素存入栈中的最小值：入栈时，一个直接入栈，另<br>    一个与当前的栈顶元素（始终保证当前栈顶元素是另一个栈种当前位置及以前位置元素的最小值）<br>    比较，若小于当前栈定元素就直接入栈，若大于栈定元素，就再放入栈顶元素；在执行出栈时直接<br>    移除两个栈顶元素即可，min操作的时候直接返回用来存放最小值元素的栈的栈顶元素即可。</p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; valStack=<span class="keyword">null</span>;</span><br><span class="line">    Stack&lt;Integer&gt; minStack=<span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        valStack=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        minStack=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        valStack.push(x);</span><br><span class="line">        <span class="keyword">if</span>(minStack.isEmpty())&#123;</span><br><span class="line">            minStack.push(x);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minStack.push(Math.min(minStack.peek(),x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        valStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> valStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第二种</strong><br><strong>自定义链表</strong>，有效的节省了Stack类型不必要的操作与空间。将两个栈化为一个链表，同时存放当前的目<br>前的最小值和当前值，还有就是节点插入的时候采用前插法，即将创建的最新的节点放到目前链表的头<br>节点位置处。</p>
<h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    ListNode head;</span><br><span class="line">    <span class="keyword">int</span> min  = Integer.MAX_VALUE;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//插入时可能会修改当前最小值</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt; min)</span><br><span class="line">            min = x;</span><br><span class="line">        ListNode t = <span class="keyword">new</span> ListNode(x , min);</span><br><span class="line">       ** t.next = head;**</span><br><span class="line">        **head = t;**</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>) min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="keyword">null</span>)min = head.min;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> head.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head.min;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> min;</span><br><span class="line">        ListNode next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> min)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.min = min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第三种</strong><br>使用一个栈，同时存放最小值和当前存入的值，注意此处与第二种不同的是，此处只会在，只会在最小<br>值发生改变的时候存入上一个最小值，以及修改当前的最小值，在pop操作时，如果取出的是当前的最小<br>值，那么就会连续的将它的前一个元素即上一个最下值赋值给min值，这样min就是始终就是目前栈中的最小值了。</p>
<h2 id="代码2-1"><a href="#代码2-1" class="headerlink" title="代码2"></a>代码2</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        min = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= min)&#123;</span><br><span class="line">            stack.push(min);</span><br><span class="line">            min = x;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.pop() == min)&#123;</span><br><span class="line">            min = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-1544</title>
    <url>/2020/08/23/LeetCode-1544/</url>
    <content><![CDATA[<h1 id="整理字符串"><a href="#整理字符串" class="headerlink" title="整理字符串"></a>整理字符串</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p><img src="/2020/08/23/LeetCode-1544/a.PNG" alt="题目"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><pre><code>模拟栈的功能,实现当栈顶元素是与当前元素同一个字母的大小写情况时删除栈顶元素即可功能即可</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">makeGood</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder ret = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch:s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ret.length() &gt; <span class="number">0</span> &amp;&amp; Character.toLowerCase(ret.charAt(ret.length()-<span class="number">1</span>)) == Character.toLowerCase(ch) &amp;&amp; ret.charAt(ret.length()-<span class="number">1</span>) != ch)             &#123; </span><br><span class="line">                ret.deleteCharAt(ret.length()-<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ret.append(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(N)，其中 NN 为字符串 s 的长度。我们要遍历字符串 s 的每一个字符，而对每个字符都只需要常数时间的操作。</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>O(N) 或O(1)，取决于使用语言的字符串类型是否是可修改的。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-844</title>
    <url>/2020/08/23/LeetCode-844/</url>
    <content><![CDATA[<h1 id="整理字符串"><a href="#整理字符串" class="headerlink" title="整理字符串"></a>整理字符串</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p><img src="/2020/08/23/LeetCode-844/a.PNG" alt="题目"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><pre><code>根据题目重构字符串，然后比较两者重构的结果是否相等。</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reBulidString(S).equals(reBulidString(T));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reBulidString</span><span class="params">(String S)</span></span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; ans = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: S.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">'#'</span>)</span><br><span class="line">                ans.push(c);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!ans.empty())</span><br><span class="line">                ans.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(M+N)，其中 M,N 是字符串 S 和 T 的长度。</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>O(M+N)</p>
<h2 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h2><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><pre><code>反向遍历两个字符串，找到合适的比较位置，然后比较字符相等与否即可，重复这些操作，知道比
较完所有的字符或者有一次比较的字符不相等即可。以上操作的难点就是查找合适的比较位置，可以
反向遍历字符串，根据#的数目越过不合题的字符位置。然后就可以比较合理的字符位置的字符是否
相等了。</code></pre><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = nextValidIndex(S, S.length());</span><br><span class="line">        <span class="keyword">int</span> j = nextValidIndex(T, T.length());</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S.charAt(i) != T.charAt(j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i = nextValidIndex(S, i);</span><br><span class="line">            j = nextValidIndex(T, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到下一个（从后向前）有效字符的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">nextValidIndex</span><span class="params">(String S, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bsCount = <span class="number">0</span>;<span class="comment">//用来判断是否已经越过所有目前读取到的的#数目对应的字符了</span></span><br><span class="line">        <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S.charAt(i) != <span class="string">'#'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bsCount == <span class="number">0</span>) &#123;<span class="comment">//为0表示已经越过#需要退格的字符了</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                bsCount--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bsCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(M+N)，其中 M,N 是字符串 S 和 T 的长度。</p>
<h3 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>O(1)</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>前端页面编码问题</title>
    <url>/2020/08/23/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="HTML中的字符设置辨析"><a href="#HTML中的字符设置辨析" class="headerlink" title="HTML中的字符设置辨析"></a>HTML中的字符设置辨析</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="在编写前端代码的时候，经常要在head元素内部，设置网页的编码方式，那么这种设置的与页面的本身的编码方式区别"><a href="#在编写前端代码的时候，经常要在head元素内部，设置网页的编码方式，那么这种设置的与页面的本身的编码方式区别" class="headerlink" title="在编写前端代码的时候，经常要在head元素内部，设置网页的编码方式，那么这种设置的与页面的本身的编码方式区别"></a>在编写前端代码的时候，经常要在head元素内部，设置网页的编码方式，那么这种设置的与页面的本身的编码方式区别</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--可以替换成 &lt;meta http-equiv=”Content-Type” content=”text/html; charset=utf-8″&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>xxxx<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        ......</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="辨析"><a href="#辨析" class="headerlink" title="辨析"></a>辨析</h2><p>实质上就是<strong>网页显示编码</strong>方式，与<strong>网页存储编码</strong>方式。meta元素设置的是网页的显示编码方式<br>，浏览器会根据设置的网页显示编码解析html页面。而<strong>网页存储编码</strong>，是html页面保存到本地时的<br>编码方式，是由编辑工具决定的，可以在编辑器中设置html文件的存储编码方式。</p>
<h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h2><p>如果网页的显示编码方式与存储编码方式不一致，会导致乱码问题，因此在使用的时候建议都设置为<br><strong>utf-8</strong>，这样即使网页中出现中文也不会乱码了。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>Node安装</title>
    <url>/2020/08/27/Node%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="Node与npm安装"><a href="#Node与npm安装" class="headerlink" title="Node与npm安装"></a>Node与npm安装</h1><a id="more"></a>

<h2 id="什么是Node？"><a href="#什么是Node？" class="headerlink" title="什么是Node？"></a>什么是Node？</h2><blockquote>
<p>Node也叫NodeJS,是一个构建于Chrome V8 引擎之上的一个JavaScript的运行时环境。它可以像浏览器一样解析和执行JavaScript代码。<br>也就是能够在服务器端运行 JavaScript 的开放源代码、跨平台 JavaScript 执行环境，避免了打开浏览器等工具。NodeJS运行通过<br>JavaScript和一系列模块来编写服务器端应用和与网络有关的应用。</p>
</blockquote>
<h2 id="什么是npm"><a href="#什么是npm" class="headerlink" title="什么是npm?"></a>什么是npm?</h2><p>npm是Node自带的一个<strong>软件包管理器</strong>(在电脑中自动安装、配制、卸载和升级软件包的工具组合)，是一个命令行工具。能够使程序员更加方<br>便的发布和获取Node.js类库和源代码，简化了类库安装、升级、卸载的过程。</p>
<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p><strong>安装环境</strong>:<strong>Windows10系统,64位机</strong>,以前安装过，不过文件目录破损了。其他环境类似。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>到官网下载安装程序<br><br><img src="/2020/08/27/Node%E5%AE%89%E8%A3%85/a.png" alt></li>
<li>双击下载好的Windows程序安装包,选择安装目录，建议放在D盘<br><br><img src="/2020/08/27/Node%E5%AE%89%E8%A3%85/b.png" alt><br><img src="/2020/08/27/Node%E5%AE%89%E8%A3%85/c.PNG" alt></li>
<li>建议安装全部的模块（包含了npm模块），默认就是的，继续点击next，然后进入安装进度页面，最终跳出如下页面<br><br><img src="/2020/08/27/Node%E5%AE%89%E8%A3%85/d.PNG" alt></li>
<li>点击Finish，进入命令行窗口(Win+R)查看版本信息以确定是否安装成功。<br><br><img src="/2020/08/27/Node%E5%AE%89%E8%A3%85/e.png" alt><br>如图，出现版本信息就已经安装成功了<br><br><img src="/2020/08/27/Node%E5%AE%89%E8%A3%85/f.png" alt><br>由于默认的本地仓库是在C盘的，不建议存放在C盘，因此可将文件转移到D盘，切忌直接CV<br><img src="/2020/08/27/Node%E5%AE%89%E8%A3%85/g.png" alt><br>执行如下两条命令<blockquote>
<p>npm config set prefix “D:node\localRegister\node_global”<br>npm config set cache “D:\node\localRegister\node_cache”</p>
</blockquote>
</li>
</ol>
<p>进入命令行查看是否修改成功:<br><img src="/2020/08/27/Node%E5%AE%89%E8%A3%85/h.png" alt></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序中使用antv入门</title>
    <url>/2020/10/31/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8antv%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="在小程序中使用可视化数据"><a href="#在小程序中使用可视化数据" class="headerlink" title="在小程序中使用可视化数据"></a>在小程序中使用可视化数据</h2><a id="more"></a>

<p>开发背景：安装好node、npm</p>
<ol>
<li><p>首先新建一个小程序项目</p>
</li>
<li><p>在IDE中关闭新建的小程序项目，然后进入到项目根目录下，打开CMD进入小程序根目录</p>
</li>
<li><p>使用npm init生成一个pakeage.json文件</p>
<p><img src="/2020/10/31/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8antv%E5%85%A5%E9%97%A8/image-20201031213555591.png" alt="image-20201031213555591"></p>
</li>
<li><p>安装可视化数据的包: npm install @antv/wx-f2 –save</p>
<p><img src="/2020/10/31/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8antv%E5%85%A5%E9%97%A8/image-20201031213712502.png" alt="image-20201031213712502"></p>
</li>
<li><p>使用IDE进入项目中，点击：</p>
<p><img src="/2020/10/31/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8antv%E5%85%A5%E9%97%A8/image-20201031213843240.png" alt="image-20201031213843240"></p>
<p>第三步其实不需要的，但是我环境并没有添加语法转化的代码</p>
<p>6.工具-&gt;npm 构建</p>
<p><img src="/2020/10/31/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8antv%E5%85%A5%E9%97%A8/image-20201031214157069.png" alt="image-20201031214157069"></p>
<p>这一步可能会出错，如果有错，直接将弹框中错误信息复制，百度，然后就能知道解决方法了</p>
<p>6.到此，环境全部配置成功，下面我们开始测试代码的编写（以index页面为测试页面）</p>
<ol>
<li><p>进入index.json中配置用如下内容覆盖原内容</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"usingComponents"</span>: &#123;</span><br><span class="line">    <span class="attr">"f2"</span>: <span class="string">"@antv/wx-f2"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>再到index.wxss中用如下代码覆盖原内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.f2-chart &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 500rpx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>到index.wxml中用如下代码覆盖原内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">  &lt;f2 class&#x3D;&quot;f2-chart&quot; onInit&#x3D;&quot;&#123;&#123;onInitChart&#125;&#125;&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后到index.js中用如下代码覆盖原内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    onInitChart(F2, config) &#123;</span><br><span class="line">     <span class="comment">//此处编写绘制图形的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>绘制图形的代码可以直接从官网下载，注意复制过来的代码不可以直接再小程序中使用，毕竟环境变了。首先将复制过来的代码放在如上代码注释处，然后需要适当的做修改，这个适当度取决于小程序对你所选择的antv视图的支持程度。不过有些基础的改变总是一定的，下面我列出恒定的改变，然后补充不常见的改变方式。</p>
<p><img src="/2020/10/31/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8antv%E5%85%A5%E9%97%A8/image-20201031221313349.png" alt="image-20201031221313349"></p>
<p>以下为官网原代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">'https://gw.alipayobjects.com/os/antfincdn/Jpuku6k%24q%24/linear-pan.json'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> chart = <span class="keyword">new</span> F2.Chart(&#123;</span><br><span class="line">      id: <span class="string">'container'</span>,</span><br><span class="line">      pixelRatio: <span class="built_in">window</span>.devicePixelRatio</span><br><span class="line">    &#125;);</span><br><span class="line">    chart.source(data, &#123;</span><br><span class="line">      release: &#123;</span><br><span class="line">        min: <span class="number">1990</span>,</span><br><span class="line">        max: <span class="number">2010</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    chart.tooltip(&#123;</span><br><span class="line">      showCrosshairs: <span class="literal">true</span>,</span><br><span class="line">      showItemMarker: <span class="literal">false</span>,</span><br><span class="line">      background: &#123;</span><br><span class="line">        radius: <span class="number">2</span>,</span><br><span class="line">        fill: <span class="string">'#1890FF'</span>,</span><br><span class="line">        padding: [ <span class="number">3</span>, <span class="number">5</span> ]</span><br><span class="line">      &#125;,</span><br><span class="line">      nameStyle: &#123;</span><br><span class="line">        fill: <span class="string">'#fff'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      onShow: <span class="function"><span class="keyword">function</span> <span class="title">onShow</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> items = ev.items;</span><br><span class="line">        items[<span class="number">0</span>].name = items[<span class="number">0</span>].title;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    chart.line().position(<span class="string">'release*count'</span>);</span><br><span class="line">    chart.point().position(<span class="string">'release*count'</span>).style(&#123;</span><br><span class="line">      lineWidth: <span class="number">1</span>,</span><br><span class="line">      stroke: <span class="string">'#fff'</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    chart.interaction(<span class="string">'pan'</span>);</span><br><span class="line">    <span class="comment">// 定义进度条</span></span><br><span class="line">    chart.scrollBar(&#123;</span><br><span class="line">      mode: <span class="string">'x'</span>,</span><br><span class="line">      xStyle: &#123;</span><br><span class="line">        offsetY: <span class="number">-5</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制 tag</span></span><br><span class="line">    chart.guide().tag(&#123;</span><br><span class="line">      position: [ <span class="number">1969</span>, <span class="number">1344</span> ],</span><br><span class="line">      withPoint: <span class="literal">false</span>,</span><br><span class="line">      content: <span class="string">'1,344'</span>,</span><br><span class="line">      limitInPlot: <span class="literal">true</span>,</span><br><span class="line">      offsetX: <span class="number">5</span>,</span><br><span class="line">      direct: <span class="string">'cr'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    chart.render();</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>



</li>
</ol>
<pre><code>1. 恒定的修改

   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">const</span> chart = <span class="keyword">new</span> F2.Chart(&#123;</span><br><span class="line">      id: <span class="string">'container'</span>,</span><br><span class="line">      pixelRatio: <span class="built_in">window</span>.devicePixelRatio</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//将对象参数换为：config,这个config就是onInitChart传递过来的参数，底层会将.wxss文件中height,以及width等属性封装到config中，所以在.wxss文件一定要配置</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">.f2-chart &#123;</span></span><br><span class="line"><span class="comment">  width: 100%;</span></span><br><span class="line"><span class="comment">  height: 500rpx;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> chart = <span class="keyword">new</span> F2.Chart(config);</span><br></pre></td></tr></table></figure>

   下面是一些特定的改变，只针对当前使用的视图有效：

   首先小程序中不支持fetch必须将js代码中使用了fetch的地方使用wx.request({...})替换

   以下是替换的的方式，删除如下代码：

   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">'https://gw.alipayobjects.com/os/antfincdn/Jpuku6k%24q%24/linear-pan.json'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//这个作用域内的代码保留其他的删除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

   既然把请求函数删除那么就必须使用小程序中的代码进行替代代码如下：

   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wx.request(&#123;</span><br><span class="line">          url: <span class="string">'https://gw.alipayobjects.com/os/antfincdn/Jpuku6k%24q%24/linear-pan.json'</span>,</span><br><span class="line">          method:<span class="string">'GET'</span>,</span><br><span class="line">          success(res)&#123;</span><br><span class="line">          <span class="comment">//此处装填刚才保留的代码</span></span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

   完整的修改代码如下：

   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    onInitChart(F2, config) &#123;</span><br><span class="line">      wx.request(&#123;</span><br><span class="line">          url: <span class="string">'https://gw.alipayobjects.com/os/antfincdn/Jpuku6k%24q%24/linear-pan.json'</span>,</span><br><span class="line">          method:<span class="string">'GET'</span>,</span><br><span class="line">          success(res)&#123;</span><br><span class="line">          <span class="keyword">let</span> data = res.data;</span><br><span class="line">          <span class="keyword">const</span> chart = <span class="keyword">new</span> F2.Chart(config);</span><br><span class="line">          chart.source(data, &#123;</span><br><span class="line">            release: &#123;</span><br><span class="line">              min: <span class="number">1990</span>,</span><br><span class="line">              max: <span class="number">2010</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          chart.tooltip(&#123;</span><br><span class="line">            showCrosshairs: <span class="literal">true</span>,</span><br><span class="line">            showItemMarker: <span class="literal">false</span>,</span><br><span class="line">            background: &#123;</span><br><span class="line">              radius: <span class="number">2</span>,</span><br><span class="line">              fill: <span class="string">'#1890FF'</span>,</span><br><span class="line">              padding: [<span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            nameStyle: &#123;</span><br><span class="line">              fill: <span class="string">'#fff'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            onShow: <span class="function"><span class="keyword">function</span> <span class="title">onShow</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">const</span> items = ev.items;</span><br><span class="line">              items[<span class="number">0</span>].name = items[<span class="number">0</span>].title;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          chart.line().position(<span class="string">'release*count'</span>);</span><br><span class="line">          chart.point().position(<span class="string">'release*count'</span>).style(&#123;</span><br><span class="line">            lineWidth: <span class="number">1</span>,</span><br><span class="line">            stroke: <span class="string">'#fff'</span></span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">          chart.interaction(<span class="string">'pan'</span>);</span><br><span class="line">          <span class="comment">// 定义进度条，此处我取消了进度条，因为，官方提供的打包过的文件中并没有包含这个函数</span></span><br><span class="line">          </span><br><span class="line"></span><br><span class="line">          <span class="comment">// 绘制 tag</span></span><br><span class="line">          chart.guide().tag(&#123;</span><br><span class="line">            position: [<span class="number">1969</span>, <span class="number">1344</span>],</span><br><span class="line">            withPoint: <span class="literal">false</span>,</span><br><span class="line">            content: <span class="string">'1,344'</span>,</span><br><span class="line">            limitInPlot: <span class="literal">true</span>,</span><br><span class="line">            offsetX: <span class="number">5</span>,</span><br><span class="line">            direct: <span class="string">'cr'</span></span><br><span class="line">          &#125;);</span><br><span class="line">          chart.render();            </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

   然后保存运行,效果如下：

   ![image-20201031222817923](./小程序中使用antv入门/image-20201031222817923.png)</code></pre><p>   如果小程序控制台显示不是安全的域名，可以将域名添加到可访问列表中。关于antv的API的使用可以参考官网以及官网下面的评论区。</p>
<p>   自此大功告成。</p>
<p>   此处，是无法滑动的，更进一步的修改可以参考这篇博客：</p>
<p>   <a href="https://blog.csdn.net/X_W123/article/details/99644256">CSDN</a></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>antv</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的前序遍历</title>
    <url>/2020/12/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>##二叉树的前序遍历</p>
<p><img src="/2020/12/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%5Ca.PNG" alt></p>
<h2 id="递归（我使用）"><a href="#递归（我使用）" class="headerlink" title="递归（我使用）"></a>递归（我使用）</h2><p>这题就是简单的二叉树先序遍历算法的使用。先序遍历为DLR顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> List&lt;Integer&gt; results= <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	        DLR(root);</span><br><span class="line">	        <span class="keyword">return</span> results;</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DLR</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			results.add(root.val);</span><br><span class="line">			DLR(root.left);</span><br><span class="line">			DLR(root.right);			</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n):因为每个节点都被访问了一次，所以执行次数的量级为O(n)</p>
<p>空间复杂度：O(n):因为<strong>递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度</strong> ，所以空间复杂度最小为O($log_2  n$),最坏的情况下，树变成了链表，空间复杂度为O($n$)</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>利用栈将递归转化为迭代，</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>将递归转化为迭代</title>
    <url>/2020/12/01/%E5%B0%86%E9%80%92%E5%BD%92%E8%BD%AC%E5%8C%96%E4%B8%BA%E8%BF%AD%E4%BB%A3/</url>
    <content><![CDATA[<h4 id="将递归算法转化为迭代算法"><a href="#将递归算法转化为迭代算法" class="headerlink" title="将递归算法转化为迭代算法"></a>将递归算法转化为迭代算法</h4><a id="more"></a>

<p>易混概念辨析：</p>
<p>递归:</p>
<p>​    ==递归就是自己调用自己，自己内部包含自己的使用，以求减小问题的规模==</p>
<p>迭代：</p>
<p>​    ==迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果，也就是说这一次处理结果会对下一次造成影响，最终找到最合适的结果​==</p>
<p>遍历：==依次==对集合中的每个元素==做一次访问==</p>
<p>循环：==与迭代操作相近，循环每次执行的是相同的操作，最终无论结果如何，都要停止循环。==</p>
<p>从理论上讲，只要允许使用栈，所有的递归程序都可以转化成迭代。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>算法整合</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle密码过期</title>
    <url>/2020/11/27/Oracle%E5%AF%86%E7%A0%81%E8%BF%87%E6%9C%9F/</url>
    <content><![CDATA[<a id="more"></a>

<p><img src="/2020/11/27/Oracle%E5%AF%86%E7%A0%81%E8%BF%87%E6%9C%9F/Oracle%E5%AF%86%E7%A0%81%E8%BF%87%E6%9C%9F%5COracle.PNG" alt="Oracle"></p>
<p>原因：Oracle11G创建用户时缺省密码过期限制是180天（即6个月），如果超过180天用户密码未做修改则该用户无法登录</p>
<p>解决：</p>
<p>使用PL/SQL进入操作界面</p>
<p>执行SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> profile <span class="keyword">default</span> <span class="keyword">limit</span> password_life_time   <span class="keyword">unlimited</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<p>查看是否成功将密码的期限设置无限：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> dba_profiles <span class="keyword">where</span> profile=<span class="string">'DEFAULT'</span> <span class="keyword">and</span> resource_name=<span class="string">'PASSWORD_LIFE_TIME'</span>;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/2020/11/27/Oracle%E5%AF%86%E7%A0%81%E8%BF%87%E6%9C%9F/Oracle%E5%AF%86%E7%A0%81%E8%BF%87%E6%9C%9F%5Cimage-20201030001317871.png" alt="image-20201030001317871"></p>
<p>注意要修改用户密码：不然用户无法正常连接数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> scott indentified <span class="keyword">by</span> xxxxxxx(xxxxxxxx为你的密码);</span><br></pre></td></tr></table></figure>

<p>如果用户在修改密码后处于被锁定状态，执行以下SQL语句取消锁定状态</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> scott <span class="keyword">account</span> <span class="keyword">unlock</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
        <category>DBMS</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>use of logger(based on log4j)</title>
    <url>/2020/12/23/use-of-logger-based-on-log4j/</url>
    <content><![CDATA[<p>内容：日志的目的以及使用（以log4j为例）</p>
<a id="more"></a>

<p><strong>为什么需要日志？</strong></p>
<p>​    为了监控程序的运行，传统的输出到控制台的方式不易于观察和管理系统的运行。</p>
<p><strong>日志框架有哪些？</strong></p>
<p>​    log4J、slf4j、…</p>
<p>l<strong>og4j介绍</strong></p>
<p>​    Log4j 应该说是 Java 领域资格最老，应用最广的日志工具。</p>
<p>​    Log4j 是高度可配置的，并可通过在运行时的外部文件配置,也支持通过提供的API进行配置，不过一般还是建议</p>
<p>​    在配置文件中进行配置，方便查看。    它根据记录的优先级别，并提供机制，以指示记录信息到许多的目的赌</p>
<p>   地，诸如：数据库，文件，控制台，UNIX     系统日志等。</p>
<p><strong>Log4j 中有三个主要组成部分</strong></p>
<ul>
<li><strong>loggers</strong> - 负责捕获记录信息。</li>
<li><strong>appenders</strong> - 负责发布日志信息，以不同的首选目的地。</li>
<li><strong>layouts</strong> - 负责格式化不同风格的日志信息。</li>
</ul>
<p><strong>log4j配置文件详解</strong></p>
<p>​    配置文件可以分为三个内容：日志记录级别、负责日志输出的组件、日志输出的格式</p>
<p>​    日志记录的级别有：FATAL、ERROR、WARN、INFO、DEBUG（严重程度由高到低）</p>
<p>​    负责日志输出的组件：</p>
<table>
<thead>
<tr>
<th><img src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" alt="img">org.apache.log4j.?</th>
<th>任务</th>
</tr>
</thead>
<tbody><tr>
<td>ConsoleAppender</td>
<td>控制台附加器</td>
</tr>
<tr>
<td>FileAppender</td>
<td>文件追加器</td>
</tr>
<tr>
<td>DailyRollingFileAppender</td>
<td>每天产生一个日志文件的追加器</td>
</tr>
<tr>
<td>RollingFileAppender</td>
<td>文件大小有上限的追加器</td>
</tr>
<tr>
<td>WriterAppender</td>
<td>流日志信息的追加器（即日志信息为一个输出流）</td>
</tr>
</tbody></table>
<p>​    以上的这些组件还要额外的设置自己的有关配置，比如输出的目的文件的路径啊、…、输出的布局</p>
<p>（</p>
<p>​    org.apache.log4j.HTMLLayout（HTML表格形式布局）、      </p>
<p>​    org.apache.log4j.PatternLayout（灵活地指定布局模式，一般为这个因为想要使用自定义的输出格式）、     </p>
<p>​     org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）、    </p>
<p>​    org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）)</p>
<p>）</p>
<p>组件的日志信息的输出格式：</p>
<table>
<thead>
<tr>
<th>格式</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>%m</td>
<td align="left">代码中指定的内容</td>
</tr>
<tr>
<td>%p</td>
<td align="left">日志信息的优先级</td>
</tr>
<tr>
<td>%r</td>
<td align="left">输出到目前为止系统的工作时间（ms）</td>
</tr>
<tr>
<td>%c</td>
<td align="left">日志信息所在的类的全路径名</td>
</tr>
<tr>
<td>%t</td>
<td align="left">日志信息产生的线程的名字</td>
</tr>
<tr>
<td>%n</td>
<td align="left">换行符（/r/n与/n分别是Windows和Linux平台的换行符）</td>
</tr>
<tr>
<td>%d</td>
<td align="left">日志产生的时间，默认为2004-05-03T17:30:08+08:00这种ISO8601格式的，也可以自定义格式如:%d{yyyy MM dd HH:mm:ss , SSS}</td>
</tr>
<tr>
<td>%l</td>
<td align="left">日志时间发生的位置(类名、方法名、行数、线程名…)</td>
</tr>
<tr>
<td>其他格式可以到网络上查找</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>log4J使用样例</strong></p>
<p>​    1.导入log4-xxx.jar包</p>
<p>​    2.在src下新建log4j.properties配置文件并填写有关日志的信息</p>
<p>​    3.关于配置信息由如下介绍</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">### 设置日志输出的级别（即虽然所有地方都有日志记录的代码，但是必须选定一些特定的记录记录）###</span><br><span class="line">log4j.rootLogger = 日志输出级别y,x1(目的追加器名),x2,x3...</span><br><span class="line">## 为单独的某个包中的所有类设置日志记录的级别(log4j.logger.xx.xx.xx=级别)</span><br><span class="line">log4j.logger.com.eju.mapper=DEBUG</span><br><span class="line">## 为单独的某个类设置日志记录的级别(log4j.logger.xx.xx=级别)</span><br><span class="line">log4j.logger.com.eju.mapper.PersonMapper=DEBUG</span><br><span class="line"> ### 级别低于y的日志信息不会被输出###</span><br><span class="line">### 输出信息到控制台###</span><br><span class="line">log4j.appender.x1 = org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.x1.Target = System.out</span><br><span class="line">log4j.appender.x1.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.x1.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n</span><br><span class="line"> </span><br><span class="line">### 输出DEBUG 级别以上的日志到E://logs/error.log</span><br><span class="line">## 使用一天一次的追加器进行记录</span><br><span class="line">log4j.appender.x2 = org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">## 输出文件的路径</span><br><span class="line">log4j.appender.x2.File = E://logs/log.log</span><br><span class="line">## 使用追加方式</span><br><span class="line">log4j.appender.x2.Append = true</span><br><span class="line">## 输出的最低级别为DEBUG</span><br><span class="line">log4j.appender.x2.Threshold = DEBUG</span><br><span class="line">## 输出的布局为自定义布局模式</span><br><span class="line">log4j.appender.x2.layout = org.apache.log4j.PatternLayout</span><br><span class="line">## 自定义布局的格式串</span><br><span class="line">log4j.appender.x2.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span><br><span class="line"> </span><br><span class="line">### 输出ERROR 级别以上的日志到E://logs/error.log</span><br><span class="line">log4j.appender.z3 = org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">log4j.appender.x3.File =E://error.log </span><br><span class="line">log4j.appender.x3.Append = true</span><br><span class="line">log4j.appender.x3.Threshold = ERROR </span><br><span class="line">log4j.appender.x3.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.x3.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span><br></pre></td></tr></table></figure>

<p>然后在一般的java项目中可以如下使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Logger logger = Logger.getLogger(Test<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		 <span class="comment">// 记录debug级别的信息  </span></span><br><span class="line">        logger.debug(<span class="string">"This is debug message."</span>);  </span><br><span class="line">        <span class="comment">// 记录info级别的信息  </span></span><br><span class="line">        logger.info(<span class="string">"This is info message."</span>);  </span><br><span class="line">        <span class="comment">// 记录error级别的信息  </span></span><br><span class="line">        logger.error(<span class="string">"This is error message."</span>);  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以上代码之后会发现日志文件不仅输出到控制台上了还输出到文件中了。</p>
<p><img src="/2020/12/23/use-of-logger-based-on-log4j/image-20201223222418544.png" alt="image-20201223222418544"></p>
<p><img src="/2020/12/23/use-of-logger-based-on-log4j/image-20201223222635560.png" alt="image-20201223222635560"></p>
]]></content>
      <categories>
        <category>后端</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>log4j</tag>
      </tags>
  </entry>
  <entry>
    <title>位图算法</title>
    <url>/2022/04/26/%E4%BD%8D%E5%9B%BE%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>​    位图(BitMap)，简单的来说就是bit类型的数组，但是各种计算机语言中并没有提供这种数据类型的结构，因此我们可以利用数字的数组来构成位图.  比如我们想要128位的位图，那么在Java中定义一个long [] bits = new long[2];就可以了.  而在Redis中有专门的数据结构(bitmap)并提供了相应的操作方法.  </p>
<a id="more"></a>

<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>位运算包括</p>
<table>
<thead>
<tr>
<th>运算</th>
<th>符号</th>
<th>举例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>与</td>
<td>&amp;</td>
<td>1101     &amp; 0110</td>
<td>0100</td>
</tr>
<tr>
<td>或</td>
<td>|</td>
<td>1101     | 0110</td>
<td>1111</td>
</tr>
<tr>
<td>非</td>
<td>!</td>
<td>!0101</td>
<td>1010</td>
</tr>
<tr>
<td>异或</td>
<td>^</td>
<td>1101     ^ 0110</td>
<td>1011</td>
</tr>
<tr>
<td>取反</td>
<td>~</td>
<td>1101</td>
<td>0010</td>
</tr>
<tr>
<td>左移</td>
<td>&lt;&lt;</td>
<td>1101 &lt;&lt; 1</td>
<td>11010</td>
</tr>
<tr>
<td>带符号右移（高位补充符号位）</td>
<td>&gt;&gt;</td>
<td>1101 &gt;&gt; 1</td>
<td>1110</td>
</tr>
<tr>
<td>不带符号右移（即高位补0）</td>
<td>&gt;&gt;&gt;</td>
<td>1101&gt;&gt;&gt;1</td>
<td>0110</td>
</tr>
</tbody></table>
<h2 id="位图-车座抢票"><a href="#位图-车座抢票" class="headerlink" title="位图-车座抢票"></a>位图-车座抢票</h2><p>​    12306抢票，一列火车车起点站到终点站要经过许多站点，每个站点都会有人上车、有人下车，火车一共200个座位，如何计算才能保证火车从起点到终点搭载的总人数相对较多呢？（<strong>为什么不是最多，因为你无法控制乘客的选择</strong>）</p>
<blockquote>
<p>理解：一个座位，如果被人占用了从站点i到站点j，那么被占用期间经过的站点，就不允许其他人购买该座的车票.  即针对一个座位，乘坐的不同人，除了邻接站点，经过的站点不能有相交的部分.  我们无法控制某个座位不出售给某个人，但是可以算出出某个站点没有被占用的座位从而在合适的站点地段出售该座位的车票，如果被抢到了</p>
</blockquote>
<p><a href="https://blog.csdn.net/lizc_lizc/article/details/108418564?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165196789116781483740607%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165196789116781483740607&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-108418564-null-null.142^v9^pc_search_result_cache,157^v4^control&utm_term=%E4%BD%8D%E5%9B%BE%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187">🔗参考文献</a></p>
<p>下面来思考一个理想化的模型：</p>
<p>​    从北京到广州，经过[北京、信阳、武汉、岳阳、长沙、广州]六个站点，火车一共8个座位.  那么如何处理才能让火车乘坐的人数相对较多呢？</p>
<p>解决思路</p>
<p>定义5个位图(位图a,b,c,d,e)，每个位图用一个byte变量表示，分别代表从北京到信阳、信阳到武汉、武汉到岳阳、岳阳到长沙、长沙到广州的车座占用情况，那么从<strong>北京到岳阳的空闲车座</strong>就可以<strong>通过位图a与位图b、位图c做或运算得出</strong>的，（因为只有这三个位图都没有人坐的位置才算可以出售给北京站点乘客的座位）.  例如如图，三个位图的占用情况.  </p>
<p><img src="/2022/04/26/%E4%BD%8D%E5%9B%BE%E7%AE%97%E6%B3%95/1651982796548.png" alt="1651982796548"></p>
<p>那么三个位图取或之后的空（实际用0表示）即座位2 4 6 8，就是北京到岳阳站点还未售卖的车座，那么北京站点处的人就可以购买了.  </p>
<p><img src="/2022/04/26/%E4%BD%8D%E5%9B%BE%E7%AE%97%E6%B3%95/1651982808968.png" alt="1651982808968"></p>
<p>结论：统计一个站点处可以售卖的车座，就是这个站点到目标站点中经过的所有站点的位图取或之后的0的位置.  </p>
<h2 id="位图-统计日活跃用户人数"><a href="#位图-统计日活跃用户人数" class="headerlink" title="位图-统计日活跃用户人数"></a>位图-统计日活跃用户人数</h2><p>问题：假设网站有一亿的用户，这些用户的id是连续的从1到1亿，如何统计这个网站的日活用户.  日活用户指当日登录该系统的用户.  </p>
<p>​    原本思路：直接定义一个全局变量，有一人登录系统就加1，然后实时地显示到展示界面中.  可以添加一个标识，标识今日已经登录过了，但是维护起来比较麻烦（要考虑用户重复登录问题、这个标识添加在数据库表中会不会导致整个项目的代码重构）.  </p>
<p>​    sql方式的思路：sql查询出登录表格（用户id,登录时间date）中日活跃人数，sql语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">----建表语句</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> login;</span><br><span class="line"><span class="comment"># date(只记录日期) time(只记录时间) datetime 记录日期时间 timestamp 记录时间戳</span></span><br><span class="line"><span class="comment"># 这里用datetime，因为不可能一天只登录一次.  </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> login(</span><br><span class="line"> <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">5</span>) <span class="keyword">comment</span> <span class="string">'用户id'</span>,</span><br><span class="line"> login_date datetime <span class="keyword">comment</span> <span class="string">'登录时间'</span>,</span><br><span class="line"> PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>,login_date)</span><br><span class="line"> );</span><br><span class="line"> <span class="comment">----插值语句 分别在5.4 5.3 5.2这几天插入语句</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">'2022-5-4 12:00:00'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">'2022-5-4 13:00:00'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">'2022-5-4 14:00:00'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">'2022-5-4 1:00:00'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="string">'2022-5-4 13:00:00'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">'2022-5-4 12:00:00'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">'2022-5-3 12:00:00'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">'2022-5-3 13:00:00'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">'2022-5-3 14:00:00'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">'2022-5-3 1:00:00'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="string">'2022-5-2 13:00:00'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">'2022-5-2 12:00:00'</span>);</span><br><span class="line"><span class="comment">--- 查询5.4这天日活</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">DATE</span>(login_date) <span class="keyword">AS</span> <span class="string">'date'</span>, <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">id</span>) <span class="keyword">AS</span> <span class="string">'count'</span> </span><br><span class="line"><span class="keyword">FROM</span> login</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">DATE</span>(login_date)</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">date</span>=<span class="built_in">DATE</span>(<span class="string">'2022-05-04'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/26/%E4%BD%8D%E5%9B%BE%E7%AE%97%E6%B3%95/1651982839135.png" alt="1651982839135"></p>
<p>这种方式涉及的数据量较大，如果网站比较活跃，数据量扩增非常迅速，且单单为了这个功能就建一张表太过奢侈.  </p>
<p>位图算法的思路</p>
<p>​    每天维护一个1亿bit的数组如day20220504[100000000]，这个数组的第i位置的bit为1代表今日id为i的用户登录了.  这样活跃人数的计算就成了统计改数组中1个个数.  </p>
<blockquote>
<p>数组大小为12m（1亿bit=12500000byte=12208k=12m），还算可以接受.  但是如果你用byte型的数组来表示改存储结构，那么大小就是96m.</p>
</blockquote>
<p>我们可以用redis实现这种思路因为Redis 的bitmap是自动扩展的，如果设置了某个偏移位置超出了现有的内容范围，位数组就会自动扩充.   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 当一个用户id为i的用户登录时，直接将位图对应下标处的位设置为1</span><br><span class="line">set day20220504 i 1</span><br><span class="line">## 统计日活的命令</span><br><span class="line">BITCOUNT day20220504</span><br></pre></td></tr></table></figure>

<h2 id="位图-海量数据查重以及去重"><a href="#位图-海量数据查重以及去重" class="headerlink" title="位图-海量数据查重以及去重"></a>位图-海量数据查重以及去重</h2><p>​    假设有40亿的数据，要求你从中找出重复出现的数据.  思路与日活用户思路类似，使用一个40亿位的BitSet，然后遍历这40亿数据，按照一定规则将每个数字设置到到位图中，当我们设置一个位置处的位图的值时，如果能取出其值，说明它已经出现过了，此算法时间复杂度为O(n).  空间占用大概480m.  </p>
<p>去重也是同样的思路，对于要去重的所有数据将其输入到位图数组中，最终将所有的数据对应的下标处的位都置为了1，这些位所代表的数据就是去重之后的值.  </p>
<p>缺点：</p>
<ul>
<li>如果数据量不大，但是最大值特别大，会导致位空间利用率极低</li>
<li>由于每个位数只能记录0或者1状态，所以位图实现的功能有限只能进行去重和查重操作，无法统计每个数据出现的次数.  </li>
</ul>
<h2 id="位图-权限控制"><a href="#位图-权限控制" class="headerlink" title="位图-权限控制"></a>位图-权限控制</h2><p>权限管理分为两个部分</p>
<p>操作权限：菜单权限（不同用户看到的菜单是不同的）、按钮权限</p>
<p>数据权限：不同的用户看到的数据是不同的.  </p>
<p>权限控制的方式</p>
<p>用户-角色-权限</p>
<p>通过建立角色表，建立角色-权限表记录不同角色的权限，建立角色-用户表格，然后在用户登录时通过查询用户-角色表，查询出用户对应的角色信息，然后通过角色权限表，查询出该用户所具备的权限.  </p>
<p>通过为每个用户维护一个权限字段，通过字段数据的每个bit位是否为1表示该用户是否具有某权限.  </p>
<p>思路</p>
<p>我们可以在用户表添加一个字段，即权限字段，这个字段的数值的每一个bit位代表一个权限，如果该bit位处为1就表明该用户具有该bit位代表的权限.  当一个用户登录时，查询该用户的权限字段，然后与不同的权限只做与运算，看看是否具备该权限，与的结果为非0数表示具有该权限.  </p>
<p>tip: 这种仅仅通过内存中的数值计算求出权限，显然比通过查表，查出用户权限快的多.  </p>
<p>例题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我们使用</span><br><span class="line">    <span class="number">1</span>&lt;&lt;<span class="number">0</span> 表示具备用户增加权限  <span class="number">1</span>&lt;&lt;<span class="number">1</span> 表示具备用户删除权限</span><br><span class="line">    <span class="number">1</span>&lt;&lt;<span class="number">2</span> 表示具备用户修改权限  <span class="number">1</span>&lt;&lt;<span class="number">3</span> 表示具备用户查询权限</span><br><span class="line">    ...  </span><br><span class="line">    <span class="number">1</span>&lt;&lt;<span class="number">31</span> 表示具有系统重启权限</span><br><span class="line">一共<span class="number">32</span>种权限，那么，一个用户所具备的权限就可以用一个<span class="keyword">int</span>型的数字表示.  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> ADD_USER = <span class="number">1</span>&lt;&lt;<span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> DELETE_USER = <span class="number">1</span>&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> MODIFY_USER = <span class="number">1</span>&lt;&lt;<span class="number">2</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> QUERY_USER = <span class="number">1</span>&lt;&lt;<span class="number">3</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> REBOOT_SYSTEM = <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> 超级管理员 = ADD_USER|DELETE_USER|MODIFY_USER|QUERY_USER|REBOOT_SYSTEM;</span><br><span class="line">    <span class="comment">// 10000000000000000000000000001111</span></span><br><span class="line">    System.out.println(Integer.toBinaryString(超级管理员));</span><br><span class="line">    <span class="keyword">int</span> 游客 = QUERY_USER;</span><br><span class="line">    <span class="comment">// 1000</span></span><br><span class="line">    System.out.println(Integer.toBinaryString(游客));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="位图-限流"><a href="#位图-限流" class="headerlink" title="位图-限流"></a>位图-限流</h2><h3 id="为什么需要对-API-进行限流？"><a href="#为什么需要对-API-进行限流？" class="headerlink" title="为什么需要对 API 进行限流？"></a>为什么需要对 API 进行限流？</h3><p>服务器作为一种资源，其CPU与内存总是有限的，那么服务器的无论是对外的 API 接口还是对内的RPC接口，单位时间内能够处理的请求数，也是有限的，即使有负载均衡策略来使得请求可以被合理的分配到各个服务器上，缓解请求压力，但是也架不住狂轰滥炸，一旦超过了某个限制，即使负载均衡策略再好，每个服务器的压力也非常大，最终也会导致整个服务的不可用.  </p>
<h3 id="限流手段有哪些？"><a href="#限流手段有哪些？" class="headerlink" title="限流手段有哪些？"></a>限流手段有哪些？</h3><h4 id="计数器算法"><a href="#计数器算法" class="headerlink" title="计数器算法"></a>计数器算法</h4><p>设计每秒允许通过的请求数（即 qps ,每秒请求数），一秒内请求数超过这个值的请求直接丢弃。然后在一秒末，重新进行计数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计数器 限流算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterLimiter</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 上次窗口的结束时间，也就是本次窗口的开始时间</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> lasterWindowEnd;</span><br><span class="line">  <span class="comment">// 本次窗口的大小</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> interval;</span><br><span class="line">  <span class="comment">// 本次窗口的请求阈值</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> requestPerwindow;</span><br><span class="line">  <span class="comment">// 本次窗口内的计数器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CounterLimiter</span><span class="params">(LocalDateTime lasterWindowEnd, <span class="keyword">int</span> second, <span class="keyword">int</span> requestPerwindow )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lasterWindowEnd = lasterWindowEnd.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">    <span class="keyword">this</span>.interval = second;</span><br><span class="line">    <span class="keyword">this</span>.counter = requestPerwindow;</span><br><span class="line">    <span class="keyword">this</span>.requestPerwindow = requestPerwindow;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认是 时间窗口为 5s ,窗口可以处理100个请求。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CounterLimiter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(LocalDateTime.now(), <span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 控制线程单独进入</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在一秒内就计数，并判断是否接受该请求</span></span><br><span class="line">      <span class="keyword">long</span> now = LocalDateTime.now().toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">      <span class="keyword">if</span> ((now - lasterWindowEnd) &gt;= interval) &#123;</span><br><span class="line">        <span class="keyword">this</span>.counter = <span class="keyword">this</span>.requestPerwindow;</span><br><span class="line">        <span class="keyword">this</span>.lasterWindowEnd = now;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.counter &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.counter--;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<p>使用Jmeter进行测试(10秒钟1000次)，测试自己编写的如下接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (Counter.checker()) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"login success"</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"login failure"</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/26/%E4%BD%8D%E5%9B%BE%E7%AE%97%E6%B3%95/1657022614778.png" alt="10秒钟匀速发送15个请求"></p>
<p>缺点：如果有人，故意在上一秒的开始不发送任何请求，然后再上一秒末尾发送最大的请求数，然后在下一秒开始发送最大的请求数，那么就相当于服务器在一秒时间内要处理，两倍的最大请求数，可能会导致系统崩溃。即如下图</p>
<p><img src="/2022/04/26/%E4%BD%8D%E5%9B%BE%E7%AE%97%E6%B3%95/1656518345627.png" alt="1656518345627"></p>
<h4 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h4><p>由于计数器算法的窗口在时间间隔内是不会变动的，这种粗犷的窗口计算方法，会导致如上图的那种一个窗口内出现两倍最大请求数要处理的情况，那么我们就需要对窗口进行进一步的细分，最好使得它处理完一个时间片段后就开始一个新的窗口，这样，如上图那种的情况就会被算法处理到了，那么那一秒内的一半请求就会被抛弃掉，不会导致服务器崩溃。但是这种算法极限情况下也会出现上一种情况的。</p>
<ol>
<li><p>合法性验证：</p>
</li>
<li><p>容器：</p>
<p>Tomcat：</p>
<p>Nginx：</p>
</li>
<li><p>算法</p>
</li>
</ol>
<p>​                                                                                                                                                                                                                                                         </p>
<p>​                                                                                                                                                                                                                                </p>
<p><a href="https://blog.51cto.com/u_2837193/4904056">待续：常用限流算法</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/376564740">https://zhuanlan.zhihu.com/p/376564740</a></p>
<p><a href="https://mp.weixin.qq.com/s/Kmy1gy0z7gaopKMmAsAd3g">https://mp.weixin.qq.com/s/Kmy1gy0z7gaopKMmAsAd3g</a></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>位图算法</tag>
      </tags>
  </entry>
  <entry>
    <title>github访问速度太慢的来龙去脉以及解决之道</title>
    <url>/2022/05/04/github%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6%E5%A4%AA%E6%85%A2%E7%9A%84%E6%9D%A5%E9%BE%99%E5%8E%BB%E8%84%89%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E4%B9%8B%E9%81%93/</url>
    <content><![CDATA[<h2 id="国内访问GitHub速度为什么慢？"><a href="#国内访问GitHub速度为什么慢？" class="headerlink" title="国内访问GitHub速度为什么慢？"></a>国内访问GitHub速度为什么慢？</h2><a id="more"></a>

<blockquote>
<p>CDN :<strong>内容分发网络</strong>，一个网站往往包含大量的静态资源（如图片、视频等），这些静态资源如果都是通过一个主服务器访问，会严重影响主服务器的处理请求的能力，因此有必要将这些静态资源抽离出来，放到各地的次服务器的存储中，然后对于一些静态或者其他资源的请求交由这些服务器接受处理，主服务器只负责核心功能请求的处理。这便是<strong>基于内容的分布式发送网络</strong>。</p>
<p>CDN的实现要素</p>
<ol>
<li><p>分布式存储：即将内容存储到分散的服务器中</p>
<ol start="2">
<li>通过DNS解析或者主服务器重定向实现请求的负载均衡 ：即对于一个资源的请求要能够让合适的服务器处理该请求</li>
<li>全局负载均衡管理和内容管理：即要对全局的服务器这些负载均衡节点的状态、以及全局的资源进行管理</li>
</ol>
</li>
</ol>
<p>CDN的整体结构：</p>
<ol>
<li>中心节点：负责全局服务器的状态检测以及请求分配即<strong>负载均衡</strong>以及内容管理，即实现上面的2 3 功能</li>
<li>边缘节点：主要负责处理分配来的请求，以及维护数据。</li>
</ol>
<p>CDN的工作流程：</p>
<blockquote>
<p> 常见的域名解析类型有两种：</p>
<p>​    A记录类型：A记录类型将<strong>一个或者多个域名直接映射到一个ip地址</strong></p>
<p>​    CNAME记录类型：CNAME类型将<strong>一个或者多个域名映射到一个域名</strong></p>
<p>​    NS记录类型、TXT记录类型</p>
</blockquote>
<p>​    用户在浏览器输入框中输入域名，现到浏览器缓存中找，没有再到hosts文件中查询，hosts文件中没有映射后，则先请求本地的DNS服务器解析，如果处理不了则向更高级的DNS服务器请求，最终解析出一个负载均衡服务器的主机域名（这里为什么不是Ip地址呢？因为这种服务器常常配置的DNS解析记录一般CNAME记录类型），而后浏览器得到这个解析后的域名后，再去请求解析这个域名对应的<strong>智能复杂均衡系统</strong>的地址得出ip后并将解析任务交给它，智能复杂均衡系统会其根据各地的服务器状态以及各种因素考虑（即考虑复杂均衡）之后返回一个响应速度最快的ip给用户，最终用户得到就在DNS缓存中记录下该ip和域名之间的映射关系，后期的请求都会发送给该ip服务器处理。</p>
</blockquote>
<p>​    理解了以上这些就能知道国内的Github访问速度为什么慢了？</p>
<p>​    因为GitHub对应的CND域名遭到了<a href="https://baike.baidu.com/item/DNS%E6%B1%A1%E6%9F%93/8620359">DNS污染</a>导致域名解析过程变得异常麻烦甚至失败，最终导致CDN网络不能正常工作，只能访问节点较远的主服务器导致速度较慢。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>​    通过自定义hosts文件来设置github的域名解析</p>
<ol>
<li>到<a href="https://www.ipaddress.com/">这里</a>上查询github.global.ssl.Fastly.net与github.com最佳的ip地址</li>
<li>到hosts文件中配置直接解析</li>
</ol>
<p><img src="/2022/05/04/github%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6%E5%A4%AA%E6%85%A2%E7%9A%84%E6%9D%A5%E9%BE%99%E5%8E%BB%E8%84%89%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E4%B9%8B%E9%81%93/1651982758936.png" alt="1651982758936"></p>
<ol start="3">
<li>cmd中执行如下命令来刷新dns缓存</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ipconfig</span> /flushdns</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>String StringBuilder StringBuffer的异同</title>
    <url>/2022/05/10/String-StringBuilder-StringBuffer%E7%9A%84%E5%BC%82%E5%90%8C/</url>
    <content><![CDATA[<p>​    <a id="more"></a></p>
<h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><ol>
<li>都是 final 类, 都不允许被继承;</li>
</ol>
<h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><ul>
<li>String 声明的是不可变的对象，每次+或者subString等操作都会生成新的String对象，然后将原有的引用指向新的String 对象 ， Stringbuilder、StringBuffer 可以在原有的基础上进行操作，所以在经常修改字符串的内容情况下，尽量使用Stringbuilder、StringBuffer</li>
<li>string初始化可以用new也可以直接赋值，后两者只能new</li>
<li>String重写了Object的equals以及hashcode方法，后两者没有，因此后两者的同类对象的对比只涉及对象地址的对比</li>
<li>string类型的+操作本质上是创建一个该变量的StringBuffer变量的操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"Hello"</span>;</span><br><span class="line">str+=<span class="string">"World!"</span>;</span><br><span class="line">本质上为</span><br><span class="line">String str = <span class="string">"Hello"</span>;</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuilder(str);</span><br><span class="line">sb.append(<span class="string">"World!"</span>);</span><br><span class="line">str=sb.toString();</span><br></pre></td></tr></table></figure>

<ul>
<li>StringBuffer的方法添加了synchronized，StringBuilder没有，因此StringBuffer是线程安全的，但是性能低。</li>
</ul>
<p>总结：字符串变量在单线程环境下建议StringBuilder、字符串变量在多线程环境下建议StringBuffer、字符串变量改动的次数极少用String。</p>
]]></content>
      <categories>
        <category>后端</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么开发中不要使用System.out.println</title>
    <url>/2022/05/08/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E5%8F%91%E4%B8%AD%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8System-out-println/</url>
    <content><![CDATA[<p>​    <a id="more"></a></p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">boolean</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    一旦某个线程System.out.println打印信息，由于System.out对象全局唯一，因此这块同步代码块就把其他线程准备System.out的线程阻塞了，所有相关线程暂停工作，系统性能急剧下降。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><pre><code>在日常开发或者调试的过程中，尽量使用log4j2或者logback这些异步的方法，进行日志的统一收集，禁止使用System.out.println。项目上线前也要进行全局搜索，防止误提交有System.out.println的代码。 </code></pre><h3 id="为什么使用ToStringBuilder而并不是直接使用-拼接字符串输出？"><a href="#为什么使用ToStringBuilder而并不是直接使用-拼接字符串输出？" class="headerlink" title="为什么使用ToStringBuilder而并不是直接使用+拼接字符串输出？"></a>为什么使用ToStringBuilder而并不是直接使用+拼接字符串输出？</h3><p>​    项目中一般都需要打印日志信息，每个对象输出到日志都使用+拼接字符串，一个+拼接操作就会生成一个String对象，那么大量的创建只使用一次的String对象，会导致内存飙升，CPU狂跑。而ToStringBuilder可以避免使用字符串拼接。从而节省资源。</p>
<h3 id="ToStringBuilder使用"><a href="#ToStringBuilder使用" class="headerlink" title="ToStringBuilder使用"></a>ToStringBuilder使用</h3><ol>
<li>引入依赖</li>
</ol>
<p><img src="/2022/05/08/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E5%8F%91%E4%B8%AD%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8System-out-println/image.png" alt="img"></p>
<ol>
<li>直接将一个对象转化成String,可以通过ToStringStyle（抽象类）来指明生成的字符串的格式，它的局部内部类继承了它，并实现了它的方法。</li>
</ol>
<p>tip: 如果属性（无论是自己的还是父类的）使用了transient或者static修饰，则不可以打印出来，即打印时会忽略该属性信息。</p>
<p>DEFAULT_STYLE，这也是默认的输出格式</p>
<blockquote>
<p>org.brains.Person@10f87f48[gender=MALE,id=1,name=zsjslfajfkl]</p>
</blockquote>
<p>MULTI_LINE_STYLE，属性换行显示</p>
<blockquote>
<p>org.brains.Person@10f87f48[</p>
<p>  gender=MALE</p>
<p>  id=1</p>
<p>  name=zsjslfajfkl</p>
<p>]</p>
</blockquote>
<p>NO_FIELD_NAMES_STYLE，只显示属性值，不显示属性名</p>
<blockquote>
<p>org.brains.Person@10f87f48[MALE,1,zsjslfajfkl]</p>
</blockquote>
<p>SIMPLE_STYLE，仅显示属性名</p>
<blockquote>
<p>MALE,1,zsjslfajfkl</p>
</blockquote>
<p>SHORT_PREFIX_STYLE，对象名称的简写</p>
<blockquote>
<p>Person[gender=MALE,id=1,name=zsjslfajfkl]</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> GenderType gender;</span><br><span class="line"></span><br><span class="line">  Person(Integer id, String name, GenderType gender) &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.gender = gender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> GenderType &#123;</span><br><span class="line">  MALE(<span class="number">1</span>, <span class="string">"MALE"</span>), FEMALE(<span class="number">0</span>, <span class="string">"FEMALE"</span>);</span><br><span class="line">  <span class="keyword">private</span> Integer code;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  GenderType(Integer code, String name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.code = code;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">测试代码</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(ToStringBuilder.reflectionToString(<span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"zsjslfajfkl"</span>, GenderType.MALE)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">----output</span><br><span class="line">org.xx.Person@<span class="number">10f</span>87f48[gender=MALE,id=<span class="number">1</span>,name=zsjslfajfkl]</span><br></pre></td></tr></table></figure>

<h3 id="ToStringBuilder底层原理"><a href="#ToStringBuilder底层原理" class="headerlink" title="ToStringBuilder底层原理"></a>ToStringBuilder底层原理</h3><p>​    基于反射机制，通过AccessibleObject.setAccessible方法来获取对对象私有属性的权限，因此可以绕过安全检查机制，可能会有安全问题。通过反射获取值后按照一定的Style组成一个Buffer，最后输出string。</p>
]]></content>
      <categories>
        <category>后端</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>ToStringBuilder</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域问题</title>
    <url>/2022/05/09/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>​        <a id="more"></a></p>
<h2 id="1-浏览器的同源策略"><a href="#1-浏览器的同源策略" class="headerlink" title="1 浏览器的同源策略"></a>1 浏览器的同源策略</h2><p>​    在一个脚本发送请求得到的响应结果，如果不是请求当前脚本执行环境所在的域名（协议、域名、端口有一个不一样就不是同域），那么给请求的响应结果会被浏览器拦截，不交给该脚本处理。这就是同源策略。这种策略能够有效的防止一个恶意开发者通过自己用户登录自己的网站时，底层默默执行代码，发送请求获取其他网站例如某些特殊网站（假如同时用户刚好登录了政府内网）获取到机关人员的cookie信息，然后使用携带该请求去请求政府服务器（这也就是传说中的CSRF攻击，跨站请求伪造攻击），浏览器会拦截这些恶意请求的响应数据不让它得到响应，从而保证了数据的安全性。</p>
<h2 id="2-什么是跨域"><a href="#2-什么是跨域" class="headerlink" title="2 什么是跨域"></a>2 什么是跨域</h2><p>简而言之，就是如果你所在的网站是<a href="https://example.com">https://example.com</a> ： 那么如果你向<a href="https://m.example.com">https://m.example.com</a> 或者<a href="https://example.com:3000">https://example.com:3000</a> 或者 <a href="http://example.com">http://example.com</a> 发送的请求都属于跨域请求。跨域所报的异常情况如下：</p>
<p><img src="/2022/05/09/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image-1652110357572.png" alt="img"></p>
<h2 id="3-什么时候出现跨域问题？"><a href="#3-什么时候出现跨域问题？" class="headerlink" title="3 什么时候出现跨域问题？"></a>3 什么时候出现跨域问题？</h2><p>跨域不一定就有跨域问题， 仅在 </p>
<p>1）调用 Ajax 时：调用 Ajax 发送请求的页面 所在的域，和被请求页面所在的域不一致<br>2）当操作 ifream 内引入的元素时：ifream 所属页面的域，和 ifream 引入页面的域不一致</p>
<h2 id="4-如何解决跨域问题？"><a href="#4-如何解决跨域问题？" class="headerlink" title="4 如何解决跨域问题？"></a>4 如何解决跨域问题？</h2><p><strong>Jsonp</strong> </p>
<p>原理如图</p>
<p>​            &lt;script src=”xx”&gt;、&lt;image src=”xx”&gt;、&lt;link src=”xx”/&gt;这些包含src属性的标签可以加载跨域的资源。</p>
<p><img src="/2022/05/09/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image-1652110357527.png" alt="img"></p>
<p>这是最早的解决方案，利用script标签可以跨域的原理实现。 使用js动态地创建<script>标签，但是请求响应数据会立马被浏览器当作javascript语句去执行，但这种数据格式并不符合其js语法。由于浏览器得到数据后会立即试图解析执行这些数据，所以如果服务器响应的数据外围包裹一层函数调用，如图，{..}是返回的数据，callback()是包裹的函数，而恰巧，浏览器环境刚好全局变量有这种函数，那么{…}就会作为数据被传递进入callback函数。</p>
<p><img src="%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/image.png" alt="img"></p>
<p>缺点：只能发起GET请求</p>
<p><strong>反向代理</strong></p>
<p>由于只有浏览器有同源策略，所以可以配置一个同域名下的nginx反向代理(理解为分发代理，帮你进行请求转发)服务器，接受所在域名的请求，然后转发请求到其他的域名指向的服务器，nginx接收到其他域名服务器的处理结果再返回给请求发出者。这样就规避了跨域。</p>
<p>缺点：需要在nginx进行额外配置，比较麻烦</p>
<p>实现</p>
<p>ngnix配置如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    # 监听9009端口，http://localhost:9009就是反向代理服务器的域名，即浏览器可见的服务器地址</span><br><span class="line">    listen 9009;</span><br><span class="line">    # 域名是localhost</span><br><span class="line">    server_name localhost;</span><br><span class="line">    # 凡是localhost:9009/api这个样子的，都转发到真正的服务端地址localhost:9888上去</span><br><span class="line">    location ^~ /api &#123;</span><br><span class="line">        proxy_pass 最终的目标域名;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CORS（最常用）</strong></p>
<p>​        通过 W3C 规范 的“ 跨域资源共享（Cross-Origin Resource Sharing ，CORS）”，通过服务器端在 HTTP 头中的设置，可以使浏览器能够获取不同来源的资源。，<strong>来限制服务器所能接受的来源、请求的方法、可携带的头</strong>等。当浏览器发现发现的ajax请求是简单请求(见下)时，会在请求头中携带一个字段：Origin指出当前请求属于哪个域（协议+域名+端口），服务器得到请求后进行处理，如果确定接受则在响应头中加上如 Access-Control-Allow-Origin、Access-Control-Request-Method、Access-Control-Request-Headers 等属性，浏览器判断Access-Control-Allow-Origin中是否包含Origin的值，含有就把响应返回给请求者。简而言之，就是浏览器得到了一个服务器的白名单，根据这个白名单决定是否把响应数据交给调用者。</p>
<blockquote>
<p>Access-Control-Allow-Origin: 跨域请求的目标域名 如<a href="http://manage.enjoyment.com">http://manage.enjoyment.com</a></p>
<p>Access-Control-Allow-Credentials: 是否允许携带cookie如true</p>
<p>Content-Type: text/html; charset=utf-8。</p>
</blockquote>
<p>​        如果是复杂请求，不携带Origin，浏览器在正式请求之前增加一次http查询请求，也叫<strong>预检</strong> ，看看当前网页所在域名是否在服务器允许范围之内，浏览器得到肯定答复后才会发出正式的XMLHttpRequest请求。后续在服务器的答复的有效期内，该域名的请求都当作简单请求处理。</p>
<blockquote>
<p>简单请求的条件：</p>
<p>（1) 请求方法是以下三种方法之一：</p>
<ul>
<li>HEAD|GET|POST</li>
</ul>
<p>（2）HTTP的头信息不超出以下几种字段：</p>
<ul>
<li><p>Accept</p>
</li>
<li><p>Accept-Language</p>
</li>
<li><p>Content-Language</p>
</li>
<li><p>Last-Event-ID</p>
</li>
<li><p>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</p>
</li>
</ul>
<p>除此之外的请求都属于复杂请求，</p>
</blockquote>
<p>实现CORS</p>
<ul>
<li>浏览器端都有浏览器自动完成，浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</li>
<li>服务端可通过拦截器统一实现，SpringMVC已经帮我们写好了CORS的跨域过滤器：CorsFilter ,内部已经实现了所讲的判定逻辑，会用即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalCorsConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.添加CORS配置信息</span></span><br><span class="line">            CorsConfiguration config = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">            <span class="comment">//1) 允许的域,不要写*，否则cookie就无法使用了</span></span><br><span class="line">            config.addAllowedOrigin(<span class="string">"http://pronhub.heiheihei.com"</span>);</span><br><span class="line">            <span class="comment">//2) 是否发送Cookie信息</span></span><br><span class="line">            config.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//3) 允许的请求方式</span></span><br><span class="line">            config.addAllowedMethod(<span class="string">"OPTIONS"</span>);</span><br><span class="line">            config.addAllowedMethod(<span class="string">"HEAD"</span>);</span><br><span class="line">            config.addAllowedMethod(<span class="string">"GET"</span>);</span><br><span class="line">            config.addAllowedMethod(<span class="string">"PUT"</span>);</span><br><span class="line">            config.addAllowedMethod(<span class="string">"POST"</span>);</span><br><span class="line">            config.addAllowedMethod(<span class="string">"DELETE"</span>);</span><br><span class="line">            config.addAllowedMethod(<span class="string">"PATCH"</span>);</span><br><span class="line">            <span class="comment">// 4）允许的头信息</span></span><br><span class="line">            config.addAllowedHeader(<span class="string">"*"</span>);</span><br><span class="line">        <span class="comment">//2.添加映射路径，我们拦截一切请求</span></span><br><span class="line">            UrlBasedCorsConfigurationSource configSource = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">            configSource.registerCorsConfiguration(<span class="string">"/**"</span>, config);</span><br><span class="line">        <span class="comment">//3.返回新的CorsFilter.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(configSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    规范化的跨域请求解决方案，安全可靠。</p>
<p>​                优势： </p>
<ul>
<li><ul>
<li><ul>
<li>在服务端进行控制是否允许跨域，可自定义规则</li>
<li>支持各种请求方式</li>
</ul>
</li>
<li><p>缺点： </p>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>会产生额外的请求</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>降域</strong></p>
<p>child1.parent.com与parent.com 虽然这两个域名不同域，可以通过document.domain=”parent.com”设置让浏览器认为他们都属于一个域。这就是降域。</p>
<p>…其他方法</p>
</script></p>]]></content>
      <categories>
        <category>前端</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>Arrays.sort、PriorityQueue、自定义Comparator的比较</title>
    <url>/2022/05/10/Arrays-sort%E3%80%81PriorityQueue%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89Comparator%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p>​    <a id="more"></a></p>
<h2 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h2><p>​     Comparable是个排序接口，若一个类实现了该接口 ，那么该类的数组和列表就可以通过<strong>Collections.sort</strong>或<strong>Arrays.sort</strong>进行自动排序。 其中Collections.sort(List)对List进行排序，Arrays.sort([])对数组进行排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">如果返回<span class="keyword">this</span>-o，那么相当于从小到大排序。</span><br><span class="line">如果返回o-<span class="keyword">this</span>，那么相当于从大到小排序。</span><br></pre></td></tr></table></figure>

<p>由于基本类型对应的包装类一般都实现了Comarable接口，这些基本类型数组都可以使用Arrays,sort()…等方法。</p>
<p>但是这个排序方式需要改变代码结构，侵入较大。</p>
<h2 id="Comparator比较器"><a href="#Comparator比较器" class="headerlink" title="Comparator比较器"></a>Comparator比较器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建比较器对象cp</span></span><br><span class="line">        Comparator&lt;Person2&gt; cp = <span class="keyword">new</span> Comparator&lt;Person2&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span><span class="comment">//重写compare方法，使按照照学号升序</span></span><br><span class="line">            <span class="comment">//o2.getXuehao()-o1.getXuehao()：按照学号降序</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person2 o1, Person2 o2)</span> </span>&#123;<span class="comment">//自定义排序规则</span></span><br><span class="line">                <span class="keyword">return</span> o1.getXuehao()-o2.getXuehao();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="comment">//对数组persons安装比较器cp进行排序</span></span><br><span class="line">        Arrays.sort(persons, cp);</span><br></pre></td></tr></table></figure>

<h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>​    常常使用自定义比较器，来构造优先级队列（大小根堆）对象，这个优先级队列底层是树形结构，通过自定义Comparator比较器来比较进行元素的对比。</p>
<p>在优先队列中，如果定义的比较器是按照某值X升序(return o1.X-o2.X)排序的，那么优先队列中元素的位置会按照X的值所构建的小根堆来放置；</p>
<p>在优先队列中，如果定义的比较器是按照某值X降序(return o2.X-o1.X)排序的，那么优先队列中元素的位置会按照X的值所构建的大根堆来放置；</p>
]]></content>
      <categories>
        <category>后端</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>shelll习题记录</title>
    <url>/2022/05/28/shelll%E4%B9%A0%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>​        <a id="more"></a></p>
<h1 id="wc、tail等指令的使用"><a href="#wc、tail等指令的使用" class="headerlink" title="wc、tail等指令的使用"></a>wc、tail等指令的使用</h1><h2 id="WC-指令"><a href="#WC-指令" class="headerlink" title="WC 指令"></a>WC 指令</h2><p><code>wc</code>是shell提供的用来查看文件的行数等信息的简陋工具。 <code>wc</code>可以计算文件的Byte数、字数或是列数。  若<strong>不指定文件名称，或是所给予的文件名为“-”</strong>，则wc指令会从标准输入设备读取数据，即<code>wc -l</code>这种执行语句，会等待用户输入后才会开始统计用户的输入信息。 </p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看某个文件的行数 单词数 字节数</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wc nowcoder.txt </span></span><br><span class="line"> 10  31 149 nowcoder.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 统计文件的字节数（一个中文字符占两个字节）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wc -c nowcoder.txt </span></span><br><span class="line">149 nowcoder.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 统计文件的字符数</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wc -m nowcoder.txt</span></span><br><span class="line">145 nowcoder.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 统计文件的行数</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wc  -l  ./nowcoder.txt</span></span><br><span class="line">8 ./nowcoder.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 统计文件中最长的一行的字节数</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wc -L nowcoder.txt</span></span><br><span class="line">38 nowcoder.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 打印一个日志文件的单词数目</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wc -w nowcoder.txt </span></span><br><span class="line">31 nowcoder.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 打印当前目录下所有文件的行数，并统计最终行数</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wc -l *</span></span><br><span class="line">  0 a.txt</span><br><span class="line"> 10 nowcoder.txt</span><br><span class="line"> 10 total</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出结果也包含了文件名，所以如果只需要行数，还需要cut共聚介入处理只取出第一列的值。</p>
</blockquote>
<h2 id="tail指令"><a href="#tail指令" class="headerlink" title="tail指令"></a>tail指令</h2><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">输出a.txt的最后100行</span><br><span class="line">tail -n 100 a.txt</span><br><span class="line">从100行开始输出一直到最后</span><br><span class="line">tail -n +100 a.txt</span><br></pre></td></tr></table></figure>

<h2 id="head指令"><a href="#head指令" class="headerlink" title="head指令"></a>head指令</h2><p>与tail相反，head是从头取文件的行</p>
<p>使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">head -n 5 nowcoder.txt | tail -n 1</span><br></pre></td></tr></table></figure>



















]]></content>
      <categories>
        <category>后端</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>HCA架构</title>
    <url>/2022/05/08/HCA%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>​    <a id="more"></a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p> HCA架构，也叫超融合架构，简而言之就是把不同方式读取数据源以及读取不同数据源的东西融合到一起，然后提供给领域层调用融合后的统一接口，进行业务处理，最终返回给上层。</p>
<p>HCA架构的优点是摒弃了专用存储网络，大大降低了存储成本。缺点是数据的读写无法保持一致的性能比如某些数据源可能读写较快某些数据源可能读写较慢。</p>
<p><a href="https://blog.csdn.net/weixin_34194702/article/details/90388620">参考文章</a></p>
<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="/2022/05/08/HCA%E6%9E%B6%E6%9E%84/1653313890632.png" alt="1653313890632"></p>
<h3 id="目录简介"><a href="#目录简介" class="headerlink" title="目录简介"></a>目录简介</h3><p>hca目录</p>
<ul>
<li><p><strong>ohs</strong>：开放主机服务（北向），提供远程和本地服务，在分布式场景下多被另外一个界限上下文的 acl 防腐层调用。</p>
</li>
<li><p><strong><em>appservice*</em></strong>：应用<strong>服</strong>务，主要为远程*服务提供实现。</p>
</li>
<li><p><strong>appservice.executor</strong>：命令执行器 - 同时也是应用服务的具体实现的载体。为什么会有这一层 : 主要是为了让应用服务的实现从原本的大实现类中分离出来，不至于随着业务的增加，应用服务的实现别的无比臃肿，执行器的职责就是干好一件事。</p>
</li>
<li><p><strong>event subscriber</strong>：事件订阅。</p>
</li>
<li><p><strong>pl</strong>：publish language（发布语言），一般包含请求命令及响应、远程调用参数和响应，ohs 层中主要是请求命令和响应。</p>
</li>
<li><p><strong>pl.command</strong>：存放 命令和查询。</p>
</li>
<li><p><strong>pl.data</strong>：DTO 数据传输对象。<strong>最终发送给用户的封装之后的对象</strong></p>
</li>
<li><p><strong>remote.controller</strong>：<strong>相当于Controller层</strong> </p>
</li>
<li><p><strong>domain</strong>：领域层。</p>
</li>
<li><p><strong>domain.entity</strong>：领域实体、对象传输模型。</p>
</li>
<li><p><strong>domain.event</strong>：事件。</p>
</li>
<li><p><strong>domain.service</strong>：领域服务，完整的原子业务服务（应用服务层通用能力的沉淀），一般在执行器中被编排。</p>
</li>
<li><p><strong>domain.exception</strong>：领域异常。</p>
</li>
<li><p><strong>domain.valueobject</strong>：领域实体 值对象。、</p>
</li>
<li><p><strong>acl</strong>：防腐层（南向），ohs、领域层 调用防腐层时只通过领域对象打交道，除非时 CQRS 模式中直接查询，acl 层可以直接返回 DTO。</p>
</li>
<li><p><strong>dataobject</strong>：数据对象，一般是 Jpa的持久化对象，命名样例: ExampleDO。</p>
</li>
<li><p><strong>jpa</strong>：JPA 数据访问层，命名样例: ExampleJpaDAO。原来我们 JPA 接口使用 XXXRepository 命名，但是为了与 HCA 框架中仓储的概念区分，统一命名 XXXJpaDAO 作为JPA数据访问层的命名。</p>
</li>
<li><p><strong>pl</strong>：publish language（发布语言），一般包含命令、数据响应、远程调用参数和响应，acl 层中主要是远程调用及响应。</p>
</li>
<li><p><strong>Repository</strong>：领域实体 仓储接口，命名样例: ExampleRepository。</p>
</li>
<li><p><strong>adapter</strong>：仓储适配器，适配器是端口的实现。命名样例: ExampleRepositoryAdapter</p>
</li>
</ul>
<h3 id="第一层仓储层-acl"><a href="#第一层仓储层-acl" class="headerlink" title="第一层仓储层(acl)"></a>第一层仓储层(acl)</h3><p>负责数据库数据的读写，可以通过mapper、jpa等手段进行数据读取，数据源可以是mysql、redis等。</p>
<p>仓储层有两个文件夹</p>
<p><img src="/2022/05/08/HCA%E6%9E%B6%E6%9E%84/image-1652004960501.png" alt="img"></p>
<h4 id="adapter-repository"><a href="#adapter-repository" class="headerlink" title="adapter.repository"></a>adapter.repository</h4><p>仓储层接口的实现，其包括如下内容</p>
<p><img src="/2022/05/08/HCA%E6%9E%B6%E6%9E%84/1653314172367.png" alt="1653314172367"></p>
<p>其中dataobject是仓储层的数据对象，用来<strong>简单</strong>封装从数据库中的数据。</p>
<h5 id="dataobject文件夹"><a href="#dataobject文件夹" class="headerlink" title="dataobject文件夹"></a>dataobject文件夹</h5><p>xxDO对应的就是一个数据对象类</p>
<p>.  一般xxDO继承了IdentityStrategyEntity，来作为jpa的默认的自增主键</p>
<p>.  提供了from()方法，将上层传入的领域对象，转化成数据对象(XXDO)然后存入数据库中</p>
<p>.  提供了to()方法，将本层的数据对象转化成上层的领域对象</p>
<p>.  此外对于数据对象中的值固定的属性一般采用枚举类型</p>
<p>tip:这两种方法都使用了BeanCopierUtils工具类，进行对象的深拷贝。</p>
<h5 id="jpa文件夹中"><a href="#jpa文件夹中" class="headerlink" title="jpa文件夹中"></a>jpa文件夹中</h5><p>存放的是使用jpa方式实现的数据操作接口，由于jpa会提供默认的接口实现，所以一般不需要我们提供接口方法。直接继承对应的<strong>JPARepository&lt;查询出来的数据对象的类型，该数据对象的主键&gt;</strong>即可</p>
<p><img src="/2022/05/08/HCA%E6%9E%B6%E6%9E%84/image-1652004960796.png" alt="img"></p>
<h5 id="MyBatis文件夹"><a href="#MyBatis文件夹" class="headerlink" title="MyBatis文件夹"></a>MyBatis文件夹</h5><p>存放使用使用mybatis方式实现的操作数据库表信息的类。一般该Mapper类继承了AppBaseMapper*&lt;*F5MemberDO&gt;来实现分页功能。</p>
<p><img src="/2022/05/08/HCA%E6%9E%B6%E6%9E%84/1653314229584.png" alt="1653314229584"></p>
<h5 id="XXRepositoryAdapter"><a href="#XXRepositoryAdapter" class="headerlink" title="XXRepositoryAdapter"></a>XXRepositoryAdapter</h5><p>实现了port.repository中声明的接口，一般注入了jpaDAO以及Mapper对象来对该接口进行实现，一般在这个类中对上层传入的领域对象转化成数据对象然后转化成调用仓储方法进行数据库操作。</p>
<p><img src="/2022/05/08/HCA%E6%9E%B6%E6%9E%84/1653314269885.png" alt="1653314269885"></p>
<h4 id="port-repository"><a href="#port-repository" class="headerlink" title="port.repository"></a>port.repository</h4><p>仓储层提供给上层的接口，方法的入参一般是本层的实体类对象即XXDO，方法的返回值是上层实体对象即领域层实体对象。</p>
<h3 id="第二层领域层"><a href="#第二层领域层" class="headerlink" title="第二层领域层"></a>第二层领域层</h3><p>负责某个领域的业务逻辑的处理，使用下层提供的数据进行处理，并最终返回给上层。</p>
<p><img src="/2022/05/08/HCA%E6%9E%B6%E6%9E%84/image-1652004960545.png" alt="img"></p>
<h4 id="entity"><a href="#entity" class="headerlink" title="entity"></a>entity</h4><p>此文件夹内部存放是领域层的实体对象类，用来对本层进行业务逻辑处理后的数据进行封装。</p>
<p><img src="/2022/05/08/HCA%E6%9E%B6%E6%9E%84/1653314292404.png" alt="1653314292404"></p>
<p>.  一般此对象要提供从上层DTO对象转化成本层领域实体对象的的from方法，以及将本层领域实体对象转化成下层数据对象的to方法。</p>
<h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><p>此文件夹存放，本层使用下层仓储适配器实现的提供给上层的服务类，这些类的方法返回值一般是DTO对象，传入的参数一般是本类对象</p>
<p><img src="/2022/05/08/HCA%E6%9E%B6%E6%9E%84/1653314321323.png" alt="1653314321323"></p>
<h3 id="第三层远程服务层-ohs"><a href="#第三层远程服务层-ohs" class="headerlink" title="第三层远程服务层(ohs)"></a>第三层远程服务层(ohs)</h3><p>负责对请求进行封装、传入下层服务进行处理，对处理的返回值进行包装。</p>
<p><img src="/2022/05/08/HCA%E6%9E%B6%E6%9E%84/image-1652004960501.png" alt="img"></p>
<h4 id="local-appservice"><a href="#local-appservice" class="headerlink" title="local.appservice"></a>local.appservice</h4><p>此文件夹表示本地应用服务，是使用下层服务实现的请求处理并最终返回合适的响应对象给浏览器流程的封装。</p>
<p>其包括文件夹如下</p>
<p><img src="/2022/05/08/HCA%E6%9E%B6%E6%9E%84/image-1652004960593.png" alt="img"></p>
<h5 id="api"><a href="#api" class="headerlink" title="api"></a>api</h5><p>是本地服务接口，声明了本项目能够对请求命令进行哪些处理，并且能够返回什么给浏览器。</p>
<p>.  一般方法返回Response</p>
<p>.  分页查询方法返回PageResponse<T></T></p>
<p>.  返回所有对象的列表方法返回MultiResponse<T></T></p>
<p>服务方法的入参常常是某个原子操作的命令</p>
<h5 id="executor"><a href="#executor" class="headerlink" title="executor"></a>executor</h5><p><img src="/2022/05/08/HCA%E6%9E%B6%E6%9E%84/1653314350494.png" alt="1653314350494"></p>
<p>使用下层服务xxService实现的某个原子操作的类，该执行器类拥有execute方法表示调用执行器执行。也是本地服务接口实现类的调用对象。</p>
<h5 id="impl"><a href="#impl" class="headerlink" title="impl"></a>impl</h5><p>本地服务接口实现类存放的文件夹，本地服务接口实现类implements 本地服务接口，通过传入的各种原子操作执行器，完成本地服务。</p>
<p><img src="/2022/05/08/HCA%E6%9E%B6%E6%9E%84/image-1652004960505.png" alt="img"></p>
<p><img src="/2022/05/08/HCA%E6%9E%B6%E6%9E%84/1653314439915.png" alt="1653314439915"></p>
<h4 id="pl"><a href="#pl" class="headerlink" title="pl"></a>pl</h4><p>ohs层的实体类存放文件夹</p>
<p><img src="/2022/05/08/HCA%E6%9E%B6%E6%9E%84/image-1652004960546.png" alt="img"></p>
<h5 id="command"><a href="#command" class="headerlink" title="command"></a>command</h5><p>是对请求数据的封装</p>
<p>一般增删改这样的请求，要求我们定义一个XXCommandCmd，封装请求的一般属性，这个CommandCmd还要实现Command接口（标记接口）。一般还要<strong>提供一个转化成下层领域对象的to方法。</strong></p>
<p><img src="/2022/05/08/HCA%E6%9E%B6%E6%9E%84/1653314460520.png" alt="1653314460520"></p>
<p>一般查询这样的请求，要求我们定义一个XXQry，封装查询请求的信息，并实现Query接口，这个接口要继承Command接口（标记接口）。</p>
<p>特别地分页查询，接口需要继承一个PageQuery<em>接口</em></p>
<p><img src="/2022/05/08/HCA%E6%9E%B6%E6%9E%84/1653314479034.png" alt="1653314479034"></p>
<h5 id="data"><a href="#data" class="headerlink" title="data"></a>data</h5><p>封装返回数据的对象，这些类要提供从下层的领域对象实体转化成本层DTO的方法from</p>
<p><img src="/2022/05/08/HCA%E6%9E%B6%E6%9E%84/image-1652004960646.png" alt="img"></p>
<p><img src="/2022/05/08/HCA%E6%9E%B6%E6%9E%84/image-16520049630569.png" alt="img"></p>
<h4 id="remote-controller"><a href="#remote-controller" class="headerlink" title="remote.controller"></a>remote.controller</h4><p>远程服务，存放Controller，共浏览器使用。本层的Controller类使用本层的本次服务接口实现类实现了各种操作，并返回方法返回值给客户。</p>
<p><img src="/2022/05/08/HCA%E6%9E%B6%E6%9E%84/1653314523806.png" alt="1653314523806"></p>
<p>下面以增加为例讲解请求处理过程</p>
<p>​    前端采用post方式发送数据，请求体中携带json数据，到达对应的控制器方法后，请求体中的数据被映射到<img src="/2022/05/08/HCA%E6%9E%B6%E6%9E%84/image-16520034960578.png" alt="img">中，其data属性就代表前端传入的数据对象即被封装成了一个增加命令实体F5MemberAddCmd，此方法调用本地服务实现类的对应方法，本地服务实现方法，调用新增命令执行器，新增命令执行器调用领域层服务并传入新增命令转化成的领域层实体对象进行处理，领域层服务调用仓储层的服务实现操作并传入领域层对象的to方法的返回值即xxDO。最终仓储层返回领域对象。</p>
]]></content>
      <categories>
        <category>架构</category>
        <category>HCA</category>
      </categories>
      <tags>
        <tag>HCA</tag>
      </tags>
  </entry>
  <entry>
    <title>ip地址为什么要分类</title>
    <url>/2022/05/15/ip%E5%9C%B0%E5%9D%80%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p>​    <a id="more"></a></p>
<h2 id="为什么IP要分类呢？"><a href="#为什么IP要分类呢？" class="headerlink" title="为什么IP要分类呢？"></a>为什么IP要分类呢？</h2><p>​    因为如果按照全球一个网络、32位的ip全部用来表示这唯一的网络中的主机的位置，那么有如下问题：</p>
<ol>
<li>远距离传输数据大概率会出错</li>
<li>交换机存储空间要非常大,因为所有主机都在一个网络了，也就不涉及网络之间的转发了。</li>
</ol>
<blockquote>
<p>交换机位于OSI参考模型中的第二层（数据链路层），交换机的工作依赖于对MAC地址的识别（所有的网络设备都有一个唯一的MAC地址，通常是由厂商直接烧录进网卡中）。</p>
<p>当交换机从其某个端口收到一个数据包时，先读取包头中的源MAC地址（即发送该数据包的设备网卡的MAC地址），将该MAC地址和端口对应起来添加到交换机内存里的地址表中；然后再读取包头中的目的MAC地址，对照内存里的地址表看该MAC地址与哪个端口对应，如果地址表中有该MAC地址的对应端口，则将该数据包直接复制到对应的端口上，如果没有找到，则将该数据帧作为一个广播帧发送到所有的端口（泛洪），对应的MAC地址设备会自动接受该帧数据，同时，交换机将接受该帧数据的端口与这个目的MAC地址对应起来放入内存中的地址表中。</p>
</blockquote>
<h2 id="IP如何分类呢？"><a href="#IP如何分类呢？" class="headerlink" title="IP如何分类呢？"></a>IP如何分类呢？</h2><p>​    显然一刀切不可行，当然是因为<strong>不同网络下的终端数量也不同</strong>了，就好比<strong>大型商场</strong>和<strong>家庭用网</strong>，如果其中一种按照另一种的分类方式来的话总会有浪费或者不满足。进而诞生了abc类，<strong>但是如果你要问为何诞生abc类，就如大多数回答一样这是个历史问题</strong>，是有概率选择这个的，而且这个方式也不是完美的，不然也不会有后来的子网掩码了。因为处于不同网段的计算机无法直接通信，必须通过ip地址与相应的子网掩码做与操作计算出源ip与目标ip是否处于同一网段。处于同一网段则可以通过ARP广播找到同网段中目标的MAC地址，然后直接送出数据到该MAC对应的端口处。如果不同网段，则通过ARP广播找到本地网关的MAC地址，然后发送数据到网关，网关根据目标IP查路由表，将数据包转发到其他网段。</p>
<blockquote>
<p>A类：000<del>127，默认子网掩码：255.0.0.0/8<br>B类：128</del>191，默认子网掩码：255.255.0.0/16<br>C类：192<del>223，默认子网掩码：255.255.255.0/24<br>D类：224</del>239，以1110开始 用于组播<br>E类：240~255， 以11110开始 用于科研保留</p>
</blockquote>
<p>但是这种网络划分方式还是有问题，总不可能一个公司四个部门共用一个ip地址，或者花大价钱各买一个ip地址吧。因此就需要继续划分子网。</p>
<blockquote>
<p> 其中172.x.x.x段地址空间是被保留的回环地址 </p>
<p>一个网络中主机的数量=2[^(主机位个数)]-2，因为减去了网络地址（主机位全0）以及广播地址（主机为全1）</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配相关算法</title>
    <url>/2022/06/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>​    <a id="more"></a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>字符串是开发中经常遇到的一种数据结构，就是有简单字符构成的序列，常见的问题包括，字符串匹配问题、子串问题、前后缀问题、子序列相关问题。本文旨在对一些字符串常用算法进行总结。</p>
<h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h2><p>字符串是开发中经常使用的一种数据结构下面我们来学习一下其涉及的各种算法</p>
<p>字符串匹配可用于数据处理、压缩、文本编辑、信息检索、甚至在分子生物学领域也大放异彩。字符串匹配分为精确匹配和模糊匹配（近似匹配）两种类型,而精确匹配算法又可以分为单模式匹配和多模式匹配算法。</p>
<blockquote>
<ul>
<li>单模式匹配算法：在字符串A中查找字符串B的位置，A叫主串，B叫模式串。</li>
<li>多模式匹配算法：在长文本主串$A$中查找字符串$B_1、B_2、B_3、…$这些模式串的位置。</li>
</ul>
</blockquote>
<h3 id="单模式匹配"><a href="#单模式匹配" class="headerlink" title="单模式匹配"></a>单模式匹配</h3><h4 id="BF"><a href="#BF" class="headerlink" title="BF"></a>BF</h4><ul>
<li><p>介绍</p>
<p>一次循环从主串的一个下标出发，不断的与模式串对应位置的字符进行比较，不同则结束此次循环；相同则继续比对如果最终全部比对成功，则返回下标位置，否则进行下一个下标位置处的比对。如果最终都没有比对成功则返回-1.</p>
</li>
<li><p>图解</p>
<p> <img src="/2022/06/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/c2cec3fdfc039245dff7384787da7cc57c1e2589.jpeg" alt="img"></p>
</li>
<li><p>复杂度</p>
<p>主串长度为n，字串长度为m，循环最多要执行O(n-m+1)次，每次比对最多比对m个字符，因此时间复杂度为O(nm)。 </p>
</li>
<li><p>实现</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">isMatch</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实际实现是每个字符串做字符比较 ，需要循环子串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (a.length() - b.length()); i++) &#123; </span><br><span class="line">        <span class="keyword">if</span> (a.startsWith(b, i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用场景</p>
<p>实际开发中较为常用，因为实际开发中，字符串长度不会太长，且最坏情况也不会经常发生，所以从统计学角度来看更加实用。</p>
</li>
</ul>
<h4 id="RK"><a href="#RK" class="headerlink" title="RK"></a>RK</h4><ul>
<li><p>介绍</p>
<p>由 Rabin 和 Karp 两人发明的算法。通过主串中n-m+1个字串的hash值，直接与模式串串的hash值进行比对，避免了BF算法中的比对过程，理想情况下时间复杂度为O(n)，但是由于如果求hash值方法设计的不好，可能会产生<strong>hash冲突（不同字符串的hash值相同）</strong>的问题，此时还需要对冲突的每个子串与模式串进行比对，算法退化成BF，时间复杂度最坏是O(nm)。但是如果你能设计一个不会冲突的hash函数，那么就不必再次比对每个hash相同的情况就能保持O(n)。</p>
</li>
<li><p>具体步骤：</p>
<ul>
<li><p>第一步：计算模式串的hashcode。伪代码：hashcode = hash(pattern);</p>
</li>
<li><p>第二步：从i位置生成主串与模式串等长子串，并计算出其hashcode:hashcode2 = hash(t);</p>
</li>
<li><p>第三步：比较两个hashcode是否相等</p>
<p>如果两个hashcode不相等，则继续重复执行第二步；</p>
<p>如果两个hashcode相等，然后再拆分每个字符进行比对进一步确保字符相等，如果每个字符都相等则终止流程；</p>
</li>
</ul>
</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rk</span><span class="params">(String t, String pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash_pattern = pattern.hashCode();</span><br><span class="line">    <span class="keyword">int</span> len_p = pattern.length(),len_t = t.length(),hash_temp;</span><br><span class="line">    String tempString;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len_t - len_p; i++) &#123;</span><br><span class="line">      tempString = t.substring(i, i + len_p);</span><br><span class="line">      hash_temp = tempString.hashCode();</span><br><span class="line">      <span class="keyword">if</span> (hash_temp!=hash_pattern) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tempString.compareTo(pattern)==<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进一步优化的想法：这里是每次都重新对字符串计算一次hash，但是每次计算只变动了首尾两个字符，所以，可以直接将计算hash的算法提出来部分，避免对中间字符进行计算。不过具体是否可以进行优化，还是要看hash算法。</p>
</li>
</ul>
<h4 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h4><ul>
<li><p>介绍</p>
<p>D.E.Knuth、J.H.Morris和V.R.Pratt 3人于1977年提出来的。先来讲一下BF算法的缺陷：主串aabaabaaf模式串aabaaf，假设现在处于BF算法的外层循环的下标为0处的循环比对过程，匹配到f与b时比对失败。那么下次比对完全可以从主串下标为5，模式串下标为2处进行比对，但是BF算法抛弃每次匹配结果中的有效信息，导致大量的无效的回溯，仍然从头开始比对两者。因此KMP算法对BF进行了优化，其大概思路：在一次比对失败之后，主串中匹配失败位置不需要回溯到前面重新进行比对，模式串的指针回溯当前模式串当前字符前面的子串中的最长相等前后缀字符串的下一位置处进行比对。这个算法的关键在于利用模式串求出一个数组，这个数组告诉模式串下一次比对的回退位置，因此也叫next数组。此外补充一点：<strong>为什么不需要回退主串的指针呢？</strong>因为如果如下这种情况</p>
<p>主串：aabdaabcaad</p>
<p>模式：aabdaabd</p>
<p>当匹配 到主串的c与模式的d时，匹配失败，那么已经匹配的前面字符串为aabdaab,其最小公共前后缀为aab，即使主串回退到aab的第二个a处与模式串重新比较，由于d在那边，所以从第二个a到d处开始的主串与模式串的比较都是多余的，而由于aabd与aabc有公共前缀，所以从d到c前面的b的字符处开始的主串与模式串的比较也是多余的，所以主串指针不需要回退，只需要移动模式串的指针到最长公共前后缀的下一个字符处开始比较即可。</p>
<blockquote>
<p>比如当前字符为f，其前面字符串对应的<a href="https://www.bilibili.com/video/BV1M5411j7Xx?spm_id_from=333.337.search-card.all.click">最长相等前后缀</a>为<code>aa</code>，长度为2，因此下次比对直接从模式串的下标为2处进行比较。特别地，当模式串第一个字符失配时，回退的位置就是达到下标为0处。</p>
<p>首先next数组j对应的元素是j下标前面的子串的最长相等前后缀长度，而这个长度也是当前匹配失败处，模式串需要回退的位置。</p>
<p>由于以上性质可以推导出next数组的求值方式：</p>
<p>j=0时，由于最长相等前后缀不存在，则主串需要向后移动一位，则对应的next[0]=-1;</p>
<p>j&gt;0时，next[j]：如果next[j-1]对应的字符和j对应的字符相等，则next[j]=next[j-1]+1;如果不相等，则再将next[next[j-1]]对应的字符与j对应的字符相比，如果相等则，next[j]=next[next[j-1]]+1；如果不相等重复刚刚的不相等的过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] getNext(String pattern) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[pattern.length()];</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; next.length; i++) &#123;</span><br><span class="line">      k=next[i-<span class="number">1</span>];<span class="comment">// 假定前一个最长相等前后缀的长度</span></span><br><span class="line">      <span class="keyword">while</span> (pattern.charAt(k) != pattern.charAt(i) &amp;&amp; k &gt; <span class="number">0</span>) &#123;<span class="comment">// 不断寻找到最吻合的最长相等前后缀的长度</span></span><br><span class="line">        k = next[k - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (pattern.charAt(k) == pattern.charAt(i)) &#123;<span class="comment">// 比对前后缀后面的字符是否与当前字符一致</span></span><br><span class="line">        k++;</span><br><span class="line">      &#125;</span><br><span class="line">      next[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p>####<a href="https://www.jb51.net/article/247405.htm#_lab2_1_0">BM</a></p>
<ul>
<li><strong>介绍：</strong>kmp算法好，不错，但是有个毛病，考虑一下如下情况(下标从1开始计算)：当主串T[14]=’a’与模式串P[8]=’c’不等时，要根据对应的next数组值，将模式串指针移动到P[5]=’b’与主串的T[14]对比，显然这是合理的，但是当主串T[14]=’S’，时，S不存在于模式串中，那么P[5]与T[14]的比较也是多此一举的，直接可以从T[15]与P[1]开始对比。基于这种主串中可能有字串没有的字符串导致大量无效对比的情况，又有人想出了BM算法，这种算法在绝大多数场合比KMP更加出色。</li>
</ul>
<p><img src="/2022/06/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1654429900570.png" alt="1654429900570"></p>
<ul>
<li><p><strong>算法原理：</strong></p>
<ul>
<li><p>坏字符原则：主串与模式串当前比较失配的字符；而坏字符原则指当比较到这种字符的时候，直接将模式串后移<code>坏字符对应的模式串字符的位序 - 模式串中的上一次出现坏字符位序（不存在为0）</code>个位置 ，然后从末到头进行比较。</p>
<p>》为什么要从末到头对比呢？因为一般情况下，坏字符是同等概率分布在字符串中的，但是我们从头到尾比较字符串带来的移动模式串的幅度，不如从末到头来对比模式串移动的幅度大，后者更加能够避免无效对比。</p>
<p>比如：如图，d为坏字符，对应位置为5，模式串中没有d这个坏字符，因此对应位置为-1,那么移动模式串到主串的6=5–1处开始比较。<img src="/2022/06/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1654430640826.png" alt="1654430640826">但是仅有坏字符原则远远不够，如果遇到主串<code>aaaaaa</code>模式串<code>baaa</code>求出来的移动位数是负数就没招了。</p>
</li>
<li><p>好后缀原则：模式串中从尾到头已经匹配的部分叫做好后缀，比如下图的<code>ab</code>，我们拿着ab到模式串从尾部到头找匹配的<strong>其他（不同于当前已经匹配的）</strong><code>ab</code>，如果找到一个直接将模式串移动到找到的的ab处进行从尾部到头部的对比。如果找不到另一个ab则倘若模式串的前缀a、ab、abd、abda、…能够和好后缀的后缀匹b配上，则我们直接滑到匹配位置。(为什么不考虑中间可能出现b的情况呢，因为如果中间出现了，那么其前面的字符必然不是a,那么此次比较必然会失败。) </p>
</li>
<li><p>模式串向后滑动距离取两者计算出来的较大值。 </p>
</li>
</ul>
<p><img src="/2022/06/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1654432126151.png" alt="1654432126151"></p>
</li>
<li><p>算法实现</p>
<ul>
<li>利用坏字符算法，计算匹配串可以滑动的距离</li>
<li>利用好后缀算法，计算匹配串可以滑动的距离</li>
<li>结合坏字符算法和好后缀算法，实现BM算法，查看匹配串在主串中存在的位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="多模式匹配"><a href="#多模式匹配" class="headerlink" title="多模式匹配"></a>多模式匹配</h3><p>多模式匹配问题：给一个字符串S和一个字符串数组T(T中的字符串要比S短许多)，设计一个算法，在字符串S中查找T中的字符串。<br>我们把S称为目标串，T中的字符串称为模式串。设目标串S的长度为m，模式串的平均长度为 n，共有k个模式串。如果我们用KMP算法(或BM算法)去处理每个模式串，判断模式串是否在目标串中出现，匹配一个模式串和目标串的时间为O(m+n)，所以总时间复杂度为：O(k(m+n))。一般实际应用中，目标串往往是一段文本，一篇文章，甚至是一个基因库，而模式串则是一些较短的字符串，也就是m一般要远大于n。这时候如果我们要匹配的模式串非常多(即k非常大)，那么我们使用上述算法就会非常慢。这也是为什么KMP或BM一般只用于单模式匹配，而不用于多模式匹配。因此催生了多模式串匹配算法，这种问题思路常用于：关键词过滤、入侵检测、病毒检测、分词等等问题中(仅考虑英文的，中文的我不会)。涉及的解法如下：</p>
<h4 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h4><p>​    Trie树，也叫字典树、前缀树，由若干单词构建成字典树。Trie树常用于统计词频、保存以及排序大量的字符串、字符串查询，由于避免了大量无效的字符串比较，因此其适合于动态查询（比如搜索框的实时关联词提示）。与传统树的结构不同，Trie树某个节点处的实际值由根节点到某个节点处的路径的所代表的字符组成的字符串（如下图），但是实际上我们并不会存储这个路径对应的字符串。</p>
<p><img src="/2022/06/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1655334907482.png" alt="1655334907482"></p>
<p>​    Trie的实现方式</p>
<p>​    链表方式：每一个节点处使用26条边，表示下一个字母,每个节点仅仅用来表示，当前到此节点处路径构成的单词是一个独立的单词还是一个前缀。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// trie树节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">  <span class="comment">//    标识从root出发到本节点的构成的字符串是否是一个单词，默认为false，即当前节点不是一个单词的末尾</span></span><br><span class="line">  <span class="keyword">boolean</span> isWordEnd;</span><br><span class="line">  <span class="comment">//    本节点延伸出去的字母数组，为null时表示，此节点为单词末尾。</span></span><br><span class="line">  TrieNode[] nexts;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// trie树</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieTree</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 字典树中是否存在某个单词</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> word</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">weatherContainsWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    TrieNode tempRoot = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Objects.isNull(tempRoot.nexts) || Objects.isNull(tempRoot.nexts[c - <span class="string">'a'</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tempRoot = tempRoot.nexts[c - <span class="string">'a'</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tempRoot.isWordEnd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 字典树中是否存在某个前缀</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> prefix</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">weatherContainsPrefix</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">    TrieNode tempRoot = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : prefix.toCharArray()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Objects.isNull(tempRoot.nexts) || Objects.isNull(tempRoot.nexts[c - <span class="string">'a'</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tempRoot = tempRoot.nexts[c - <span class="string">'a'</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 加入一个新单词</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> word</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] letters = word.toCharArray();</span><br><span class="line">    TrieNode tempRoot = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> letter : letters) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Objects.isNull(tempRoot.nexts)) &#123;</span><br><span class="line">        tempRoot.nexts = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (Objects.isNull(tempRoot.nexts[letter - <span class="string">'a'</span>])) &#123;</span><br><span class="line">        tempRoot.nexts[letter - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">      &#125;</span><br><span class="line">      tempRoot = tempRoot.nexts[letter - <span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    tempRoot.isWordEnd = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 加入一堆单词</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> words</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWords</span><span class="params">(String... words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">      addWord(word);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 广度遍历字典树，也叫层次遍历</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Queue&lt;TrieNode&gt; nodeQueue = <span class="keyword">new</span> LinkedList&lt;TrieNode&gt;();</span><br><span class="line">    nodeQueue.add(root); </span><br><span class="line">    <span class="keyword">int</span> preNodeCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nextNodeCount = <span class="number">0</span>;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (!nodeQueue.isEmpty()) &#123;</span><br><span class="line">      TrieNode tempNode = nodeQueue.poll();</span><br><span class="line">      <span class="keyword">if</span> (!tempNode.isWordEnd) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (Objects.nonNull(tempNode.nexts[i])) &#123;</span><br><span class="line">            nextNodeCount++;</span><br><span class="line">            nodeQueue.add(tempNode.nexts[i]);</span><br><span class="line">            sb.append((<span class="keyword">char</span>) (<span class="string">'a'</span> + i));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      preNodeCount--;</span><br><span class="line">      <span class="keyword">if</span> (preNodeCount == <span class="number">0</span>) &#123;</span><br><span class="line">        preNodeCount=nextNodeCount;</span><br><span class="line">        nextNodeCount=<span class="number">0</span>;</span><br><span class="line">        sb.append(<span class="string">'\n'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>讲完了Trie树，这种数据结构后，多模式匹配算法，可以利用这种数据结构。</p>
<p>实现流程：</p>
<p>​    1 将主串的所有后缀构造成一颗trie树：eg:’student’构造成的trie树中包含单词student、’udent、udent、dent、ent、nt、t。这个过程为O(n$^2$)，其中n为主串的长度。</p>
<p>​    2 然后遍历每个模式串，判断模式串是否是该trie树的前缀，是的话证明原来的主串中包含该模式串。这个过程时间复杂度为O($km$),k是模式串的个数，m是模式串的平均长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String t = <span class="string">"ahishers"</span>;</span><br><span class="line">    String[] ps = <span class="keyword">new</span> String[]&#123;<span class="string">"hi"</span>,<span class="string">"her"</span>,<span class="string">"shee"</span>&#125;;</span><br><span class="line">    TrieTree trieTree = <span class="keyword">new</span> TrieTree();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">      trieTree.addWords(t.substring(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String p : ps) &#123;</span><br><span class="line">      System.out.println(trieTree.weatherContainsPrefix(p));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">-------</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p>以上的这种做法效率极低，时间复杂度为O($n^2+km$)，空间复杂度为O($ n^2 $), 显然不适合进行模式串匹配算法，但是这种思路为下文的自动状态机进行了铺垫，所以必须掌握。</p>
<blockquote>
<p>字典树除了用来判断主串中是否包含某个模式串外，还可以用来对多个模式串对应的单词进行排序：先将多个单词建立Trie树，然后按照先序遍历输出这颗树的所有涉及单词，就是排序+去重后的单词集合；还可以用来查找不同字符串的最长的公共子串：先将不同字符串建立成Trie树，然后层序遍历每个节点，到达具有多个分支的节点为止，这个节点就是最长公共前缀的末尾。</p>
</blockquote>
<h4 id="AC自动状态机"><a href="#AC自动状态机" class="headerlink" title="AC自动状态机"></a>AC自动状态机</h4><p> <a href="https://www.bilibili.com/video/BV1uJ411Y7Eg?spm_id_from=333.337.search-card.all.click&vd_source=f95b900f862c216d7583fbbb4a9a3aa0">前提知识：Trie树、层序遍历</a></p>
<p>​    利用Tried字典树进行多模式匹配的前提条件。</p>
<p>主串以及模式串集如下：</p>
<p><img src="/2022/06/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1655393828643.png" alt="1655393828643"></p>
<p>自动状态机使用的字典树如下：</p>
<p><img src="/2022/06/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/1655392163582.png" alt="1655392163582"></p>
<ol>
<li><p>根据模式串集合构建字典树。</p>
<blockquote>
<p>与传统的字典树不同的是，AC自动状态机中的字典树，在一个结点处，使用一个长度列表不为null的长度列表表示该节点是字典中的一个单词，如果一个结点处的长度列表为null说明根节点到该节点为止的字符串不存在于模式串集合中，其仅仅只是某个模式串的前缀而已。也可以直接在单词末尾存储单词。</p>
</blockquote>
</li>
<li><p>预处理：层序遍历，构建出字典树每个结点处的失败指针（子节点的fail指针等于父节点的fail指针指向的节点的下面的某个分支），并继续维护每个节点处的长度列表。</p>
<blockquote>
<p>失败指针的作用，在对主串某个下标处为止匹配失败的时候，可以通过匹配失败位置处的失败节点，找到字典树中存在的以根节点到当前节点构成的字符串的所有后缀中的最长的那个末尾对应的节点，这就是fali指针的指向对象，从这个节点开始继续查找匹配失败的字符。fail指针可以简单理解为kmp算法中的next数组的作用。</p>
</blockquote>
</li>
<li><p>search：从根节点开始向下查找每个字符对应得分支，如果存在该分支说明可以继续匹配下一个字符，则继续跳到下一个字符位置处；如果不存在该分支：当前节点是根节点，则原地不动，如果是其他节点，找到其失败指针指向的节点处，从上个字符处继续比较，一直找，直到找到root节点，说明这个树种就没有这个模式串的单词前缀，放弃该字符，继续跳到下一个字符处开始比较。此外对于每个正在比较中的节点，都需要判断其是否表示字典树中的一个字符串被匹配到了，一次返回当前下标-长度的每个值，即为存在的每个模式串中开始下标。</p>
</li>
</ol>
<blockquote>
<p>AC字典树的一个特点：一个子节点的fail指针，必定指向其父亲节点的fail指针指向的节点或者其子节点。</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022/6/16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@blog</span>: zhuming-github.github.io</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: v1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AC</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ACTrieNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ACTrieNode[] branchs;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; words;</span><br><span class="line">    <span class="keyword">private</span> ACTrieNode fail;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ACTrie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ACTrieNode root = <span class="keyword">new</span> ACTrieNode();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addOneWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">      ACTrieNode tempRoot = root;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(tempRoot.branchs)) &#123;</span><br><span class="line">          <span class="comment">// 初始化每个结点处的分支数组</span></span><br><span class="line">          tempRoot.branchs = <span class="keyword">new</span> ACTrieNode[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加入某个不存在字符分支</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(tempRoot.branchs[c - <span class="string">'a'</span>])) &#123;</span><br><span class="line">          tempRoot.branchs[c - <span class="string">'a'</span>] = <span class="keyword">new</span> ACTrieNode();</span><br><span class="line">        &#125;</span><br><span class="line">        tempRoot = tempRoot.branchs[c - <span class="string">'a'</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      tempRoot.words = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      tempRoot.words.add(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用模式串数组words，构建字典树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> words 模式串数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(String... words)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        addOneWord(word);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 预处理，设置每个节点的失败指针，以及长度列表。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preprocess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Queue&lt;ACTrieNode&gt; nodeQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      nodeQueue.add(root);</span><br><span class="line">      <span class="keyword">while</span> (!nodeQueue.isEmpty()) &#123;</span><br><span class="line">        ACTrieNode fatherNode = nodeQueue.poll();</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(fatherNode.branchs)) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(fatherNode.branchs[i])) &#123;</span><br><span class="line">              ACTrieNode childNode = fatherNode.branchs[i];</span><br><span class="line">              <span class="keyword">if</span> (Objects.nonNull(fatherNode.fail) &amp;&amp; Objects.nonNull(fatherNode.fail.branchs) &amp;&amp; Objects.nonNull(fatherNode.fail.branchs[i])) &#123;</span><br><span class="line">                childNode.fail = fatherNode.fail.branchs[i];</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                childNode.fail = root;</span><br><span class="line">              &#125;</span><br><span class="line">              nodeQueue.add(childNode);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Integer&gt; <span class="title">search</span><span class="params">(String t)</span> </span>&#123;</span><br><span class="line">      ACTrieNode tempRoot = <span class="keyword">this</span>.root;</span><br><span class="line">      <span class="keyword">char</span>[] chs = t.toCharArray();</span><br><span class="line">      Map&lt;String, Integer&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i = i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(tempRoot.words)) &#123;</span><br><span class="line">          <span class="keyword">for</span> (String word : tempRoot.words) &#123;</span><br><span class="line">            result.put(word, i - word.length());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(tempRoot.branchs) &amp;&amp; Objects.nonNull(tempRoot.branchs[chs[i] - <span class="string">'a'</span>])) &#123;</span><br><span class="line">          tempRoot = tempRoot.branchs[chs[i] - <span class="string">'a'</span>];</span><br><span class="line">          i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (Objects.nonNull(tempRoot.fail)) &#123;</span><br><span class="line">            tempRoot = tempRoot.fail;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (Objects.nonNull(tempRoot.words)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String word : tempRoot.words) &#123;</span><br><span class="line">          result.put(word, t.length() - word.length());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 测试程序</span></span><br><span class="line">    ACTrie acTrie = <span class="keyword">new</span> ACTrie();</span><br><span class="line">    <span class="comment">// 构建Ac自动机处理树，时间复杂度为O（m）,m为模式串的长度总和</span></span><br><span class="line">    acTrie.buildTree(<span class="string">"he"</span>, <span class="string">"she"</span>, <span class="string">"hers"</span>, <span class="string">"his"</span>);</span><br><span class="line">    <span class="comment">// 预处理，生成每个节点得fail指针，以及其他补充处理,时间复杂度为O(i),i为树的节点数</span></span><br><span class="line">    acTrie.preprocess();</span><br><span class="line">    <span class="comment">// 搜索，返回一个模式串以及出现位置得索引得map,时间复杂度为O(n),n为主串长度.</span></span><br><span class="line">    Map&lt;String, Integer&gt; ahisher = acTrie.search(<span class="string">"ahishers"</span>);</span><br><span class="line">    System.out.println(ahisher);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------</span><br><span class="line">    &#123;she=<span class="number">3</span>, his=<span class="number">1</span>, he=<span class="number">4</span>, hers=<span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="WM算法"><a href="#WM算法" class="headerlink" title="WM算法"></a>WM算法</h4><p>简而言之就是BM算法的多模式匹配版本,将多个字符构成一个字符块, 我暂未理解,可以移至<a href="https://www.cnblogs.com/ladawn/p/9281509.html#:~:text=WM%E7%AE%97%E6%B3%95%E6%98%AF%E5%AF%B9BM%E7%AE%97%E6%B3%95%E7%9A%84%E5%BB%B6%E4%BC%B8%E7%BB%A7%E6%89%BF%EF%BC%8C%E7%94%A8BM%E7%AE%97%E6%B3%95%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6%EF%BC%8C%E7%94%A8%E5%AD%97%E7%AC%A6%E5%9D%97%E6%9D%A5%E8%AE%A1%E7%AE%97shift%E8%A1%A8%EF%BC%88%E5%8F%96%E4%BB%A3%E5%9D%8F%E5%AD%97%E7%AC%A6%E8%A1%A8%EF%BC%89%E8%BF%9B%E8%A1%8C%E8%B7%B3%E8%BD%AC%EF%BC%8C%E5%9C%A8%E8%BF%9B%E8%A1%8C%E5%8C%B9%E9%85%8D%E6%97%B6%EF%BC%8C%E7%94%A8hash%E5%92%8Cprefix%E8%AE%A1%E7%AE%97%E5%89%8D%E5%90%8E%E7%BC%80%E7%9A%84hash%E5%80%BC%E6%9D%A5%E4%BB%8E%E4%BC%97%E5%A4%9A%E5%8F%AF%E9%80%89%E7%9A%84%E6%A8%A1%E5%BC%8F%E4%B8%B2%E4%B8%AD%E5%BF%AB%E9%80%9F%E7%AD%9B%E9%80%89%E5%87%BA%E6%AD%A3%E7%A1%AE%E5%8C%B9%E9%85%8D%E7%9A%84%E6%A8%A1%E5%BC%8F%E4%B8%B2%E3%80%82%20shift%E8%A1%A8%EF%BC%9A%E7%94%A8%E4%BA%8E%E8%AE%B0%E5%BD%95%E6%96%87%E6%9C%AC%E4%B8%B2%E5%90%91%E5%8F%B3%E7%A7%BB%E5%8A%A8%E7%9A%84%E9%95%BF%E5%BA%A6%EF%BC%8C%E5%8D%B3%E4%B8%80%E5%BC%A0%E8%B7%B3%E8%BD%AC%E8%A1%A8%EF%BC%88,ps%EF%BC%9A%E6%9C%89%E7%82%B9%E7%B1%BB%E4%BC%BCBM%E7%AE%97%E6%B3%95%E7%9A%84%E5%9D%8F%E5%AD%97%E7%AC%A6%E8%A1%A8%EF%BC%8C%E4%B8%8D%E8%BF%87BM%E6%98%AF%E9%92%88%E5%AF%B9%E5%8D%95%E5%AD%97%E7%AC%A6%EF%BC%8CWM%E6%98%AF%E9%92%88%E5%AF%B9%E5%AD%97%E7%AC%A6%E5%9D%97%20%EF%BC%89%E3%80%82">这里</a></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>字符串匹配相关算法</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络总结</title>
    <url>/2022/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>​    <a id="more"></a></p>
<p>​    前4个月实习中发现自己在计算机网络这块学习的还是不够透彻，于是抽空总结了一下。</p>
<p><a href="https://juejin.cn/post/6844904079974465544">参考文献1</a></p>
<p>[参考文献2](有了 IP 地址，为什么还要用 MAC 地址？ - 闪客sun的回答 - 知乎 <a href="https://www.zhihu.com/question/21546408/answer/2303205686">https://www.zhihu.com/question/21546408/answer/2303205686</a>)</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>网络通信的本质就是网络中不同的两个进程之间的通信。人们对计算机通信这个复杂（涉及建立会话、数据加密、会话保持等等）的过程进行抽象，拆离出了许多的层次，不同的层次负责通信的不同的要素。因而不同的拆解方法也会对应有不同的层次，大致可以划分为：OSI七层协议模型、TCP/IP四层协议模型、五层协议模型。</p>
<h3 id="大体交互流程"><a href="#大体交互流程" class="headerlink" title="大体交互流程"></a>大体交互流程</h3><p>MAC地址是局域网中通信的唯一标识，IP地址是不同网段之间交互的唯一标识。</p>
<p>集线器相当于把局域网络中不同电脑中互联的链路封装到一个机器中，其只负责接受数据无脑转发。由于只实现了网络协议的物理层的部分功能，因此是物理层设备。</p>
<p><img src="/2022/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/image-1655039971351.png" alt="img"></p>
<p>交换机相当于智能化的集线器，其接收到数据后，先学习一下，然后根据目标MAC地址，查找本地MAC地址表，如果有合适的端口就从合适的端口转发出去，如果没有则泛洪发送。由于实现了部分链路层的功能，因此是链路层设备。</p>
<p><img src="/2022/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/image-1655039971403.png" alt="img"></p>
<p>随着局域网规模的不断扩大，那么交换机中的MAC地址表越来越大，越来越难以维护，因此催生了ip地址以及路由这些概念。</p>
<p><img src="/2022/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/image-1655039971425.png" alt="img"></p>
<p>路由器的每个端口都有自己的MAC地址。路由器作为一个独立的具有多个MAC地址的设备，对于每个交换机来说，与自己相连的路由器与一个PC无异。</p>
<p><img src="/2022/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/image-1655039971427.png" alt="img"></p>
<ol>
<li><p>作为网络中一个有ip，不论是私网ip还是公网ip的主机，我想要发送数据到另一个拥有独立ip的主机，首先发送这所在主机必须通过子网掩码对网段进行与操作，判断两个ip是否属于同一个网段</p>
</li>
<li><ol>
<li>如果属于同一个网段，直接通过ARP协议获取该ip对应的mac地址，封装到数据帧中，然后直接通过转发给交换机，让交换机查询自己的【MAC地址-端口映射表】，从合适的端口转发给目标主机，目标主机接收到数据后，检查MAC地址是自己，接受数据。</li>
<li>如果不是同一个网段，则发送者主机网卡通过ARP协议获取本机配置该网络的默认网关IP的MAC，封装到数据帧中，然后将数据帧发送给交换机，交换机得到数据帧后学习一下，并无脑查询【MAC地址-端口映射表】，从合适的端口转发给网关（一般是路由器）。</li>
</ol>
</li>
<li><ol>
<li><ol>
<li>路由器接受到数据帧后，判断目标MAC地址是否与本接口的MAC地址一致，不一致则抛弃数据，一致则解封数据帧，取出目标ip，并查询自己的【目标IP网段-下一跳ip网段-端口表】，将每个条目的掩码与目标ip相与，并与每个条目对应的目标网段进行对比</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li><ol>
<li><ol>
<li>如果数据包含的目标ip在这个表中，如果得到的结果与此条目对应的目标ip网段一致则找出对应的下一跳的ip地址或者出接口，</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li><ol>
<li><ol>
<li><ol>
<li>如果得到的是端口信息，说明目标网络与路由器直接相连，则现在需要目标ip对应的MAC地址了，此时优先查找本地的ARP缓存表，如果找到了目标ip对应的MAC地址，则直接封装到数据帧中，然后从该端口转发给目标网段的交换机即可。如果ARP缓存中没有，则通过ARP协议获取目标IP对应的MAC地址，然后重复如上动作。</li>
<li>如果得到的是下一跳地址，则说明目标网络与路由器不是直接相连，则继续查找表，找出下一跳地址对应的转发的端口，然后从ARP缓存表或者通过ARP协议获取到下一跳IP对应的MAC地址，封装成数据帧，从下一跳地址对应的端口出去。下一跳IP对应的主机得到数据帧后，会根据目标MAC地址判断是不是发给自己的，是的话就接受处理，重复如上过程。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li><ol>
<li><ol>
<li>查不到，从路由器的默认网关端口转发出去。然后下一个路由器接受到重复b操作。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>对于交换机而言，只需要维护一张MAC地址－端口映射表，然后根据传递过来的数据帧的信息，找到合适的端口转发出去即可，如果没有找到合适的端口，则泛洪转发。</p>
</li>
</ol>
<p>ARP缓存表(在PC以及路由器中都有)结构如下：</p>
<p><img src="/2022/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/image-1655039971278.png" alt="img"></p>
<p>MAC地址表（仅在交换机中有）结构如下：</p>
<p><img src="/2022/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/image-1655039971428.png" alt="img"></p>
<p>路由表结构（仅在路由器中有）如下：</p>
<p><img src="/2022/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/image-1655039971305.png" alt="img"></p>
<h2 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h2><p>每一层实现各自的功能和协议,并完成与相邻层的接口通信.每一层提供的服务就是该层及其以下层的协作完成的.</p>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>责任：负责建立、维护、断开传输二进制数据的物理连接，以及数据的实际传输。</p>
<p>说明：本层主要是传输媒介标准规则，比如-10~-15v表示二进制的0这种规则</p>
<h3 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><p>责任：负责提供介质访问和链路管理，也负责同段网络中从一个节点，到另一个几点的数据传输</p>
<p>说明：</p>
<ol>
<li>把网络层传递过来的网络数据包，拆分，添加上帧首（编号）、帧尾，<strong>封装成数据帧</strong>，难点是<strong>帧定界</strong>【由于物理媒介中信号是源源不断的，因此需要界定一个数据帧的开始和结束，因此使用两个特殊的bit串作为数据帧的开始和结束的标志】</li>
<li>保证<strong>透明传输</strong>，即不会私自篡改上层给的数据【由于帧定界使用了两个bit串作为边界标志，那么bit串很可能与数据帧中的数据部分重复，这会导致错误的帧定界，最终导致数据传输失败，解决的办法有两种：字节填充和0bit填充，只讲字节填充是在数据帧的数据部分的定界符数据前添加一个转义字符，如过转义字符也在数据中，那么就再添加一个转移字符，这样将两个转义字符看出一个转义字符，而数据中的单独的转义字符视作普通的字符，接收端的数据链路层在读到两个转义字符自然认为其后面就是边界符】</li>
<li>接收端的数据链路层收到数据后，要判断传输过程中是否由于信号之类不可控因此导致bit位发生变化，数据损坏了，可选的算法有CRC循环冗余校验等。此外还需要保证传数据帧按照正确的顺序传递到接收端，因此接收端还需要再接收到一个数据帧后立即发送确认数据帧给发送方，如果发送方在规定时间内没有收到确认数据帧，立即重传没收到确认信息的数据帧给接收方。这便是【<strong>差错控制</strong>】。</li>
<li>如果发送方写出数据速率太快和接收方接受速率太慢，那么会导致数据帧丢弃，因为接收方存不下了，那么接收方会使用滑动窗口协议或者选择重传协议进行处理。这便是<strong>流量控制</strong>【注意：传输层TCP也有流量控制功能，区别在于TCP是端到端的流量控制，链路层是点到点（比如一个路由器到下一个路由器）】。</li>
</ol>
<p>双层模型实现载体</p>
<ol>
<li><p>链路层的设备</p>
</li>
<li><ol>
<li>网卡，也叫网络适配器，按照传输速率分类网卡可分为10Mb/s、100Mb/s、1000Mb/s和10Gb/s等多种速率的网卡。OS使用网卡驱动程序对网卡进行操作，将网络层的数据封装成帧。网卡诞生之刻就烧录了一个MAC地址，这个地址一般是单播地址</li>
</ol>
</li>
</ol>
<p><img src="/2022/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/image-1655039971360.png" alt="img"></p>
<ol>
<li><ol>
<li>网桥，低配版的交换机，用来隔离不同的冲突域（同一时间只能由一台设备发送信息的范围，即同一个网段），以及在不同的网段之间进行数据交换。接收到一个网段的广播的数据帧后，解析数据帧中的源MAC与目的MAC地址信息，学习一下并记录到MAC地址-接口 映射表，然后根据目的MAC地址，如果MAC地址是单播地址，则找到适当的出端口发送出去，如果不知道那个端口则广播到所有的端口中【除了来源端口，这种工作方式叫做泛洪】；如果是组播或者广播地址，则直接泛洪。</li>
</ol>
</li>
</ol>
<p><img src="/2022/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/image-1655039971365.png" alt="img"></p>
<p> c.  交换机，与网桥功能类似：接收帧、寻找通向目的地址的端口、发送帧。相当于多个网桥拼装成一个交换机。</p>
<p>有了网桥或者交换机，由于不同网段中的主机通信使用MAC地址，因此通过网桥或者交换机互联的不同网段可以物理上是一个网段。</p>
<ol>
<li>局域网依仗1、2层协议，例如以太网、无线局域网，以太网对于物理层的实现是完全按照OSI协议描述的，但是对于链路层，其继续分层成了MAC层和LLC层进行实现。以太网对数据的封装叫做以太网帧，来自网络层的数据被转化成以太网帧。以太网帧如下，目的地址与源地址都是MAC地址，局域网通信规则，局域网中的一个主机A向发送数据给同一个局域网中的主机B，A广播一个以太网帧，局域网中的每个机器接收后与自己的MAC地址进行比较，如果目标MAC地址是自己就接受，不是则抛弃，接收后进行差错控制等链路层部分责任。<img src="/2022/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/image-1655039971427.png" alt="img"></li>
<li>以太网的结构有：总线、星状拓扑等</li>
</ol>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>由于链路层负责相邻两个节点之间的通信，因此网络层负责网际间的数据传输。具体负责进行逻辑地址寻址，实现不同网络之间的路径选择。</p>
<p>前提知识：</p>
<ul>
<li><p>分组交换【即将数据切分成等长的组，然后进行在不同的节点之间进行存储转发，动态路由到合适的途径中传输】</p>
</li>
<li><p>ip数据报【网络层对等实体之间通信的数据的最小单元】</p>
</li>
<li><p>ip分片【由于上层数据是一股脑的丢给网络层进行封装的，显然如果把这么多数据封装太一个数据报里面去，显然不安全，而且不利于网络传输，因此需要对上层传输下来的数据进行切分，然后封装成一个个小的ip数据报】</p>
</li>
</ul>
<p><img src="/2022/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/image-1655039971421.png" alt="img"></p>
<ul>
<li>ip地址分类，由于不同网络的用途对网络中主机的数目要求一般不同，因此需要对ip网络进行分类</li>
</ul>
<p><img src="/2022/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/image-1655039971329.png" alt="img"></p>
<ul>
<li><p>网络地址转化</p>
</li>
<li><ul>
<li><img src="/2022/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/image-1655039971336.png" alt="img"></li>
</ul>
</li>
<li><p>子网和子网掩码【由于一个ip网络对于一个部门来说，仍然是显得有点浪费了，因此公司一般将申请的网络号继续划分成多个子网，供 不同的部门使用，但是表面上看这些ip都属于公司的ip网络中的，实际上这些网络之间是隔离的，需要使用对应网络的子网掩码进行计算求出其真实网络号】</p>
</li>
<li><p>网络层涉及的协议</p>
</li>
<li><ul>
<li>ARP协议【负责将一个机器的ip地址解析成其MAC地址，用来在局域网中通信，当局域网中某个机器上没有目标主机的MAC地址是，会发送ARP请求到局域网中的每个机器上，相关机器得到数据后，检验ip是不是自己的ip，不是就丢弃该数据包，相同则发送ARP响应数据包其中携带了自己的MAC地址】、</li>
<li>DHCP协议【负责为一个局域网中的机器动态的分配ip以及子网掩码】、</li>
<li>ICMP协议【负责规定当路由器找不到合适的输出端口时。返回错误的信息（终点不可达、时间超过、参数问题、改变路由），ping命令就是依靠ICMP，探测是否可达目的主机】</li>
</ul>
</li>
</ul>
<p>实现了网络层、链路层、物理层的设备：路由器、主机</p>
<p><img src="/2022/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/image-1655039971347.png" alt="img"></p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>以上三层实现了之后，主机之间的通信的基础（举个例子：交通规则、导航工具、交通工具等等）基本搭建好了，但是具体的主机通信时落实到主机上的一个个进程程序身上的，因此本层对进行通信方式的相关进行了规定，为更上层的应用层实现更加丰富的通信服务提供基础条件。</p>
<p>前提知识：</p>
<ol>
<li><p>端口号：一个主机上，同时运行着许多的程序，那么如何区分每个需要通信的程序呢，这便通过端口，当有数据来的时候，数据被发送到对应的端口监听程序中，这是其便得到了数据。但是不同主机上的进程通信方式分为两种TCP以及UDP，因此TCP和UDP各自拥有一套端口号体系，互不干扰。</p>
</li>
<li><p>网络层通信协议【负责规定网络层对等实体之间的通信过程规则】</p>
</li>
<li><ol>
<li>UDP协议：无连接的通信方式，通信前不需要建立连接通道，直接有什么发什么，不管tmd能不能送到。</li>
</ol>
</li>
<li><ol>
<li><ol>
<li>优点：无需建立连接，减少网络空间资源占用，没用<strong>拥塞控制，</strong>适合视频通话这种对实时性要求高以及丢失数据无所谓的通信。UDP报文头部（如下报文）较小，空间利用率高。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><img src="/2022/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/image-1655039971306.png" alt="img"></p>
<ol>
<li><ol>
<li><ol>
<li>缺点：数据可能会丢失，不适合大文件传输。</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li>TCP协议：有连接的通信方式【通信过程中网络空间会维持一条通信通道，供双方数据传输】</li>
</ol>
</li>
<li><ol>
<li><ol>
<li>优点：可靠有序、不丢不重、适合大文件传输，其拥有校验、序号、确认、重传以及流量控制机制</li>
<li>缺点：空间利用率低、时间延迟比较大</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><img src="/2022/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/image-1655039971325.png" alt="img"></p>
<p>上图中六个控制位的含义如下</p>
<table>
<thead>
<tr>
<th>控制位</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ACK</td>
<td>置1时表示确认号合法，为0的时候表示数据段不包含确认信息，确认号被忽略</td>
</tr>
<tr>
<td>PSH</td>
<td>置1时请求的数据段在接收方得到后就可直接送到应用程序，而不必等到缓冲区满时才传送</td>
</tr>
<tr>
<td>RST</td>
<td>置1时重建连接。如果接收到RST位时候，通常发生了某些错</td>
</tr>
<tr>
<td>SYN</td>
<td>置1时用来发起一个连接</td>
</tr>
<tr>
<td>FIN</td>
<td>置1时表示发端完成发送任务。用来释放连接，表明发送方已经没有数据发送了</td>
</tr>
<tr>
<td>URG</td>
<td>紧急指针，告诉接收TCP模块紧要指针域指着紧要数据</td>
</tr>
</tbody></table>
<p>TCP建立连接：</p>
<p><img src="/2022/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/image-1655039971428.png" alt="img"></p>
<p>SYN=1标识自己允许建立连接；seq=x是随机产生的序号。</p>
<p>接收者接收到数据后，SYN=1表示自己也愿意建立连接、返回的ACK=1表示确认接收到数据了、ack=x+1表示本次回答是对那次请求做出的、seq=y是随机产生的序列号。</p>
<p>发送放接收到确认信息后，再次发送报文，其中SYN=0表示本次请求不是请求建立连接而是正式传输数据了、ACK=1表示自己确认收到了你的消息。</p>
<p>TCP释放连接：</p>
<p><img src="/2022/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/image-1655039971427.png" alt="img"></p>
<ul>
<li>客户端发起请求，请求断开链接。FIN=1，seq=u。u是之前传送过来的最后一个字节的序号+1。</li>
<li>服务器收到客户端的请求断开链接的报文之后，返回确认信息。ACK=1，seq=v，ack=u+1。这个时候，客户端不能给服务器发送信息报文，只能接收。但是服务器要是还有信息要传给服务器，仍然能传送。这里的v是什么意思呢，这就取决于服务器发送给客户端之前的一个包确认号是多少了。</li>
<li>当服务器也没有了可以传的信息之后，给客户端发送请求结束的报文。FIN=1，ACK=1，ack=u+1，seq=w。这里的w，跟上面的v是一个意思，为什么不都是v呢，因为这一步和上一步中间可能还在发数据呢，所以seq这个数据发送的字节流序号可能要变。</li>
<li>客户端接收到FIN=1的报文之后，返回确认报文，ACK=1，seq=u+1，ack=w+1。发送完毕之后，客户端进入等待状态，等待两个时间周期（防止自己信息发送不成功还接受不到服务器返回的错误信息，最终导致服务器没关闭连接）。</li>
</ul>
<p>TCP连接方式有两种</p>
<ul>
<li>短连接：当发送者有一个请求的时候，该请求总是经历三次握手，得到响应，四次挥手的过程。这种连接通道短时间使用叫短连接，这种方式每次多发送了7个数据包，利用率太低。</li>
<li>长连接：当发送者与接收者建立连接之后，三次握手，发送有用数据，发送心跳维持数据报来保证连接通道维持，四次挥手，结束，这种长时间开启一个连接通过的方式叫做长连接。这种方式更加常用。</li>
</ul>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层使用下一层提供的基础服务，进行拼装，搭积木这种操作，拼装出形形色色的服务协议。主要负责对程序中可能常用的一些通信，比如文件传输、邮件传输、虚拟终端等等操作进行封装，成基本的服务单元，比如FTP协议、MAIL协议、，对于一些定制服务，还是需要自己利用底层提供的TCP或者UDP接口进行通信协议的设计（例如：利用Java中的Soeckt实现自己的文件传输协议）。</p>
<p>常见的应用层服务模型有如下几种：</p>
<ul>
<li><ul>
<li>C/S架构：比如电子邮件、QQ这种，往往需要自己使用TCP或者UDP实现自己的内部通信协议</li>
<li>B/S架构：比如浏览器中的网站这种</li>
<li>P2P架构：比如迅雷下载</li>
</ul>
</li>
</ul>
<p>计算机相互连接而成的网络叫做互联网，全球范围内的互联网叫做因特网，因特网采用TCP/IP协议簇联通不同的主机，提供了不同的服务，其中就有了万维网(www)，www即指使用了HTTP协议进行数据传输的网络不同节点资源构成的网络，HTTP协议规定了浏览器如何请求解析万维网文档，服务器如何传输文档为浏览器。</p>
<p>作为开发人员我们需要了解的是HTTP请求以及响应数据的结构：</p>
<p><img src="/2022/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/image.png" alt="img"></p>
<p>一个HTTP请求信息按照协议规定主要包括：</p>
<p><img src="/2022/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/image-1655039971428.png" alt="img"></p>
<p><strong>请求行</strong></p>
<ol>
<li><ol>
<li><ol>
<li>请求方法：客户端希望服务器对资源执行的动作</li>
<li>请求URL：要访问的服务器资源的路径</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>请求头</strong>：描述请求信息以及请求发出者的偏好</p>
<ol>
<li><ol>
<li><ol>
<li>版本：报文信息使用的版本种类，其格式：HTTP/&lt;主要版本号&gt;.&lt;次要版本号&gt;</li>
<li>首部字段名：对本次请求信息进行描述的字段名</li>
<li>值：该字段的值</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>请求空行</strong>：CRLF</p>
<p><strong>请求实体</strong>【携带POST方法的数据，一般不用，其格式也是a=xxx&amp;b=xxxx】</p>
<p>一个HTTP响应信息按照协议规定主要包括如下：</p>
<p><img src="/2022/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/image-1655039971427.png" alt="img"></p>
<p>内容与HTTP请求报文类似，其中的</p>
<p>状态码：指请求过程中发生的事情，比如状态码<strong>200</strong>表示请求成功</p>
<p>短语：对状态码进行解释的短语，比如200状态码对应的短语是<strong>OK</strong></p>
<p>请求头以及响应头中的字段极其解释如下</p>
<p>通用头部</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Connection</td>
<td>Keep-alive</td>
<td>本次连接的属性</td>
</tr>
<tr>
<td>Date</td>
<td></td>
<td>报文创建的时期</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td></td>
<td>本报文的编码方式，用于服务器编码字符</td>
</tr>
<tr>
<td>Cache-Control</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>请求头部特有的部分字段</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>值举例</th>
</tr>
</thead>
<tbody><tr>
<td>Host</td>
<td>请求发出者的主机名和端口号</td>
<td></td>
</tr>
<tr>
<td>Referer</td>
<td>当前请求的网络资源的URL</td>
<td></td>
</tr>
<tr>
<td>User-Agent</td>
<td>请求发出者的应用程序信息（一般是浏览器版本之类的）</td>
<td></td>
</tr>
<tr>
<td>Accept</td>
<td>告诉服务器我能够接受的哪些媒体类型</td>
<td></td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>告诉服务器能我支持哪些编码</td>
<td></td>
</tr>
<tr>
<td>Accept-Language</td>
<td>告诉服务器我支持哪些语言</td>
<td></td>
</tr>
<tr>
<td>Range</td>
<td>本次请求获取的请求主体的部分文件的内容，格式0-9，表示从取出第一个字节到第9个字节</td>
<td><strong>Range:bytes=0-9</strong>-》请求一个URL的前8个字节<strong>Range: bytes=0-50, 100-150</strong>-》请求一个文档的前50个以及后50个字节</td>
</tr>
<tr>
<td>If-Range</td>
<td>这是为了防止某次片段下载后，资源被修改过.如果资源被修改过，其modified_date时间与if-Range不同，则服务器返回整个文档，状态码以及短语为：200 OK;如果相同则返回Range规定的范围中的数据，并且状态码以及短语为：<strong>206 Partial</strong></td>
<td>If-Range: Wed, 21 Oct 2015 07:28:00 GMT</td>
</tr>
<tr>
<td>Authorization</td>
<td>用户提供给服务器的认证信息</td>
<td></td>
</tr>
<tr>
<td>Cookie</td>
<td>客户端向服务器发送的数据</td>
<td></td>
</tr>
</tbody></table>
<p>HTTP 协议<strong>范围请求</strong>允许服务器<strong>只发送 HTTP 消息的一部分</strong>到客户端。范围请求在<strong>传送大的媒体文件</strong>，或者<strong>与文件下载的断点续传</strong>功能搭配使用时<strong>非常有用</strong>。</p>
<p>响应头部特有的字段</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Age</strong></td>
<td></td>
</tr>
<tr>
<td>Server</td>
<td>服务器应用程序软件的名称和版本</td>
</tr>
<tr>
<td>Content-Length</td>
<td>响应主体或者文件的长度</td>
</tr>
<tr>
<td>Content-Type</td>
<td>响应主体的类型</td>
</tr>
<tr>
<td>Content-Range</td>
<td>响应的部分主体在整个相应主体资源中的为止以及资源总大小</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>响应实体最后一次被修改的时间</td>
</tr>
<tr>
<td>Accept-Ranges</td>
<td>它的值不为 “none”，那么表示该服务器支持范围请求。 Accept-Ranges: bytes 表示<strong>界定范围的单位是 bytes</strong> 。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>后端</category>
        <category>基础</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-正则表达式</title>
    <url>/2022/05/28/Java-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>​        <a id="more"></a></p>
<h2 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式?"></a>什么是正则表达式?</h2><p>​    简而言之，正则表达式就是一种字符串的模式串，这种模式串能够匹配一类或者一个字符串，结合正则表达式对这一类字符串做相应的处理比如替换、分割、去除等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my\s&#123;1&#125;name\s&#123;1&#125;is\s&#123;1&#125;peiqi.</span><br><span class="line">---</span><br><span class="line">这个模式串只能用来匹配&quot;my name is peiqi.&quot;这一个字符串。</span><br></pre></td></tr></table></figure>

<h2 id="正则表达式原理"><a href="#正则表达式原理" class="headerlink" title="正则表达式原理"></a>正则表达式原理</h2><p>​    当你写好一个正则表达式模式串时，并使用的时候，底层会拿着这个表达式从头到尾到目标字符串中遍历，看看是否匹配，匹配则可能会做相应的处理。因此一旦某个字符被模式串匹配中了，下一个开始匹配的位置必然在此之后。</p>
<h2 id="正则表达式的语法？"><a href="#正则表达式的语法？" class="headerlink" title="正则表达式的语法？"></a>正则表达式的语法？</h2><p>​    正则表达式的语法大体可以分为：普通字符、非打印字符、特殊字符(元字符)、限定符、定位符、选择、反向引用</p>
<h3 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h3><p>​    所有出现在正则表达式中的大小写字母、数字、个别标点符号等字符都是仅仅匹配自己。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">"abc!"</span>作为模式串只能匹配<span class="string">"abc!"</span></span><br><span class="line">但是<span class="string">"abc."</span>作为模式串可以匹配<span class="string">"ab"</span>、<span class="string">"abc"</span>、<span class="string">"abcc"</span>...因为其中的.不是普通字符，而是正则表达式识别的一种特殊字符。</span><br></pre></td></tr></table></figure>

<h3 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h3><p>​    什么是非打印字符？</p>
<p>​        就是界面中展示不了即看不见的字符，比如换行符、分页符、制表符等。这些字符一般无法用具体的某个符号表示，但是可以用转义字符表示。</p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\cx</td>
<td align="left">匹配由x指明的控制字符。比如\cp匹配ctrl+p</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="left">匹配一个制表符</td>
</tr>
<tr>
<td align="center">\v</td>
<td align="left">匹配一个垂直制表符</td>
</tr>
<tr>
<td align="center">\r</td>
<td align="left">匹配一个回车符,回车符是CR,表示回到本行行首</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="left">匹配一个换行符,换行符是LF，表示到达下一行的当前位置</td>
</tr>
<tr>
<td align="center">\s</td>
<td align="left">匹配一个空白字符（空格、制表符、换页符等）等价于[\f\n\r\t\v ],注意这里面有一个空格字符</td>
</tr>
<tr>
<td align="center">\S</td>
<td align="left">配任何非空白字符,等价于[^\f\n\r\t\v],注意这里面有一个空格字符</td>
</tr>
</tbody></table>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>​    什么是特殊字符？</p>
<p>​        特殊字符也叫元字符，在正则中，特殊字符具有特殊的含义，比如.表示出了\n之外的任何单个字符，如果我们需要匹配没有特殊意义的.字符，则需要添加转义字符\在正则表达式中。特殊字符又可以分为：限定符、定位符、选择符、反向引用。下表是一些无法分类的特殊字符。</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">.</td>
<td align="left">匹配除”\r\n”以及各种空白符之外的任何单个字符。若要匹配包括”\r\n”在内的任意字符，请使用诸如”[\s\S]”之类的模式。</td>
</tr>
<tr>
<td align="left">\</td>
<td align="left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符,  “\(“ 则匹配 “(“。</td>
</tr>
<tr>
<td align="left">(pattern)</td>
<td align="left">表示一个子表达式，子表达式是当前正则表达式里面的表达式，一个正则表达式中往往有多个子表达式供选择，如”a(pattern_a|pattern_b)”的匹配结果相当于正则表达式”apattern_a”与”apattern_b”的结果取并集，这类似于划分学生成绩时做的if-else if-else判断，这一个整体相当于一个正则表达式，每个判断分支又相当于一个子表达式，最终只有一个表达式作用于一个匹配的结果中。但是这种用法匹配的结果会被缓存起来，可能会导致大量的内存占用。我们可以用<strong>$0…$9</strong> 属性从结果”匹配”集合中检索捕获的匹配。这种能将匹配的字符串存储在缓存区的正则表达式也叫一个捕获组。</td>
</tr>
<tr>
<td align="left">(?:pattern)</td>
<td align="left">保证pattern匹配的结果不会被缓存起来。？打头的都是非捕获组，即匹配后不存放到内存区。</td>
</tr>
<tr>
<td align="left">(?=X )</td>
<td align="left">零宽度正先行断言。仅当子表达式 X 在 此位置的右侧匹配时才继续匹配。也就是说要使此零宽度断言起到我们想要的效果的话，就必须把这个非捕获组放在整个表达式的右侧。例如，/w+(?=/d) 与后跟数字的单词匹配，而不与该数字匹配。此构造不会回溯。</td>
</tr>
<tr>
<td align="left">(?!X)</td>
<td align="left">零宽度负先行断言。仅当子表达式 X 不在 此位置的右侧匹配时才继续匹配。例如，例如，/w+(?!/d) 与后不跟数字的单词匹配，而不与该数字匹配 。</td>
</tr>
<tr>
<td align="left">(?&lt;=X)</td>
<td align="left">零宽度正后发断言。仅当子表达式 X 在 此位置的左侧匹配时才继续匹配。例如，(?&lt;=19)99 与跟在 19 后面的 99 的实例匹配。此构造不会回溯。</td>
</tr>
<tr>
<td align="left">(?&lt;!X)</td>
<td align="left">零宽度负后发断言。仅当子表达式 X 不在此位置的左侧匹配时才继续匹配。例如，(?&lt;!19)99 与不跟在 19 后面的 99 的实例匹配</td>
</tr>
<tr>
<td align="left">[]</td>
<td align="left">字符集，[]内部的（字符集）出现的字符最终只有一个字符作为最终匹配结果的一个字符。比如[a-zA-Z0-9]只能匹配a-z或者A-Z或者0-9的一个字符。</td>
</tr>
<tr>
<td align="left">[<em>xyz</em>]</td>
<td align="left">字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”。</td>
</tr>
<tr>
<td align="left">[^<em>xyz</em>]</td>
<td align="left">反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”。</td>
</tr>
<tr>
<td align="left">[<em>a-z</em>]</td>
<td align="left">字符范围。匹配指定范围内的任何字符。例如，”[a-z]”匹配”a”到”z”范围内的任何小写字母。</td>
</tr>
<tr>
<td align="left">[^<em>a-z</em>]</td>
<td align="left">反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符。</td>
</tr>
</tbody></table>
<h4 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h4><p>​    限定符，用来指明前面组件出现的次数</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">*</td>
<td align="left">匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td>
</tr>
<tr>
<td align="left">{n}</td>
<td align="left">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td align="left">{n,}</td>
<td align="left">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>
</tr>
<tr>
<td align="left">{n,m}</td>
<td align="left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>
</tr>
</tbody></table>
<blockquote>
<p><em>、+、?在匹配的时候是贪婪的（最多匹配），即匹配的越多越好，比如a*可以匹配 空、a、aa、aaa、，如果一个字符串中有aaa那么a*会选择匹配aaa而不是空、a或者aa，这种希望匹配的更多行为就叫做贪婪。我们可以用a\</em>?来取消贪婪模式变为最小匹配，那个这个模式串只匹配空。a+?只匹配a、</p>
</blockquote>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/Chapter [<span class="number">1</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]*</span><br><span class="line">匹配</span><br><span class="line">    /Chapter <span class="number">1</span>-无穷</span><br><span class="line">解释：章节一般从<span class="number">1</span>开始到无穷结束，因此用*限定[<span class="number">0</span>-<span class="number">9</span>]能出现&#123;<span class="number">0</span>,&#125;次</span><br></pre></td></tr></table></figure>

<h4 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h4><p>​    正则表达式中用来表示位置的符号。有时我们需要对某个位置进行限定，所以正则表达式提供了定位符。比如有时我们只想匹配app而不像匹配application中的app，此时我们就需要对位置进行限定，要求app前后均是空格，所以可以用”\bapp\b”来匹配。这样就可以把全文的app取出来，而不会取出application中的app。</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">^</td>
<td align="left">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">匹配一个字边界，即字与空格间的位置。<img src="/2022/05/28/Java-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/1652585837142.png" alt="1652585837142"></td>
</tr>
<tr>
<td align="left">\B</td>
<td align="left">非字边界匹配。即这个位置边界外是字符<img src="/2022/05/28/Java-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/1652585822991.png" alt="1652585822991"></td>
</tr>
</tbody></table>
<h4 id="选择符"><a href="#选择符" class="headerlink" title="选择符"></a>选择符</h4><p>​    正则表达式有时需要条件判断这种结构的模式匹配来构成最终的正则表达式，因此正则中支持选择符</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>|</td>
<td>|前后的内容最终只有一个作为匹结果对应的模式串，两者是或的关系</td>
</tr>
<tr>
<td><em>x</em>|<em>y</em></td>
<td>匹配 <em>x</em> 或 <em>y</em>。例如，’z|food’ 匹配”z”或”food”。’(z|f)ood’ 匹配”zood”或”food”。</td>
</tr>
</tbody></table>
<h4 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h4><p>​    有时我们需要在正则表达式中使用正则表达式的匹配结果，比如找到需求：找到昵称名就是姓名的字符串。因此正则表达式提供了反向引用，使得正则表达式中也可以引用已经匹配的字符串。反向引用的下标从1开始，一般与子表达式符号连用，遇到一个左括号，下标加1，比如”\b([a-z]+) \1\b”其中的\1表示第一个子表达式”([a-z]+)”匹配的字符串。</p>
<p>下面我们来完成需求：找到昵称名就是姓名的字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#39;s nickname is a</span><br><span class="line">xiaobai&#39;s nickname is xb</span><br><span class="line">对应的模式串为</span><br><span class="line">\b([a-zA-Z]+)&#39;s nickname is \1\b</span><br><span class="line">匹配的结果为</span><br><span class="line">a&#39;s nickname is a</span><br></pre></td></tr></table></figure>

<p>此外反向引用还可以将URI拆分成组件</p>
<p> 假定您想将下面的 URI 分解为协议（ftp、http 等等）、域地址和页/路径： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http://www.w3cschool.cn:80/html/html-tutorial.html</span><br></pre></td></tr></table></figure>

<p>对应的正则为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)</span><br></pre></td></tr></table></figure>

<p> 第一个括号子表达式捕获 Web 地址的协议部分。该子表达式匹配在冒号和两个正斜杠前面的任何单词。 </p>
<p>​    第一个子表达式匹配的字符串是”http”</p>
<p> 第二个括号子表达式捕获地址的域地址部分。子表达式匹配 / 或 : 之外的一个或多个字符。</p>
<p>​    第二个表达式匹配的字符串是”<a href="http://www.w3cschool.cn&quot;">www.w3cschool.cn&quot;</a></p>
<p>第三个括号子表达式捕获端口号（如果指定了的话）。该子表达式匹配冒号后面的零个或多个数字。只能重复一次该子表达式。</p>
<p>​    第三个表达式匹配的字符串是”:80”，由于后面接着?所以可以没有这个字符串</p>
<p>第四个括号子表达式捕获 Web 地址指定的路径和/或页信息。该子表达式能匹配不包括 # 或空格字符的任何字符序列。 </p>
<p>​    第四个表达式匹配的字符串是” /html/html-tutorial.html “</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>\xn</code></td>
<td align="left">匹配 <em>n</em>，此处的 <em>n</em> 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，”\x41”匹配”A”。”\x041”与”\x04”&amp;”1”等效。允许在正则表达式中使用 ASCII 代码。</td>
</tr>
<tr>
<td align="center"><code>num</code></td>
<td align="left">匹配 <em>num*，此处的 *num</em> 是一个正整数。到捕获匹配的反向引用。例如，”(.)\1”匹配两个连续的相同字符。</td>
</tr>
<tr>
<td align="center"><code>n</code></td>
<td align="left">标识一个八进制转义码或反向引用。如果 <em>n</em> 前面至少有 <em>n</em> 个捕获子表达式，那么 <em>n</em> 是反向引用。否则，如果 <em>n</em> 是八进制数 (0-7)，那么 <em>n</em> 是八进制转义码。</td>
</tr>
<tr>
<td align="center"><code>nm</code></td>
<td align="left">标识一个八进制转义码或反向引用。如果 <em>nm</em> 前面至少有 <em>nm</em> 个捕获子表达式，那么 <em>nm</em> 是反向引用。如果 <em>nm</em> 前面至少有 <em>n</em> 个捕获，则 <em>n</em> 是反向引用，后面跟有字符 <em>m</em>。如果两种前面的情况都不存在，则 <em>nm</em> 匹配八进制值 <em>nm*，其中 *n</em> 和 <em>m</em> 是八进制数字 (0-7)。</td>
</tr>
<tr>
<td align="center"><code>\nml</code></td>
<td align="left">当 <em>n</em> 是八进制数 (0-3)，<em>m</em> 和 <em>l</em> 是八进制数 (0-7) 时，匹配八进制转义码 <em>nml</em>。</td>
</tr>
<tr>
<td align="center"><code>\un</code></td>
<td align="left">匹配 <em>n</em>，其中 <em>n</em> 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</td>
</tr>
</tbody></table>
<h2 id="正则表达式工具推荐"><a href="#正则表达式工具推荐" class="headerlink" title="正则表达式工具推荐"></a>正则表达式工具推荐</h2><p>​    <img src="/2022/05/28/Java-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/1652604705418.png" alt="1652604705418"></p>
<h2 id="Java中如何使用正则？"><a href="#Java中如何使用正则？" class="headerlink" title="Java中如何使用正则？"></a>Java中如何使用正则？</h2><p>​    不同的编程语言，对正则表达式的支持程度不同，编写的正则表达式一般也不同。我们这里仅考虑Java实现的正则。</p>
<p>​    Java中主要提供了Pattern类、Matcher类、PatternSyntaxExcaption类来做到正则表达式的匹配如语法检查。 pattern 对象是一个正则表达式的编译表示；Matcher 对象是对输入字符串进行解释和匹配操作的引擎；PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。 </p>
<blockquote>
<p> <em>根据 Java Language Specification 的要求，Java 源代码的字符串中的反斜线被解释为 Unicode 转义或其他字符转义。因此必须在字符串字面值中使用两个反斜线，表示正则表达式受到保护，不被 Java 字节码编译器解释。例如，当解释为正则表达式时，字符串字面值 “\b” 与单个退格字符匹配，而 “\\b” 与单词边界匹配。字符串字面值 “<code>\(hello\)</code>“ 是非法的，将导致编译时错误；要与字符串 (hello) 匹配，必须使用字符串字面值 “\\(hello\\)”。</em> </p>
</blockquote>
<p> <img src="/2022/05/28/Java-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/c182dd874f2e4c4baaf1806d54bf9cfc.png" alt="img"> </p>
<h3 id="Pattern类"><a href="#Pattern类" class="headerlink" title="Pattern类"></a>Pattern类</h3><blockquote>
<p>Pattern类在java.util.regex 包中 ，且是正则表达式的编译表示形式；<br>Pattern类由final修饰，因此不能被子类继承；<br>Pattern类的实例不可变，可供多个并发线程安全使用；<br>Pattern的构造器是私有的，只能通过Pattern调用静态方法compile返回Pattern实例。</p>
</blockquote>
<p> <strong>Pattern compile(String regex)：</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pattern <span class="title">compile</span><span class="params">(String regex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pattern(regex, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>Pattern compile(String regex, int flags)：</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pattern <span class="title">compile</span><span class="params">(String regex, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pattern(regex, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>flag可取值</p>
<ul>
<li><strong>Pattern.UNIX_LINES：</strong>unix lines模式，该模式下，仅以\n为结尾（行一般以\n或\r\n结尾）；</li>
<li><strong>Pattern.CASE_INSENSITIVE：</strong>忽略大小写进行匹配；</li>
<li><strong>Pattern.COMMENTS：</strong>忽略空格字符（例如，表达式里的空格，tab，回车）和注释（从#开始，一直到行结束）；</li>
<li><strong>Pattern.MULTILINE：</strong>多行模式的开启，在多行模式下，^匹配输入字符串开始的位置，$匹配输入字符串结尾的位置；</li>
<li><strong>Pattern.DOTALL：</strong>dotall模式，”.”匹配所有字符，包括行终结符。（若该模式未开启，“.”表达式不匹配行终结符）；</li>
<li><strong>Pattern.UNICODE_CASE：</strong>UNICODE_CASE模式结合CASE_INSENSITIVE模式，那么它会对Unicode字符进行大小写不敏感的匹配。（若未开启UNICODE_CASE模式，仅开始CASE_INSENSITIVE模式，则只适用于US-ASCII字符集）；</li>
<li><strong>Pattern.CANON_EQ：</strong>当且仅当两个字符的正规分解都完全相同的情况下，则认定匹配。（默认情况下，不考虑规范相等性）；</li>
</ul>
</blockquote>
<p><strong>String[] split(CharSequence input, int limit)</strong> </p>
<blockquote>
<p> input 要拆分的字符序列</p>
<p> ​    limit 结果阈值，控制应用模式的次数，从而影响结果数组的长度</p>
<p> ​        若 limit &gt; 0：split最多应用limit - 1次，数组的长度不大于limit；常常匹配结果中出现空字符串。</p>
<p> ​        若 limit &lt; 0：split次数不受限制，数组为任意长度；</p>
<p> ​        若 limit = 0：split次数不受限制，数组为任意长度，但会摒弃尾部的空字符串；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pattern pattern= Pattern.compile(<span class="string">"\\d&#123;2&#125;"</span>);</span><br><span class="line">String[] split = pattern.split(<span class="string">"12a2"</span>);<span class="comment">//""、"a2"</span></span><br></pre></td></tr></table></figure>

<p> <strong>boolean Pattern.matches(String regex,CharSequence input)</strong> </p>
<p>​    判断regex是否能匹配到input中的所有字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Pattern.matches(<span class="string">"\\d+"</span>, <span class="string">"aa123456"</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h3 id="Matcher类"><a href="#Matcher类" class="headerlink" title="Matcher类"></a>Matcher类</h3><p>​     Matcher 对象是对输入字符串进行解释和匹配操作的引擎，与Pattern 类一样，Matcher 也没有公共构造方法； </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pattern pattern = Pattern.compile(<span class="string">"正则表达式"</span>);</span><br><span class="line">Matcher matcher = pattern.matcher(<span class="string">"目标字符串"</span>);</span><br></pre></td></tr></table></figure>

<p><strong>1、查找方法</strong></p>
<ul>
<li>find()：只要正则表达式在字符串被匹配到就返回true</li>
<li>lookingAt()：只有匹配到的字符串在最前面，返回true，否则，false（即，匹配到的字符串部分必须在首位）</li>
<li>matches(): 对整个字符串进行匹配,若整个字符串都匹配，返回true，否则，false（即，整个字符串全部匹配）</li>
</ul>
<p><strong>2、索引方法</strong>，这些方法必须结合(matcher.find()方法使用</p>
<ul>
<li>start(): 返回匹配到的子字符串的第一个字符在原字符串中的索引位置</li>
<li>end(): 返回匹配到的子字符串的最后一个字符在原字符串中的索引位置</li>
<li>group(): 返回匹配到的子字符串，是整个正则表达式匹配到的字符串，相当于group(0)的返回值</li>
<li>groupCount()  : 返回捕获组的数量，除去了全局字符串匹配到的捕获组。</li>
<li>start(int i): 匹配到的第i个捕获组组第一个字符索引</li>
<li>end(int i): 匹配到的第i个捕获组最后一个字符索引</li>
<li>group(int i): 匹配到的第i个捕获组</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">String text = <span class="string">"aaasdas&lt;textarea rows=\"20\" cols=\"70\"&gt;nexus maven repository index properties updating index central&lt;/textarea&gt;"</span>;</span><br><span class="line"><span class="comment">//下面的正则表达式中共有四个捕获组：(&lt;textarea.*?&gt;)、(.*?)、(&lt;/textarea&gt;)和整个匹配到的内容</span></span><br><span class="line">String reg = <span class="string">"(&lt;textarea.*?&gt;)(.*?)(&lt;/textarea&gt;)"</span>;</span><br><span class="line">Pattern p = Pattern.compile(reg);</span><br><span class="line">Matcher m = p.matcher(text);</span><br><span class="line">System.out.println(m.find());<span class="comment">//true，字符串中能匹配到，返回true</span></span><br><span class="line">System.out.println(m.lookingAt());<span class="comment">//false，匹配到的字符串不在首位</span></span><br><span class="line">System.out.println(m.matches());<span class="comment">//false，因为整个字符串不符合这个模式串</span></span><br><span class="line"><span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">    System.out.println(m.group(<span class="number">0</span>)); <span class="comment">// 整个匹配到的内容</span></span><br><span class="line">    System.out.println(m.group(<span class="number">1</span>)); <span class="comment">// (&lt;textarea.*?&gt;)</span></span><br><span class="line">    System.out.println(m.group(<span class="number">2</span>)); <span class="comment">// (.*?)</span></span><br><span class="line">    System.out.println(m.group(<span class="number">3</span>)); <span class="comment">// (&lt;/textarea&gt;)</span></span><br><span class="line">&#125;</span><br><span class="line">如果不想要捕获某个组，只需要将(变为(?:即可，还有方便的写法 (&lt;textarea.*?&gt;)(?&lt;data&gt;.*?)(&lt;/textarea&gt;) 在正则表达式中加一个变量 data 然后在 group 获取 string str = m.group(“data”);相当于中间那个捕获组的名字叫做data。</span><br></pre></td></tr></table></figure>

<p><strong>3、替换方法</strong></p>
<ul>
<li><p>replace(CharSequence target, CharSequence replacement)：用replacement替换所有的target，两个参数都是字符串；</p>
</li>
<li><p>replaceAll(String regex, String replacement)：用replacement替换所有的regex匹配项，regex是正则表达式，</p>
<p>replacement是字符串；</p>
</li>
<li><p>replaceFirst(String regex, String replacement)：基本和replaceAll相同，区别是只替换第一个匹配项；</p>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>限流相关总结</title>
    <url>/2022/07/06/%E9%99%90%E6%B5%81%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>​    <a id="more"></a></p>
<p>!!!! 本文章为个人知识成果，转载请注明出处。文中涉及的部分内容，是我从网络上抄过来加以自己理解的。</p>
<h2 id="为什么要限流？"><a href="#为什么要限流？" class="headerlink" title="为什么要限流？"></a>为什么要限流？</h2><p>随着业务逻辑的复杂化，一个庞大的系统必然会不断的被拆分成多个独立的模块，不同的模块之间依赖关系越来越紧密，那么就要求了不同模块的<strong>高稳定性</strong>，即对于突发的请求，相关模块也能稳定的处理，保证正常工作。这种稳定性往往需要<strong>缓存、限流、熔断降级、负载均衡等多种组合拳</strong>应对。</p>
<h2 id="限流的相关概念？"><a href="#限流的相关概念？" class="headerlink" title="限流的相关概念？"></a>限流的相关概念？</h2><p>阈值：一个单位时间内服务器能处理的请求数。</p>
<p>窗口：一个单位时间。</p>
<p>QPS：每秒查询数。</p>
<p>TPS：每秒事务数，即每秒写入数。</p>
<p>RPS：每秒请求数。</p>
<p>并发数：某一个时刻，进入系统内执行的请求个数。</p>
<p>拒绝策略：对于无法处理的请求，服务器所作的应对。常见的拒绝策略有：直接拒绝、排队等候等。</p>
<h2 id="限流的相关手段？"><a href="#限流的相关手段？" class="headerlink" title="限流的相关手段？"></a>限流的相关手段？</h2><h3 id="合法性验证限流"><a href="#合法性验证限流" class="headerlink" title="合法性验证限流"></a>合法性验证限流</h3><p>比如验证码、IP黑名单等直接限制某些人恶意访问网站的方式。</p>
<h3 id="容器限流"><a href="#容器限流" class="headerlink" title="容器限流"></a>容器限流</h3><p>即运行项目的某些容器对外部的请求数进行限制。</p>
<ul>
<li><p>Tomcat设置最大线程数【请求数超过最大线程数，多余的请求采取排队等候拒绝策略】</p>
<p>在Tomcat的conf/server.xml文件中配置最大线程数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;Connector port=<span class="string">"8080"</span> protocol=<span class="string">"HTTP/1.1"</span></span><br><span class="line">          connectionTimeout=<span class="string">"20000"</span></span><br><span class="line">          maxThreads=<span class="string">"150"</span></span><br><span class="line">          redirectPort=<span class="string">"8443"</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中设置并发的线程最大数字为150，对于这些线程无法处理的新的请求，暂时放到队列中等待。</p>
<p>tip：Windows中的最大线程数是 2000 ， Linux中最大线程数是 1000 。且没开启一个线程 JVM 都会分配 1m 内存空间给该线程，并且GC 压力变大，所以线程数不是越多越好。</p>
</li>
<li><p>Nginx设置请求速率以及并发连接数</p>
<ul>
<li>控制速率：在nginx的配置文件 nginx.conf 设置一个 ip 单位时间内的请求数，即请求速率。但是这种方式（如下代码1）对速率的要求太过苛刻。而且这种方式默认采取的拒绝策略是抛弃。还有一种拒绝策略</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  limit_req_zone $binary_remote_addr zone=mylimit:10m rate=2r/s;</span><br><span class="line">  server &#123; </span><br><span class="line">    location / &#123; </span><br><span class="line">      limit_req zone=mylimit burst=5;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  参数详解（可能有误，待我系统学习 nginx 后再来补充）</span><br><span class="line">limit_req_zone </span><br><span class="line">  ` 定义流量限制相关的参数的指令</span><br><span class="line">    $binary_remote_addr </span><br><span class="line">      ` 远程访问服务器的 ip 地址</span><br><span class="line">    zone=mylimit:10m  </span><br><span class="line">      · 开辟一个内存空间为10m的名字叫做 mylimit的区域存储统计频次相关信息</span><br><span class="line">      rate=2r/s  </span><br><span class="line">      · 单个 ip 地址 每秒 允许 2 个请求被处理，还有其他单位的 30r/m 单个ip 没分钟能处理 30个请</span><br><span class="line">  	求</span><br><span class="line">  limit_req</span><br><span class="line">  ` 在所配置的上下文中开启限流的指令，比如上面的代码就是对服务器的所有请求进行限流</span><br><span class="line">  zone=mylimit</span><br><span class="line">  ` 配置使用上面的统计区域内存空间</span><br><span class="line">  burst=5</span><br><span class="line">  ` 配置当有大量的请求到达的时候，显然，对于不能对所有超过rate比率的请求一概抛弃，返回503，服务暂时不可用，burst就是为了弥补这个缺点，burst=5,开启一个长度为5的请求队列，对于超过请求速率的请求可以放到这个队列中等待被处理。以上的这些nginx配置，底层使用了令牌桶算法。</span><br><span class="line">  nodelay</span><br><span class="line">  对于超过请求速率处理能力并且还大于请求队列数burst的请求，采取的策略，如果写了nodelay，那么nginx 会认为服务器有能力 单位时间内处理 burst + rate个请求，所以对于超过请求队列数的请求直接抛弃，返回503（服务暂时不可用）。如果没写 nodelay 则超过后来的请求会追加到请求队列中，但是请求队列长度保持不变。对于出队了，却无能力处理的请求直接返回（503 服务暂时不可用）。如果有能力处理则处理该请求。</span><br></pre></td></tr></table></figure>

<p>具体 nginx 配置以及测试用例可以看<a href="https://blog.csdn.net/hellow__world/article/details/78658041">这里</a></p>
<ul>
<li><p>控制单个ip 单位时间能够持有的连接数，以及服务器能够处理并发连接的总数。</p>
<p>与tomcat同样的作用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">limit_conn_zone $binary_remote_addr zone=perip:10m;</span><br><span class="line">limit_conn_zone $server_name zone=perserver:10m;</span><br><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    limit_conn perip 10; # 每个ip某个时刻持有的最大连接数</span><br><span class="line">    limit_conn perserver 100; # server同时能够处理的最大连接数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="服务器端限流"><a href="#服务器端限流" class="headerlink" title="服务器端限流"></a>服务器端限流</h3><p>也就是自己编写代码，在服务器中进行请求限流操作。</p>
<h4 id="常见限流算法？"><a href="#常见限流算法？" class="headerlink" title="常见限流算法？"></a>常见限流算法？</h4><ul>
<li>固定窗口算法</li>
</ul>
<p>设计每秒允许通过的请求数（即 qps ,每秒请求数，也就是所谓的阈值），一秒内请求数超过这个值的请求直接丢弃。然后在一秒末，重新进行计数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022/6/28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@blog</span>: zhuming-github.github.io</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: v1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器 限流算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterLimiter</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 上次窗口的结束时间，也就是本次窗口的开始时间</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> lasterWindowEnd;</span><br><span class="line">  <span class="comment">// 本次窗口的大小</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> interval;</span><br><span class="line">  <span class="comment">// 本次窗口的请求阈值</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> requestPerwindow;</span><br><span class="line">  <span class="comment">// 本次窗口内的计数器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> counter;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CounterLimiter</span><span class="params">(LocalDateTime lasterWindowEnd, <span class="keyword">int</span> second, <span class="keyword">int</span> requestPerwindow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lasterWindowEnd = lasterWindowEnd.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">    <span class="keyword">this</span>.interval = second;</span><br><span class="line">    <span class="keyword">this</span>.counter = requestPerwindow;</span><br><span class="line">    <span class="keyword">this</span>.requestPerwindow = requestPerwindow;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认是 时间窗口为 5s ,窗口可以处理100个请求。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CounterLimiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(LocalDateTime.now(), <span class="number">5</span>, <span class="number">50</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 控制线程单独进入</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在一秒内就计数，并判断是否接受该请求</span></span><br><span class="line">    <span class="keyword">long</span> now = LocalDateTime.now().toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">    <span class="keyword">synchronized</span> (CounterLimiter<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> ((now - lasterWindowEnd) &gt;= interval) &#123;</span><br><span class="line">        <span class="keyword">this</span>.counter = <span class="keyword">this</span>.requestPerwindow;</span><br><span class="line">        <span class="keyword">this</span>.lasterWindowEnd = now;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.counter-- &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<p>使用Jmeter进行测试(10秒钟1000次)，测试自己编写的如下接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Counter.checker()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login success"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login failure"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/06/%E9%99%90%E6%B5%81%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/1657120897983.png" alt="1657120897983"></p>
<p>注意：使用Jemter发送的所有请求中不一定会出现 正确的比例/错误的比例 =  时间比的情况。这是因为 请求可能在任何一个时间点到达，所以会导致结果比例失调，但是这并不说明算法是错误的。</p>
<p>缺点：如果有人，故意在上一秒的开始不发送任何请求，然后再上一秒末尾发送最大的请求数，然后在下一秒开始发送最大的请求数，那么就相当于服务器在一秒时间内要处理，两倍的最大请求数，可能会导致系统崩溃。即如下图。</p>
<p><img src="/2022/07/06/%E9%99%90%E6%B5%81%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/1657120931816.png" alt="1657120931816"></p>
<ul>
<li>滑动窗口算法 </li>
</ul>
<p>由于计数器算法的窗口在时间间隔内是不会变动的，这种粗犷的窗口计算方法，会导致如上图的那种一个窗口内出现两倍最大请求数要处理的情况，那么我们就需要对窗口进行进一步的细分，最好使得它处理完一个时间片段后就向后滑动一下窗口，这样，如上图那种的情况就会被算法处理到了，那么那一秒内的一半请求就会被抛弃掉，不会导致服务器崩溃。但是这种算法极限情况下也会出现上一种情况的。阿里的Sentinel就是采用这种算法实现的限流。下面只给出了具体的伪代码实现步骤，这个算法实现起来比较复杂，我没精力搞了。</p>
<p> <img src="/2022/07/06/%E9%99%90%E6%B5%81%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/20210104165710238.png" alt="img"> </p>
<p>通过一个线程进行滑动窗口滑动的算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlidingWindowRateLimit</span> <span class="keyword">implements</span> <span class="title">RateLimit</span>, <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 窗口内的请求阈值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer limitCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前窗口通过的请求数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger passCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 窗口中时间间隔数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer windowSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每个窗口时间间隔大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> windowPeriod;</span><br><span class="line">    <span class="keyword">private</span> TimeUnit timeUnit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Window[] windows;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Integer windowIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SlidingWindowRateLimit</span><span class="params">(Integer limitCount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 默认统计qps, 窗口大小5</span></span><br><span class="line">        <span class="keyword">this</span>(limitCount, <span class="number">5</span>, <span class="number">200</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计总时间 = windowSize * windowPeriod</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SlidingWindowRateLimit</span><span class="params">(Integer limitCount, Integer windowSize, Integer windowPeriod, TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.limitCount = limitCount;</span><br><span class="line">        <span class="keyword">this</span>.windowSize = windowSize;</span><br><span class="line">        <span class="keyword">this</span>.windowPeriod = windowPeriod;</span><br><span class="line">        <span class="keyword">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="keyword">this</span>.passCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.initWindows(windowSize);</span><br><span class="line">        <span class="keyword">this</span>.startResetTask();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPass</span><span class="params">()</span> <span class="keyword">throws</span> BlockException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">if</span> (passCount.get() &gt; limitCount) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        windows[windowIndex].passCount.incrementAndGet();</span><br><span class="line">        passCount.incrementAndGet();</span><br><span class="line">        lock.unlock();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initWindows</span><span class="params">(Integer windowSize)</span> </span>&#123;</span><br><span class="line">        windows = <span class="keyword">new</span> Window[windowSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; windowSize; i++) &#123;</span><br><span class="line">            windows[i] = <span class="keyword">new</span> Window();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ScheduledExecutorService scheduledExecutorService;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startResetTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">this</span>, windowPeriod, windowPeriod, timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前窗口索引</span></span><br><span class="line">        Integer curIndex = (windowIndex + <span class="number">1</span>) % windowSize;</span><br><span class="line">        log.info(<span class="string">"info_reset_task, curIndex = &#123;&#125;"</span>, curIndex);</span><br><span class="line">        <span class="comment">// 重置当前窗口索引通过数量，并获取上一次通过数量</span></span><br><span class="line">        Integer count = windows[curIndex].passCount.getAndSet(<span class="number">0</span>);</span><br><span class="line">        windowIndex = curIndex;</span><br><span class="line">        <span class="comment">// 总通过数量 减去 当前窗口上次通过数量</span></span><br><span class="line">        passCount.addAndGet(-count);</span><br><span class="line">        log.info(<span class="string">"info_reset_task, curOldCount = &#123;&#125;, passCount = &#123;&#125;, windows = &#123;&#125;"</span>, count, passCount, windows);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> AtomicInteger passCount;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Window</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.passCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>漏桶算法</p>
<p>水（请求）从进水口进入到漏桶（服务器处理中的集合）里，漏桶以一定的速度出水（请求放行），当水流入速度过大，桶内的总水量大于桶容量会直接溢出，请求被拒绝。 漏桶算法，相当于把服务器的处理请求的能力（处理速率）看作出水的速度。服务器可处理的并发数的大小看作桶的大小，这种算法忽略了服务器对于大量的突发请求的处理能力，只使用了服务器正常工作水平。</p>
</li>
</ul>
<p><img src="/2022/07/06/%E9%99%90%E6%B5%81%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/1657495915381.png" alt="1657495915381"></p>
<p>漏桶算法的优点：能有效的进行削峰（ 有大量流量进入时,会发生溢出,从而限流保护服务可用 ），缓冲（ 不至于直接请求到服务器, 缓冲压力 ）。</p>
<p>漏桶算法的不足： 漏桶的出水速度固定，也就是请求放行速度是固定的， 不能灵活的应对后端能力提升，如果服务器处理能力经常变动，漏桶无法做到充分利用服务器处理能力的技术。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rate 即使服务器处理请求的速度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeakBucketLimiter</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 桶的总容量 个</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> capacity;</span><br><span class="line">  <span class="comment">// 流出速率 个/s</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> outRate;</span><br><span class="line">  <span class="comment">// 每次请求的开始时间 ms</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> startTime;</span><br><span class="line">  <span class="comment">// 桶中剩余的水量 个</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> remainWater;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LeakBucketLimiter</span><span class="params">(<span class="keyword">long</span> capacity, <span class="keyword">long</span> outRate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    <span class="comment">// 设置桶的流出速率，保持向下取整，，保留一位小数</span></span><br><span class="line">    <span class="keyword">this</span>.outRate = outRate;</span><br><span class="line">    startTime = LocalDateTime.now().toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果桶中没有水了，则直接将水放入桶中，允许其执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == <span class="keyword">this</span>.remainWater) &#123;</span><br><span class="line">      <span class="keyword">this</span>.remainWater = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">this</span>.startTime = System.currentTimeMillis();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//桶中有水，则先排水，然后将水放入桶中。</span></span><br><span class="line">    <span class="keyword">long</span> interval = System.currentTimeMillis() - startTime;</span><br><span class="line">    <span class="keyword">this</span>.remainWater = Math.max((<span class="keyword">this</span>.remainWater - (interval / <span class="number">1000</span>) * <span class="keyword">this</span>.outRate), <span class="number">0</span>);</span><br><span class="line">    System.out.println(<span class="keyword">this</span>.remainWater);</span><br><span class="line">    <span class="keyword">this</span>.startTime += interval / <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">// 水满则拒绝加水</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.remainWater &gt; <span class="keyword">this</span>.capacity) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.remainWater++;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>令牌桶算法</li>
</ul>
<p>相较于漏桶算法，令牌桶算法关注水流的流入速率，以恒定的速度向桶中放入令牌，无论请求何时到达，只要桶中有令牌就放行，如果令牌的发放速度慢于请求的到来速度，那么桶内的令牌就会被消耗殆尽，从而请求被拒绝，这种算法可以做到，请求突发时，对应的流出速率变高，请求减少时，对应的流出速率变低，合理充分的使用服务器资源，进行恰到好处的限流。谷歌的 Guava  开源工具包就是使用了这种算法实现限流。</p>
<p><img src="/2022/07/06/%E9%99%90%E6%B5%81%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/1657522526728.png" alt="1657522526728"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenBucketLimiter</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 令牌桶的总大小</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> capacity;</span><br><span class="line">  <span class="comment">// 每秒生成的令牌数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> rate_Count_Per_Second = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 上次放令牌的时间</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> lastPutTime;</span><br><span class="line">  <span class="comment">// 桶中令牌总数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> tokenNum;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TokenBucketLimiter</span><span class="params">(<span class="keyword">long</span> capacity, <span class="keyword">long</span> rate_Count_Per_Second)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    <span class="keyword">this</span>.rate_Count_Per_Second = rate_Count_Per_Second;</span><br><span class="line">    <span class="keyword">this</span>.lastPutTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">this</span>.tokenNum = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * true 代表放行，请求可已通过</span></span><br><span class="line"><span class="comment">   * false 代表限制，不让请求通过</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//更新桶中剩余令牌的数量</span></span><br><span class="line">    <span class="keyword">long</span> interval = System.currentTimeMillis() - lastPutTime;</span><br><span class="line">    <span class="comment">//更新时间</span></span><br><span class="line">    tokenNum = Math.min(capacity, tokenNum + interval / <span class="number">1000</span> * rate_Count_Per_Second);</span><br><span class="line">    lastPutTime += (interval) / <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">//桶中还有令牌就放行</span></span><br><span class="line">    <span class="keyword">if</span> (tokenNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      tokenNum--;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>后端</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title>表达式算法介绍</title>
    <url>/2022/06/20/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>​    <a id="more"></a></p>
<p>!!!! 本文章为个人知识成果，转载请注明出处。</p>
<p>世界上的算术表达式有三种：前缀表达式、中缀表达式、后缀表达式（也叫逆波兰表达式），前缀表达式与后缀表达式由于操作符将操作隔离在一起，因此不会有歧义，但是中缀表达式，由于操作数被操作符隔开导致可能出现歧义（比如3+2<em>3，设想一下如果+与\</em>同级别，那么结果是不是有两种可能【9、15】）,因此中缀表达式引入了括号以及操作符优先级来保证算术的无歧义性。</p>
<p>可以通过构造一个表达式的二叉树，然后先序、中序、后序遍历分别得到前缀、中缀、后缀表达式。</p>
<h4 id="表达式树"><a href="#表达式树" class="headerlink" title="表达式树"></a>表达式树</h4><p><img src="/2022/06/20/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/1655738085390.png" alt="1655738085390"></p>
]]></content>
      <categories>
        <category>后端</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2022/06/21/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>​    <a id="more"></a></p>
<p>!!!! 本文章为个人知识成果，转载请注明出处。</p>
<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><p>依据选择的贪心策略，只注重局部最优解，以期望取得全局最优解。</p>
<p>有时局部最优可以推出全局最优，但是有时局部最优不可以推出全局最优，关键是如何看出局部最优能否推出全局最优，这种没有固定的套路，只能<strong>自己进行简单的推导，然后自己举反例证明贪心不行，如果举不出反例，则贪心算法的反例则证明此贪心算法可行</strong>。</p>
<h2 id="贪心算法适用问题的特性"><a href="#贪心算法适用问题的特性" class="headerlink" title="贪心算法适用问题的特性"></a>贪心算法适用问题的特性</h2><ul>
<li><p>最优子结构性质：一个问题的最优解包含了其子问题的最优解</p>
</li>
<li><p>贪心选择性质：所有问题的整体最优解，可以通过一系列的局部最优解的选择来达成。</p>
<blockquote>
<p>首先假设一个该问题的最优解，然后假定该最优解的首元素不是贪心选择所需要的元素，证明将其首元素替换成贪心选择所需元素后的解，依然是最优解。然后使用数学归纳法证明每一个 。</p>
</blockquote>
</li>
</ul>
<h2 id="贪心算法求解步骤"><a href="#贪心算法求解步骤" class="headerlink" title="贪心算法求解步骤"></a>贪心算法求解步骤</h2><ol>
<li>分析问题，设计数据找规律 ，找到合适的贪心策略</li>
<li>证明使用此种贪心选择策略的贪心算法的可行性，证明方法如上。</li>
<li>依据贪心策略，对每一个子问题求解出局部最优解。</li>
</ol>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="活动选择问题"><a href="#活动选择问题" class="headerlink" title="活动选择问题"></a>活动选择问题</h3><p><img src="/2022/06/21/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/1655820657493.png" alt="1655820657493"></p>
<p>解决：</p>
<ul>
<li><p>选择合适的贪心策略（即贪心的点）：</p>
<blockquote>
<ol>
<li><p>如果按照<strong>开始时间最早</strong>作为贪心策略。由于选择开始时间最早的事务，由于其结束时间不确定，因此无法保证后续剩余时间的最多的事务。如下图，如果你选择了最早开始的蓝色事务，那么下面的较晚开始的两个事务就无法选择，最终求出来的也不是最优解。</p>
<p><img src="/2022/06/21/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/1655818217246.png" alt="1655818217246"></p>
</li>
<li><p>如果按照<strong>事务持续时间最少</strong>作为贪心标准。那么由于选择最少的事务的开始时间没法确定，那么导致浪费了大量的时间，所以这种策略也是不行的。</p>
<p><img src="/2022/06/21/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/1655821088468.png" alt="1655821088468"></p>
</li>
<li><p>如果选择<strong>事务结束时间最早</strong>的事务，那么按照常理，事务结束时间越早，后续留出的时间越多，可以安排的事务也就越多，所以这种贪心策略是可以考虑的。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>证明选择事务结束时间最早的事务的贪心策略的可行性</p>
<blockquote>
<ul>
<li>贪心选择性质证明：假设最终的一个最优解是A，A中的事务按照结束时间进行非递减排列，假设排序后的A的第一个事务是K。而我们通过贪心选择策略选择的第一个活动记为k。<ul>
<li>如果事务K就是事务k，则最优解A就是以事务k开始的。</li>
<li>如果事务K不是事务k，那么由于事务k是按照事务结束时间求出的最小的事务，那么事务k的结束时间必然是在事务K结束时间的前面或者就是事务K的结束时间的，则证明事务k替换掉最优解中的事务K，也能够替换后的解A仍然是最优解，则证明了该问题具有贪心选择性质。</li>
</ul>
</li>
<li>最优子结构性质证明：由于A是最优解，所以在上一个性质的证明中，如果直接去除掉事务K即$A^`=A-{K}$，仍然是子问题：”<strong>去除掉事务K之后的活动安排</strong>“的最优解。则证明问题具有最优子结构性质。</li>
</ul>
</blockquote>
</li>
<li><p>解决问题</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HJM1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line">    Time begin;</span><br><span class="line">    Time end;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Activity</span><span class="params">(Time begin,Time end)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.begin = begin;</span><br><span class="line">      <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> ToStringBuilder.reflectionToString(<span class="keyword">this</span>, ToStringStyle.SHORT_PREFIX_STYLE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建活动数组</span></span><br><span class="line">Activity activitys[] = <span class="keyword">new</span> Activity[<span class="number">11</span>];</span><br><span class="line">activitys[<span class="number">0</span>] =  <span class="keyword">new</span> Activity(Time.valueOf(<span class="string">"01:00:00"</span>),Time.valueOf(<span class="string">"04:00:00"</span>));</span><br><span class="line">activitys[<span class="number">4</span>] =  <span class="keyword">new</span> Activity(Time.valueOf(<span class="string">"03:00:00"</span>),Time.valueOf(<span class="string">"05:00:00"</span>));</span><br><span class="line">activitys[<span class="number">2</span>] =  <span class="keyword">new</span> Activity(Time.valueOf(<span class="string">"00:00:00"</span>),Time.valueOf(<span class="string">"06:00:00"</span>));</span><br><span class="line">activitys[<span class="number">3</span>] =  <span class="keyword">new</span> Activity(Time.valueOf(<span class="string">"05:00:00"</span>),Time.valueOf(<span class="string">"07:00:00"</span>));</span><br><span class="line">activitys[<span class="number">1</span>] =  <span class="keyword">new</span> Activity(Time.valueOf(<span class="string">"03:00:00"</span>),Time.valueOf(<span class="string">"08:00:00"</span>));</span><br><span class="line">activitys[<span class="number">8</span>] =  <span class="keyword">new</span> Activity(Time.valueOf(<span class="string">"05:00:00"</span>),Time.valueOf(<span class="string">"09:00:00"</span>));</span><br><span class="line">activitys[<span class="number">6</span>] =  <span class="keyword">new</span> Activity(Time.valueOf(<span class="string">"06:00:00"</span>),Time.valueOf(<span class="string">"10:00:00"</span>));</span><br><span class="line">activitys[<span class="number">7</span>] =  <span class="keyword">new</span> Activity(Time.valueOf(<span class="string">"08:00:00"</span>),Time.valueOf(<span class="string">"11:00:00"</span>));</span><br><span class="line">activitys[<span class="number">5</span>] =  <span class="keyword">new</span> Activity(Time.valueOf(<span class="string">"08:00:00"</span>),Time.valueOf(<span class="string">"12:00:00"</span>));</span><br><span class="line">activitys[<span class="number">9</span>] =  <span class="keyword">new</span> Activity(Time.valueOf(<span class="string">"02:00:00"</span>),Time.valueOf(<span class="string">"13:00:00"</span>));</span><br><span class="line">activitys[<span class="number">10</span>] =  <span class="keyword">new</span> Activity(Time.valueOf(<span class="string">"12:00:00"</span>),Time.valueOf(<span class="string">"14:00:00"</span>));</span><br><span class="line"><span class="comment">// 对事务数组按照结束时间进行排序</span></span><br><span class="line">Arrays.sort(activitys, <span class="keyword">new</span> Comparator&lt;Activity&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Activity o1, Activity o2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> o1.end.compareTo(o2.end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 利用贪心策略，进行问题求解，并记录一个最优解的结构</span></span><br><span class="line">List&lt;Activity&gt; resultActivitys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Activity preActivity = <span class="keyword">new</span> Activity(Time.valueOf(<span class="string">"00:00:00"</span>),Time.valueOf(<span class="string">"00:00:00"</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; activitys.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (activitys[i].begin.compareTo(preActivity.end)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">    resultActivitys.add(activitys[i]);</span><br><span class="line">    preActivity = activitys[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(resultActivitys);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">------求解出的这一天最多可以进行的活动列表如下</span><br><span class="line">[HJM1.Activity[begin=<span class="number">01</span>:<span class="number">00</span>:<span class="number">00</span>,end=<span class="number">04</span>:<span class="number">00</span>:<span class="number">00</span>], HJM1.Activity[begin=<span class="number">05</span>:<span class="number">00</span>:<span class="number">00</span>,end=<span class="number">07</span>:<span class="number">00</span>:<span class="number">00</span>], HJM1.Activity[begin=<span class="number">08</span>:<span class="number">00</span>:<span class="number">00</span>,end=<span class="number">11</span>:<span class="number">00</span>:<span class="number">00</span>], HJM1.Activity[begin=<span class="number">12</span>:<span class="number">00</span>:<span class="number">00</span>,end=<span class="number">14</span>:<span class="number">00</span>:<span class="number">00</span>]]</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h3 id="国王游戏"><a href="#国王游戏" class="headerlink" title="国王游戏"></a>国王游戏</h3><p>题目:恰逢 H 国国庆，国王邀请 n 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 n 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。</p>
<p>国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。</p>
<blockquote>
<p>题意：国王希望这些大臣中拿到最多金币的大臣的金币数尽可能的少，从而减少总支出。</p>
</blockquote>
<p>【输入】</p>
<blockquote>
<p>第一行包含一个整数 n，表示大臣的人数。</p>
<p>第二行包含两个整数 a和 b，之间用一个空格隔开，分别表示国王左手和右手上的整数。</p>
<p>接下来 n 行，每行包含两个整数 a 和 b，之间用一个空格隔开，分别表示每个大臣左手和右手上的整数。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="number">3</span></span><br><span class="line">&gt;<span class="number">1</span> <span class="number">1</span></span><br><span class="line">&gt;<span class="number">2</span> <span class="number">3</span></span><br><span class="line">&gt;<span class="number">7</span> <span class="number">4</span></span><br><span class="line">&gt;<span class="number">4</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>【输出】</p>
<blockquote>
<p> 一个整数，表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。 </p>
</blockquote>
<p>【输入输出样例说明】</p>
<blockquote>
<p>按 1、2、3 这样排列队伍，获得奖赏最多的大臣所获得金币数为 2；</p>
<p>按 1、3、2 这样排列队伍，获得奖赏最多的大臣所获得金币数为 2；</p>
<p>按 2、1、3 这样排列队伍，获得奖赏最多的大臣所获得金币数为 2；</p>
<p>按 2、3、1这样排列队伍，获得奖赏最多的大臣所获得金币数为 9；</p>
<p>按 3、1、2这样排列队伍，获得奖赏最多的大臣所获得金币数为 2；</p>
<p>按 3、2、1 这样排列队伍，获得奖赏最多的大臣所获得金币数为 9。</p>
<p>因此，奖赏最多的大臣最少获得 2个金币，答案输出 2。</p>
</blockquote>
<p>解决：</p>
<ol>
<li>使用样例数据找规律，推出合适的贪心策略</li>
</ol>
<blockquote>
<p>就拿<img src="/2022/06/21/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/1655996542241.png" alt="1655996542241">举例，如果交换大臣1 和大臣2的位置，你会发现对大臣3的拿到                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        的金币数没影响；如果交换大臣2和大臣3的位置，你会发现，交换后的结果对大臣2拿的金币数没影响。由此我们推出一个结论：相邻两个大臣交换位置，对这两个大臣之外的人拿的金币数是没有影响的。那么相邻两个大臣交换了位置之后，对他们两人的影响如何呢？假设大臣i，左手数字是$a_i$，右手数字是$b_i$；大臣i+1，左手金币数是$a_{i+1}$，右手数字是$b_{i+1}$，那么原本第i个大臣拿的金币数是$m_i=p[i-1]/b_i$，第i+1个大臣拿的金币数是$m_{i+1}=p[i-1]<em>a_i/b_{i+1}$，那么这两个人的最大金币数是$MAX(p[i-1]/b_i，p[i-1]</em>a_i/b_{i+1} )$，同样的计算方法交换位置后的两人的最大金币数为$MAX(p[i-1]/b_{i+1}，p[i-1]<em>a_{i+1}/b_i )$，如果交换后的最大金币数大于交换前的最大金币数，可以推导出一个不等式$a_ib_i&lt;a_{i+1}b_{i+1}$，也就是说如果一开始，两个大臣，达成构成如下条件$a_ib_i&lt;a_{i+1}b_{i+1}$，那么这两个两个人交换位置后的拿的最大金币数变大了，所以这两个人排列的时候，左右手数字乘积小的人排列在前会使得最终两人拿的最大的金币数变少。而且根据冒泡排序那种相邻两两交换的情况，任何两者的交换都可以由一系列的相邻交换组成，所以最终的排列按照*</em>左手右手乘积值升序排列即可** </p>
</blockquote>
<ol start="2">
<li>证明贪心策略的正确性</li>
</ol>
<blockquote>
<p>证明问题具有贪心选择性质</p>
<p>​    如果最优解是A，那么如果事务A的排列的第一个大臣K， 根据贪心策略求出来的第一个大臣是k，如果K就是k，那么则最优解就是以k开始的，则此种情况下最优解具有贪心选择性；如果K不是k，如果用k替换掉K的位置，由于k的乘积是最小的，k加进来后大臣的排列组合中，由于第一个大臣为k，其余大臣仍然是在该种排列下的最大值，所以只需证明k替换K后第二位大臣也是取到该位置上的最小值即可。这点很容易证明。</p>
<p>证明子问题的解结构具有最优解结构</p>
<p>​        如果最优解是A，由于这种最优解是按照左手右手乘积升序排列的，所以去掉了最优解的排列的第一个大臣后，生下来的大臣的排列构成的子问题的最优解结构任然是A中剩余部分，则子问题也具有最优解结构。</p>
</blockquote>
<ol start="3">
<li>编码</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TXSF02</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(People[] peoples, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对这 num 个大臣按照左右手乘积大小，非递减排序</span></span><br><span class="line">    Arrays.sort(peoples, <span class="number">1</span>,num + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 求出最后一位大臣可以取得得金币数目</span></span><br><span class="line">    BigDecimal result = BigDecimal.valueOf(peoples[<span class="number">0</span>].a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num; i++) &#123;</span><br><span class="line">        result = result.multiply(BigDecimal.valueOf(peoples[i].a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.divide(BigDecimal.valueOf(peoples[num].b)).intValue();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> num = scanner.nextInt();</span><br><span class="line">    People[] peoples =<span class="keyword">new</span> People[num+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num+<span class="number">1</span>; i++) &#123;</span><br><span class="line">      peoples[i] = <span class="keyword">new</span> People();</span><br><span class="line">      peoples[i].a = scanner.nextInt();</span><br><span class="line">      peoples[i].b = scanner.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> TXSF02().solve(peoples, num));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">People</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(People o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a * <span class="keyword">this</span>.b - o.a * o.b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>》 这个题目的另一个难点是大数乘法，如果每个大臣的左手数字都是9999，那么最后相乘的位数就是$4*n$位数，其中n是大臣的个数。那么显然这个极容易超过int型数字的最大表示范围值，所以这种数字的计算要用BigDecimal进行。</p>
<h3 id="钱币找零问题"><a href="#钱币找零问题" class="headerlink" title="钱币找零问题"></a>钱币找零问题</h3><p>问题描述</p>
<blockquote>
<p>假设1元、2元、5元、10元、20元、50元、100元的纸币分别有c0, c1, c2, c3, c4, c5, c6张。<br>现在要用这些钱来支付K元，至少要用多少张纸币？</p>
<p>题目保证给出的零钱一定可以用这些纸币找零</p>
</blockquote>
<p>思路</p>
<blockquote>
<p>用贪心算法的思想，很显然，每一步尽可能用面值大的纸币即可. </p>
<p>但是这种贪心算法只能解决钱币之间存在倍数关系的钱币找零问题，没有倍数关系的可以通过动态规划解决。</p>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*人民币面额集合*/</span></span><br><span class="line">    <span class="keyword">int</span>[] values = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="comment">/*各种面额对应数量集合*/</span></span><br><span class="line">    <span class="keyword">int</span>[] counts = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] counter = solve(values, counts, <span class="number">365</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; counts.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (counter[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"需要面额为%d的纸币%d张\n"</span>, values[i], counter[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] solve ( <span class="keyword">int</span>[] values, <span class="keyword">int</span>[] counts, <span class="keyword">int</span> sum)&#123;</span><br><span class="line">    <span class="keyword">int</span> []  result = <span class="keyword">new</span> <span class="keyword">int</span>[counts.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = values.length-<span class="number">1</span>; i &gt; -<span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = Math.min(sum/values[i], counts[i]);</span><br><span class="line">        counts[i] -= num;</span><br><span class="line">        sum = sum - num * values[i];</span><br><span class="line">        result[i] = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最长摇摆子序列"><a href="#最长摇摆子序列" class="headerlink" title="最长摇摆子序列"></a>最长摇摆子序列</h3><p>问题描述</p>
<blockquote>
<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p>
<p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p>
<p> 给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。 </p>
</blockquote>
<p>思路</p>
<p>题目要求我们把给定的序列中的最长的摇摆子序列给求出来。例如 <img src="/2022/06/21/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/20200811103747423.png" alt="img"></p>
<p>求出最长摇摆子序列为：图中蓝色节点外的节点构成的集合。这种做法，是对于连续一段递增或者递减的原序列，我们保留其末尾值作为子序列的元素，属于贪心策略。此外，我们需要的仅仅是图中转折处的节点，这种结点处变化趋势改变了，也就是状态发生了变化，因而我们可以把图中的节点变化过程描述成如下的状态机，然后依据此状态机来做贪心选择以及最长的摇摆子序列生成。</p>
<p> <img src="/2022/06/21/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/20200811103630445.png" alt="img"></p>
<p>即 设计了三种状态：</p>
<p>BEGIN状态，为初始状态，BEGIN状态有三种转移方式：</p>
<ol>
<li>当前节点与前一个节点值相同，状态不变</li>
<li>当前节点&gt;前一个节点值，状态变为UP</li>
<li>当前节点&lt;前一个节点值，状态变为DOWN</li>
</ol>
<p>UP状态，有两种种状态转移方式</p>
<ol>
<li>当前节点值&gt;=前一个节点值，状态不变</li>
<li>当前节点值&lt;前一个节点值，状态变为DOWN</li>
</ol>
<p>DOWN，有两种状态转移方式</p>
<ol>
<li>当前节点值&lt;=前一个节点值，状态不变</li>
<li>当前节点值&gt;前一个节点值，状态变为UP</li>
</ol>
<p>我们仅仅在每种状态发生变化，且变化到其他状态时记录该节点，最终得出的就是最长摇摆子序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">solve</span><span class="params">(<span class="keyword">int</span> [] nodes)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 定义三种状态</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> BEGIN = <span class="number">0</span>, UP = <span class="number">1</span>, DOWN = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 遍历每一个节点，进行变化状态演变过程，并在状态变化到其他状态时记录下该节点</span></span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> STATE = BEGIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nodes.length; i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (STATE)&#123;</span><br><span class="line">            <span class="keyword">case</span> BEGIN:</span><br><span class="line">                <span class="keyword">if</span> (nodes[i] &gt; nodes[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                    STATE = UP;</span><br><span class="line">                    result.add(nodes[i-<span class="number">1</span>]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodes[i] &lt; nodes[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                    STATE = DOWN;</span><br><span class="line">                    result.add(nodes[i-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> UP:</span><br><span class="line">                <span class="keyword">if</span> (nodes[i] &lt; nodes[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                    STATE = DOWN;</span><br><span class="line">                    result.add(nodes[i-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DOWN:</span><br><span class="line">                <span class="keyword">if</span> (nodes[i] &gt; nodes[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                    STATE = UP;</span><br><span class="line">                    result.add(nodes[i-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加入没有后面节点而无法统计的末尾节点</span></span><br><span class="line">    result.add(nodes[nodes.length-<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>水果店卖水果</p>
<p>问题描述</p>
<blockquote>
<p> 小王手里有点闲钱，想着做点卖水果的小买卖。给出两个数组m、n，用m[i]代表第i个水果的成本价，n[i]代表第i水果能卖出的价钱，假如现在有本钱k，试问最后最多能赚多少钱？ </p>
<p> 说明：<br>1 每种水果只需买一次，只能卖一次<br>2 数组m、n大小不超过50<br>3 数组元素为正整数，不超过1000 </p>
<p>输入描述：<br>1 数组m、n<br>2 本钱k<br>备注：<br>1 首行输入逗号分隔的数组m的元素值<br>2 第二行输入逗号分隔的数组n的元素值<br>3 第三行输入本钱</p>
<p>输出描述：<br>最后的本金</p>
</blockquote>
<p>例子</p>
<blockquote>
<p>输入<br>    4,2,6,4<br>    5,3,8,7<br>    15<br>输出<br>    22 </p>
<p> 说明<br>样例计算过程：<br>先买前3种水果，全部卖出，再买第4种水果，再卖出，最后本金变为22。 </p>
</blockquote>
<p>思路</p>
<blockquote>
<p>本题要求给你一个本金，你要用这本金尽可能的买更多的水果，从而使得最终的本金尽可能的多。每个水果只能买入卖出一次，所以每种水果能够給本金增加的数目都是固定的，所以按照成本升序，成本相同则价格降序对水果进行排序，每次买入一种水果后立刻卖出，获得收益到本金，方便买入后面更高成本的水果。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Fruit</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">boolean</span> hasBuyed  = <span class="keyword">false</span>;</span><br><span class="line">    BigDecimal gross_profit;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.price = price;</span><br><span class="line">      <span class="keyword">this</span>.gross_profit = BigDecimal.valueOf((price - cost)*<span class="number">1.0</span>/cost);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照毛利升序排列，毛利相同，按照成本升序排列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Fruit o)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.cost == o.cost)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.price - o.price;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.cost - o.cost;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    String[] mStrs = scanner.nextLine().split(<span class="string">","</span>);</span><br><span class="line">    String[] nStrs = scanner.nextLine().split(<span class="string">","</span>);</span><br><span class="line">    <span class="keyword">int</span> principal = Integer.parseInt(scanner.nextLine());</span><br><span class="line">    Fruit fruits[] = <span class="keyword">new</span> Fruit[mStrs.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fruits.length; i++) &#123;</span><br><span class="line">      fruits[i] = <span class="keyword">new</span> Fruit();</span><br><span class="line">      fruits[i].cost = Integer.parseInt(mStrs[i]);</span><br><span class="line">      fruits[i].setPrice(Integer.parseInt(nStrs[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(fruits);</span><br><span class="line">    <span class="keyword">for</span> (Fruit fruit : fruits) &#123;</span><br><span class="line">        <span class="keyword">if</span> (principal &lt; fruit.cost) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          principal = principal + fruit.price - fruit.cost;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(principal);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>​    <a id="more"></a></p>
<p>!!!! 本文章为个人知识成果，转载请注明出处。</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>参考文献</p>
<ul>
<li>【<a href="https://blog.csdn.net/u013309870/article/details/75193592?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165753067816782388033559%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165753067816782388033559&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-75193592-null-null.142^v32^down_rank,185^v2^control&utm_term=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&spm=1018.2226.3001.4187">算法-动态规划 Dynamic Programming–从菜鸟到老鸟</a>】</li>
<li>牛客网</li>
</ul>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p> 动态规划（英语：Dynamic programming，简称 DP） ，核心思想是记住并利用子问题的解来得出原问题的解。 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题。 </p>
<p>而记住子问题的答案的方式有两种</p>
<ul>
<li>自顶向下的备忘录法：从原问题出发，在得出一个子问题的解答之后，先记录到备忘录中，在返回供原问题求解。</li>
<li>自底向上：从最小的子问题出发求出其解，然后利用状态转移方程，求出上级问题的最优解。</li>
</ul>
<blockquote>
<p>重叠子问题：原问题求解的过程中需要涉及多次重复子问题的求解而不是子问题衍生出无数的子问题，比如 <code>fibonacci(5)</code>求解过程中多次涉及<code>fibonacci(2)</code>问题的求解，且最终子问题到达<code>fibonacci(1)</code></p>
<p>最优子结构性质：原问题的最优解中包含了子问题的最优解的性质。</p>
</blockquote>
<h2 id="动态规划演化由来（斐波那契数列为例）"><a href="#动态规划演化由来（斐波那契数列为例）" class="headerlink" title="动态规划演化由来（斐波那契数列为例）"></a>动态规划演化由来（斐波那契数列为例）</h2><p>斐波那契数列：0 1 1 2 3 5 8 13 … $a_n = a_{n-1} + a_{n-2}$。</p>
<p>问题：求出fib(n)的值</p>
<h3 id="无脑递归方式"><a href="#无脑递归方式" class="headerlink" title="无脑递归方式"></a>无脑递归方式</h3><p>那么利用递归求解的代码实现如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> fib( n-<span class="number">1</span>)+fib(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其求解流程如图</p>
<p> <img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/e7b6b6d25f9e63eef02f57488eee30d2.png" alt="这里写图片描述"> </p>
<blockquote>
<p>显然原问题的最优解，包含了子问题的最优解，且某个子问题的解被多次计算(导致时空效率低下)。这两条性质说明，这个问题可以用动态规划来解决。</p>
</blockquote>
<h3 id="备忘录法的动态规划"><a href="#备忘录法的动态规划" class="headerlink" title="备忘录法的动态规划"></a>备忘录法的动态规划</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> []Memo=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];		</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        Memo[i]=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(n, Memo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> []Memo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果已经求出了fib（n）的值直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(Memo[n]!=-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> Memo[n];</span><br><span class="line">    <span class="comment">//否则将求出的值保存在Memo备忘录中			</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)</span><br><span class="line">        Memo[n]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        Memo[n]=fib( n-<span class="number">1</span>,Memo)+fib(n-<span class="number">2</span>,Memo);	</span><br><span class="line">    <span class="keyword">return</span> Memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自底向上的动态规划"><a href="#自底向上的动态规划" class="headerlink" title="自底向上的动态规划"></a>自底向上的动态规划</h3><p>上面的备忘录法，虽然避免了大量的无效的子问题求解过程，但是还是要重复的用到子问题的解，虽然不用求了，那么为什么不反过来，先计算子问题然后直接利用子问题的解答，求出父问题的答案呢？比如按照顺序依次计算出 <code>fib（1），fib（2），fib（3）…,</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> []Memo=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    Memo[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    Memo[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Memo[i]=Memo[i-<span class="number">1</span>]+Memo[i-<span class="number">2</span>];</span><br><span class="line">    &#125;		</span><br><span class="line">    <span class="keyword">return</span> Memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：由于自顶向下的备忘录这种动态规划方法涉及了程序的递归，那么肯定会产生额外的开销，所以一般推荐使用自底向上的动态规划。</p>
<h2 id="钢条切割问题"><a href="#钢条切割问题" class="headerlink" title="钢条切割问题"></a>钢条切割问题</h2><p>  Serling公司购买长钢条，将其切割为短钢条出售。假设切割工序没有成本，不同长度的钢条的售价如下： </p>
<p><img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/v2-a2d0edf44393d61b06ea93b3fa2609b4_720w.png" alt="img"></p>
<p>  那么钢条切割问题就是：给定一段长度为 n 英尺的钢条和一个价格表为 $P_i(i=1,2…,n)$ ,$r_n$ 最大（单位为元）。注意：如果长度为 n 英尺的钢条的价格 $P_i(i=1,2…,n)$  足够大，那么最优解就是不需要切割。 </p>
<p>问题分析：考虑 n = 4 的情况，那么有以下几种切割方式：</p>
<ol>
<li>切割为四段，长度为：1，1，1，1；总共卖4<em>1=4元。</em></li>
<li>切割为三段，长度为：1，1，2；总共卖2<em>1+1</em>5=7元。</li>
<li>切割为两段，长度为：1，3；总共卖1<em>1+1</em>8=9元。</li>
<li>切割为两段，长度为：2，2；总共卖2<em>5=10元。</em></li>
<li>不切割，长度为：4；总共卖1*9=9元。</li>
</ol>
<p>长度为  n  的钢条，总共有 $2^{n-1}$ 种不同的切割方案，因为长度为 n 的钢条，总共有 n-1 个缝隙，每个缝隙都可以选择切或不切，所以有   $2^{n-1}$ 种不同切割方案。所以随着 n 增大，切割方案总数呈指数级上升，遍历是不现实的。在这里，很容易想到，当要分析长度为  的 n 钢条的最优解时，可以先将钢条切成两段。将长度为 n 的钢条随意切割的方案是  $2^{n-1}$ 种，但是只切两段的方案只有 n-1 种，这样规避了指数级计算量。将切成的两段，分别再当作子问题去求解，这就是如下分治策略解法：</p>
<h4 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h4><p>利用分治算法，由于最终切割的钢条有很多种情况，因此每次递归，取出最终结果的所有可能的切割的最大值，然后到底层最终在从底层返回到最终结果。</p>
<p> <img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/v2-8f01d48b606971496b207333534f15f9_720w.jpg" alt="img"> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solve1</span><span class="params">(<span class="keyword">int</span> values[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> result = Integer.MIN_VALUE;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    result = Math.max(result, values[i-<span class="number">1</span>] + solve1(values, n - i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  System.out.println(solve1(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">17</span>,<span class="number">17</span>,<span class="number">20</span>,<span class="number">24</span>,<span class="number">30</span>&#125;,<span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自顶向下的备忘录动态规划"><a href="#自顶向下的备忘录动态规划" class="headerlink" title="自顶向下的备忘录动态规划"></a>自顶向下的备忘录动态规划</h4><p>利用备忘录，记录中间计算过程中的子问题的解答，避免重复计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solve2</span><span class="params">(<span class="keyword">int</span>[] values, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] cutValue = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cutValue.length; i++) &#123;</span><br><span class="line">      cutValue[i] = Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> solve2_borrow(values,n,cutValue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solve2_borrow</span><span class="params">(<span class="keyword">int</span>[] values, <span class="keyword">int</span> n, <span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array[n] &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> array[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tempValue;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">      tempValue = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tempValue = Integer.MIN_VALUE;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        tempValue = Math.max(tempValue, values[i-<span class="number">1</span>] + solve2_borrow(values, n-i,array));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    array[n] = tempValue;</span><br><span class="line">    <span class="keyword">return</span> tempValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="自底向上的动态规划-1"><a href="#自底向上的动态规划-1" class="headerlink" title="自底向上的动态规划"></a>自底向上的动态规划</h4><p>利用边界条件值结合转移方程，求出子问题的解，最终求出最终问题的解。</p>
<p> <img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/99b691cfaa5ef5f5f459be4e3b886a0d.png" alt="这里写图片描述"> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solve3</span><span class="params">(<span class="keyword">int</span>[] values, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[values.length+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= values.length; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> tempMax = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">      tempMax = Math.max(tempMax, values[j-<span class="number">1</span>] + r[i-j]);</span><br><span class="line">    &#125;</span><br><span class="line">    r[i] = tempMax;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划的解题模型"><a href="#动态规划的解题模型" class="headerlink" title="动态规划的解题模型"></a>动态规划的解题模型</h2><p>由于，自顶向下的备忘录式的动态规划算法，涉及算法的递归调用，因此有额外的时空开销，所以我们使用的dp算法一般都是自底向上的动态规划，这种动态规划算法涉及状态转移方程以及边界条件的考察。而根据转移方程的不同结构我们把动态规划能够求解的问题页划分成了不同的解题模型。</p>
<h3 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h3><p>转移方程类似于 <code>f(n) = x f(n-1)</code>这种结构的问题的解题思路。</p>
<p>例题1 钢条切割问题</p>
<blockquote>
<p>Serling公司购买长钢条，将其切割为短钢条出售。切割工序本身没有成本支出。公司管理层希望知道最佳的切割方案。假定我们知道Serling公司出售一段长为i英寸的钢条的价格为pi(i=1,2,…，单位为美元)。钢条的长度均为整英寸。图15-1给出了一个价格表的样例。</p>
<p><img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/162025012825029.png" alt="img"></p>
<p>钢条切割问题是这样的：给定一段长度为n英寸的钢条和一个价格表pi(i=1,2,…n)，求切割钢条方案，使得销售收益rn最大。注意，如果长度为n英寸的钢条的价格pn足够大，最优解可能就是完全不需要切割。</p>
</blockquote>
<p>分析：</p>
<p>其状态转移方程大概为 f(n) = Max(values[1] + f(n - 1),values[2] + f(n-2), values[3] + f(n-3), …values[n-1] + f(1))。</p>
<p>例题2 孩子过桥问题</p>
<blockquote>
<p>在一个夜黑风高的晚上，有n（n &lt;= 50）个小朋友在桥的这边，现在他们需要过桥，但是由于桥很窄，每次只允许不大于两人通过，他们只有一个手电筒，所以每次过桥的两个人需要把手电筒带回来，i号小朋友过桥的时间为T[i]，两个人过桥的总时间为二者中时间长者。问所有小朋友过桥的总时间最短是多少。</p>
</blockquote>
<p>分析：</p>
<p>这题如果按照贪心算法的思路，就是选择过河速度最快的一个孩子，每次让他配一个孩子过河，过河之后，立即返回把手电筒带回来，得出来的不是最优解，因为如果这个孩子每次都返回，可能导致本来速度最慢的两个孩子的每个人都和他一起过河，反而耗时更长了，不如这两个速度最慢的孩子一起过河所造成的时间损耗最小。因此我们可以先将所有人按花费时间递增进行排序，假设前i个人过河花费的最少时间为opt[i]，那么考虑前i-1个人过河的情况，即河这边还有1个人，河那边有i-1个人，并且这时候手电筒肯定在对岸，所以opt[i] = opt[i-1] + a[1] + a[i]        (让花费时间最少的人把手电筒送过来，然后和第i个人一起过河)。如果河这边还有两个人，一个是第i号，另外一个无所谓，河那边有i-2个人，并且手电筒肯定在对岸，所以opt[i] = opt[i-2] + a[1] + a[i] + 2*a[2]    (让花费时间最少的人把电筒送过来，然后第i个人和另外一个人一起过河，由于花费时间最少的人在这边，所以下一次送手电筒过来的一定是花费次少的，送过来后花费最少的和花费次少的一起过河，解决问题)。</p>
<p>由以上的分析过程中我们可以得出动态规划算法的状态转移方程： <em>opt[i] = min{opt[i-1] + a[1] + a[i] , opt[i-2] + a[1] + a[i] + 2</em>a[2] }</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读入孩子的速率数组</span></span><br><span class="line">    <span class="keyword">int</span> [] childRate = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="comment">// 对其进行升序排序</span></span><br><span class="line">    Arrays.sort(childRate);</span><br><span class="line">    <span class="comment">// 处理边界条件然后依次按照自底向上的顺序对状态数组按照状态转移方程进行处理</span></span><br><span class="line">    <span class="keyword">int</span>[] time = <span class="keyword">new</span> <span class="keyword">int</span>[childRate.length];</span><br><span class="line">    time[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    time[<span class="number">1</span>] = childRate[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; childRate.length; i++) &#123;</span><br><span class="line">      time[i] = Math.min(</span><br><span class="line">          time[i-<span class="number">1</span>] + childRate[<span class="number">0</span>] + childRate[i],</span><br><span class="line">          time[i-<span class="number">2</span>] + childRate[<span class="number">0</span>] + childRate[i] + <span class="number">2</span> * childRate[<span class="number">1</span>]</span><br><span class="line">          );</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(time[childRate.length-<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="区间模型"><a href="#区间模型" class="headerlink" title="区间模型"></a>区间模型</h3><p>例题3 最长公共子序列问题</p>
<blockquote>
<p>给定两个字符串str1和str2，输出两个字符串的最长公共子序列。如果最长公共子序列为空，则返回”-1”。目前给出的数据，仅仅会存在一个最长的公共子序列</p>
<p>数据范围：$0 \le |str_1|,|str_2| \le 20000≤∣str_1∣,∣str_2∣≤2000$</p>
<p>要求：空间复杂度 $O(n^2)$，时间复杂度 $O(n^2)$</p>
</blockquote>
<p>解题思路：</p>
<p>这题属于矩阵模型的动态规划，这个问题由于具有最优子结构性质（原问题的解可以划分成子问题的解）、以及重叠子结构性质（子问题的解可能被多次重复利用），所以可以使用动态规划解决，具体解决步骤如下。</p>
<ul>
<li><p>step 1：优先检查特殊情况。</p>
</li>
<li><p>step 2：获取最长公共子序列的长度可以使用动态规划，我们以$dp[i][j]$表示在s1中以i结尾，s2中以j结尾的字符串的最长公共子序列长度。</p>
</li>
<li><p>step 3：遍历两个字符串的所有位置，开始状态转移：若是i位与j位的字符相等，则该问题可以变成$1+dp[i−1][j−1]$，即到此处为止最长公共子序列长度由前面的结果加1。</p>
</li>
<li><p>step 4：若是不相等，说明到此处为止的两个子串，最后一位不可能同时属于最长公共子序列，毕竟它们都不相同，因此我们考虑换成两个子问题，$dp[i][j−1]$或者$dp[i−1][j]$，我们取较大的一个就可以了，由此可以用递归解决。</p>
</li>
<li><p>step 5：根据以上的过程得出一个状态转移方程</p>
<p><img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1657603453077.png" alt="1657603453077"></p>
</li>
<li><p>step 6：依据此方程，可知这是一个区间模型的动态规划问题，为了方便，我们把矩阵行和列都拓展一位，然后考虑边界条件（i==0与j==0）即二维矩阵的$dp[i][0]$或者$dp[0][j]$，显然由于我们拓展了一位，那么这些区域的初始值必须为0，这样才方便i==1或者j==j时的dp矩阵的下标处的值利用转移方程求出来。</p>
<p> <img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/C8A06E419BA9D0380E76B9F353AC0956.gif" alt="图片说明"> </p>
</li>
<li><p>step 7：最终求出矩阵所有值后，我们从矩阵末尾反推，如果$dp[i][j]$所涉及的s1和s2的两个末尾字符相同，则直接放入结果子序列中；如果不相同，则找与当前$dp[i][j]$相同值的$dp[i-1][j]$或者$dp[i][j-1]$，因为找到这些，说明当前$dp[i][j]$处的字符并不是最长公共子序列中的，所以需要向其他方向找。 </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">LCS</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理无效输入问题</span></span><br><span class="line">    <span class="keyword">if</span> (s1.length() == <span class="number">0</span> || s2.length() == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"-1"</span>;</span><br><span class="line">    <span class="comment">// 定义状态转移的二维模型,dp[i][j]，表示S1(0,i)、S2(0,j)的子串的最长公共子序列的长度。</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s1.length() + <span class="number">1</span>][s2.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 处理边界情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s1.length(); i++)</span><br><span class="line">      dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= s2.length(); j++)</span><br><span class="line">      dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 正式利用状态转移方程求解</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; dp[i].length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.charAt(i-<span class="number">1</span>) == s2.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">          dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s1.length(), j = s2.length(); dp[i][j] &gt;= <span class="number">1</span>; ) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s1.charAt(i - <span class="number">1</span>) == s2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">        res.append(s1.charAt(i - <span class="number">1</span>));</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] &gt;= dp[i][j - <span class="number">1</span>]) &#123;</span><br><span class="line">        i--;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String finalResult = res.reverse().toString();</span><br><span class="line">    <span class="keyword">return</span> finalResult.length() &gt; <span class="number">0</span> ? finalResult : <span class="string">"-1"</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="背包模型"><a href="#背包模型" class="headerlink" title="背包模型"></a>背包模型</h3><p>例题：01背包问题（01指的是，一个物品只能有被装入或者不被装入的两种情况，不存在装入了一半这种情况）</p>
<blockquote>
<p>有n件物品（<strong>每种物品都只有一件</strong>），w[i]表示物品的体积，v[i]表示物品的价值，现有一个容量为V的背包，</p>
<p>应该如何选物品使得书包内装的物品的价值之和最大呢？</p>
</blockquote>
<p>分析：利用动态规划算法，将原问题拆解为子问题，如果最后一个物品不放入背包，则当前背包的总价值等于前n-1个物品以及背包容量为V的子问题；最后一个放入背包，则当前背包的总价值等于，前n-1个物品以及背包容量为V-wi的子问题。这样就得出了状态转移方程如下：$dp[i][V] = max(dp[i-1][V], dp[i-1][V-W_i] + v_i )$。那么还有另外一个问题，当前背包装了哪些物品呢？我们可以利用回溯，来求出背包中装了哪些物品。</p>
<p><img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1657628583621.png" alt="1657628583621"></p>
<p>回溯： 从表的右下角，如果发现前n个物品的最佳组合的价值和前n-1个物品最佳组合的价值一样，则说明第n个物品并没有被装入，否则第n个物品被装入，然后拿着剩余容量到前n-1所在行的对应剩余容量所代表的列，重复如上判断过程直到编号为0，最终得出哪些物品被装入了背包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">ZeroOnePack</span><span class="params">(<span class="keyword">int</span> V,<span class="keyword">int</span> N,<span class="keyword">int</span>[] weight,<span class="keyword">int</span>[] value)</span></span>&#123;</span><br><span class="line">		<span class="comment">//初始化动态规划数组</span></span><br><span class="line">		<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>][V+<span class="number">1</span>];</span><br><span class="line">		<span class="comment">//为了便于理解,将dp[i][0]和dp[0][j]均置为0，从1开始计算</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N+<span class="number">1</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;V+<span class="number">1</span>;j++)&#123;</span><br><span class="line">				<span class="comment">//如果第i件物品的重量大于背包容量j,则不装入背包</span></span><br><span class="line">				<span class="comment">//由于weight和value数组下标都是从0开始,故注意第i个物品的重量为weight[i-1],价值为value[i-1]</span></span><br><span class="line">				<span class="keyword">if</span>(weight[i-<span class="number">1</span>] &gt; j)</span><br><span class="line">					dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-weight[i-<span class="number">1</span>]]+value[i-<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//则容量为V的背包能够装入物品的最大值为</span></span><br><span class="line">		<span class="keyword">int</span> maxValue = dp[N][V];</span><br><span class="line">		<span class="comment">//逆推找出装入背包的所有商品的编号</span></span><br><span class="line">		<span class="keyword">int</span> j=V;</span><br><span class="line">		String numStr=<span class="string">""</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=N;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">			<span class="comment">//若果dp[i][j]&gt;dp[i-1][j],这说明第i件物品是放入背包的</span></span><br><span class="line">			<span class="keyword">if</span>(dp[i][j]&gt;dp[i-<span class="number">1</span>][j])&#123;</span><br><span class="line">				numStr = i+<span class="string">" "</span>+numStr;</span><br><span class="line">				j=j-weight[i-<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(j==<span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> numStr;	</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划的常考问题总结"><a href="#动态规划的常考问题总结" class="headerlink" title="动态规划的常考问题总结"></a>动态规划的常考问题总结</h2><p>动态规划算法，难点在于看到相关问题是否能够想到使用动态规划，以及状态转移方程的求解。因此有必要总结动态规划算法常用于如下问题的解决（并不是一定能用）。</p>
<ul>
<li>计数问题 算法中一般涉及加加减减</li>
</ul>
<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1649511781328.png" alt="1649511781328" style="zoom:67%;">

<ul>
<li>求最大值、最小值 算法中一般涉及Math.min,Math.max</li>
</ul>
<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1649511772602.png" alt="1649511772602" style="zoom:67%;">

<ul>
<li>存在性问题 算法中一般涉及and or</li>
</ul>
<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1649511792136.png" alt="1649511792136" style="zoom:67%;">

<h2 id="动态规划解题流程"><a href="#动态规划解题流程" class="headerlink" title="动态规划解题流程"></a>动态规划解题流程</h2><p>例题 1求最值问题-动态规划</p>
<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1649512519517.png" alt="1649512519517" style="zoom:50%;">



<blockquote>
<p>错误的直觉算法：尽量用大的硬币。导致777222.正确答案是75555。</p>
</blockquote>
<ol>
<li><strong>确定状态：即确定题目中的自变量（根据最后一步的操作、和子问题想出状态是什么？）</strong></li>
</ol>
<blockquote>
<p>最后一步操作是最优策略的$a_{k}$放入硬币组合中，和为27。从而化成子问题：27-$a_k$的最优硬币组合。</p>
</blockquote>
<ol start="2">
<li><strong>确定状态转移方程：即原问题到子问题变化的方程</strong></li>
</ol>
<blockquote>
<p>f[ 27 ] =1+f[ 27-$a_k$ ];其中$a_k $=2|5|7于是推导出如下状态转移方程</p>
<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1649600103965.png" alt="1649600103965" style="zoom: 67%;">
</blockquote>
<ol start="3">
<li><strong>初始条件和边界情况</strong></li>
</ol>
<blockquote>
<p>初始条件：即状态转移方程算不出来的，但是需要我们定义的值。如f[0]我们需知f[-2]、f[-3]、f[-7]的值这些显然不可知，预设预设</p>
<p>​    本题中为f[0]=0</p>
<p>边界情况：转移方程需要考虑的x的边界</p>
<p>​     本题中为：x-2 x-5 x-7小于0如何？</p>
</blockquote>
<ol start="4">
<li><strong>计算顺序</strong></li>
</ol>
<blockquote>
<p>确定了<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1649601294665.png" alt="1649601294665" style="zoom:50%;"></p>
<p>之后还需要确定计算顺序，原则是<strong>当计算到f[x]时f[x-2]、f[x-5]、f[x-7]都已经有值了</strong></p>
</blockquote>
<p>最终结果</p>
<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1649601405465.png" alt="1649601405465" style="zoom:50%;">

<p>动态规划一共进行27次循环、每次计算三种计算，一共27*3次，远远小于递归算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span> []a,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="comment">//状态数组,长度为m+1</span></span><br><span class="line">    <span class="keyword">int</span> [] f = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//硬币枚数</span></span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="comment">//处理不在考虑之类的数值出的值</span></span><br><span class="line">        f[i]=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">//要考虑下标为负数以及f[i-a[i]]为最大值的情况（为最大值时，最大值+1会越界）</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;=a[j]&amp;&amp;f[i-a[j]]!=Integer.MAX_VALUE)&#123;</span><br><span class="line">                f[i]=Math.min(f[i],f[i-a[j]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">return</span>  f[m]==Integer.MAX_VALUE?-<span class="number">1</span>:f[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例题2 机器人走路问题-计数型</p>
<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1649604758708.png" alt="1649604758708" style="zoom:50%;">

<ol>
<li>确定状态</li>
</ol>
<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1649605369806.png" alt="1649605369806" style="zoom:33%;">

<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1649605240553.png" alt="1649605240553" style="zoom: 33%;">

<ol start="2">
<li><p>确定状态转移方程</p>
<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1649605595890.png" alt="1649605595890" style="zoom:50%;">
</li>
<li><p>初始条件和边界情况</p>
</li>
</ol>
<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1649605664631.png" alt="1649605664631" style="zoom:50%;">

<ol start="4">
<li>计算顺序</li>
</ol>
<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1649605870614.png" alt="1649605870614" style="zoom:50%;">

<p>结果是f[ m-1] [n-1]。</p>
<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1649605918172.png" alt="1649605918172" style="zoom:50%;">

<p>算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//开数组</span></span><br><span class="line">    <span class="keyword">int</span> [][] paths= <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="comment">//初始化，初始化放到for循环中了</span></span><br><span class="line">    <span class="comment">//按照顺序进行计算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;</span><br><span class="line">                paths[i][j]=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                paths[i][j]=paths[i-<span class="number">1</span>][j]+paths[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">return</span> paths[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例题3 青蛙跳-可行性问题</p>
<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1649607548832.png" alt="1649607548832" style="zoom:50%;">

<ol>
<li><p>确定状态</p>
<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1649609042933.png" alt="1649609042933" style="zoom:50%;">

</li>
</ol>
<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1649608514237.png" alt="1649608514237" style="zoom:50%;">

<ol start="2">
<li>转移方程</li>
</ol>
<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1649608558184.png" alt="1649608558184" style="zoom:50%;">

<ol start="3">
<li>初始值和边界情况</li>
</ol>
<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1649608746861.png" alt="1649608746861" style="zoom:50%;">

<ol start="4">
<li>计算顺序</li>
</ol>
<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1649608737903.png" alt="1649608737903" style="zoom:50%;">

<p>算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[]a)</span></span>&#123;</span><br><span class="line">    <span class="comment">//数组</span></span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">boolean</span> [] canJump =  <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    canJump[<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//计算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        canJump[i]=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canJump[j]&amp;&amp;j+a[j]&gt;=i)&#123;</span><br><span class="line">                canJump[i]=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> canJump[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1657463940594.png" alt="1657463940594"></p>
<p>算法实现过程一般是：开数组、初始化、按顺序赋值、返回值。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>一些做题心得体会</p>
<ul>
<li>动态规划转移方程一定要反复确认是否正确。</li>
<li>线性模型没思路就试试区间模型，再者试试背包模型，切不可死扣，实在不行就暴力解法。</li>
<li>先找出转移方程，再根据转移方程考虑边界处的值。</li>
<li>一定要注意dp数组的求值顺序，不然正确的转移方程得不出正确的结果很麻烦。比如 牛客 BM73题。</li>
<li>一定定义dp数组的时候，要把0位考虑成特殊位置，即下标从1开始而不是0。</li>
<li>一般数组中所取得下标处都要判断数据是否合法。</li>
<li>考虑原问题最后一步的行为时，确定自变量，因变量，如果因变量不是想要的dp数组，则把因变量也变为dp数组的一维。</li>
<li>状态就是问题求解过程中子问题与原问题都涉及的东西，原问题的状态一般由子问题的状态通过运算获得，对于问题中涉及的变化的量，可以将其作为状态数组的一个维度。</li>
</ul>
<h2 id="习题练习记录"><a href="#习题练习记录" class="headerlink" title="习题练习记录"></a>习题练习记录</h2><ul>
<li><p><img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1657986669957.png" alt="1657986669957"></p>
<p>状态转移方程：<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1657986703364.png" alt="1657986703364"></p>
</li>
<li><p><img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1657986726259.png" alt="1657986726259"></p>
<p>状态转移方程：<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1657986755264.png" alt="1657986755264"></p>
</li>
<li><p><img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1657986773320.png" alt="1657986773320"></p>
<p>状态转移方程：<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1657986804090.png" alt="1657986804090"></p>
</li>
<li><p><img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1657986830453.png" alt="1657986830453"></p>
<p>状态转移方程：<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1657986866275.png" alt="1657986866275"></p>
</li>
<li><p><img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1657986886423.png" alt="1657986886423"></p>
<p>状态转移方程：<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1657986905427.png" alt="1657986905427"></p>
</li>
<li><p><img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1657986935387.png" alt="1657986935387"></p>
<p>状态转移方程：<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1657986979599.png" alt="1657986979599"></p>
</li>
<li><p><img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1657987021249.png" alt="1657987021249"></p>
</li>
<li><p>状态转移方程：<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1657987057431.png" alt="1657987057431"></p>
</li>
<li><p><img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1657987090831.png" alt="1657987090831"></p>
<p>状态转移方程：<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1657987151958.png" alt="1657987151958"></p>
</li>
<li><p><img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1657987187989.png" alt="1657987187989"></p>
<p>状态转移方程：<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1657987229640.png" alt="1657987229640"></p>
</li>
<li><p><img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1658019052743.png" alt="1658019052743"></p>
<p>状态转移方程：dp[i]表示以i结尾的连续子数组的和，则 dp[i] = Math.max(dp[i-1]+array[i], array[i]); </p>
</li>
<li><p><img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1658020108413.png" alt="1658020108413"></p>
<p>$dp[i][j]$表示以i与j为两端的字符串是否是回文字符串，<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1658020254140.png" alt="1658020254140"></p>
</li>
<li><p><img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1658020989005.png" alt="1658020989005"></p>
<p>$dp[i][j]$表示从i到j的最小编辑距离，则<img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1658021028125.png" alt="1658021028125"></p>
</li>
<li><p><img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1658021429626.png" alt="1658021429626"></p>
<p> <code>dp[i][j]</code>表示str前i个字符和pattern前j个字符是否匹配 ， 只要遍历到的两个字符相等，或是pattern串中为’.’即可匹配，即 <code>dp[i][j] = dp[i-1][j-1]</code>,如果遍历到的模式串的字符为<code>*</code>，则有如下情况</p>
<ul>
<li>pattern[j - 2] == ‘.’ || pattern[j - 2] == str[i - 1] =》 <code>dp[i][j] = dp[i-1][j] || dp[i][j−2] ​</code></li>
<li>其他情况，则让模式串的<code>*</code>前面的字符出现0次，即<code>dp[i][j]=dp[i][j−2]</code></li>
</ul>
</li>
<li><p><img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1658023208170.png" alt="1658023208170"></p>
<p><code>dp[i]</code>表示以<code>a[i]</code>结尾的最长的括号子串的长度，则<code>a[i]=&#39;(&#39;</code>时，<code>dp[i] = 0</code>；<code>a[i] = &#39;)&#39;</code>时考虑如下两种情况</p>
<ul>
<li>子串形如：‘……()’，则 <code>dp[i] = dp[i-2] + 2</code></li>
<li>子串形如：  ‘……))’ ，则<code>dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2</code></li>
</ul>
</li>
<li><p><img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1658024516305.png" alt="1658024516305"></p>
<p><code>dp[i]表示偷到第i家的最大获利值，有两种情况，偷第i家和不偷第i家，则</code>dp[i]=max(dp[i−1],nums[i−1]+dp[i−2]) `。</p>
</li>
<li><p><img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1658025629608.png" alt="1658025629608"></p>
<p>与上题不同的是，这题的第一家和最后一家是相邻的，那么</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span> <span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]表示长度为i的数组，最多能偷取多少钱</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>]; </span><br><span class="line">        <span class="comment">//选择偷了第一家</span></span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>]; </span><br><span class="line">        <span class="comment">//最后一家不能偷</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++) </span><br><span class="line">            <span class="comment">//对于每家可以选择偷或者不偷</span></span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], nums[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]); </span><br><span class="line">        <span class="keyword">int</span> res = dp[nums.length - <span class="number">1</span>]; </span><br><span class="line">        <span class="comment">//清除dp数组，第二次循环</span></span><br><span class="line">        Arrays.fill(dp, <span class="number">0</span>); </span><br><span class="line">        <span class="comment">//不偷第一家</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>; </span><br><span class="line">        <span class="comment">//可以偷最后一家</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nums.length; i++) </span><br><span class="line">            <span class="comment">//对于每家可以选择偷或者不偷</span></span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], nums[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]); </span><br><span class="line">        <span class="comment">//选择最大值</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(res, dp[nums.length]); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1658026001098.png" alt="1658026001098"></p>
<p>状态转移方程：<code>dp[i][0]</code>表示第i天手上不持股的获利值，<code>dp[i][1]</code>表示第i天手上持股的获利值。则</p>
<p><code>dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);</code> </p>
<p><code>dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);</code></p>
</li>
<li><p><img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1658026189019.png" alt="1658026189019"></p>
<p>状态转移方程：</p>
<p><code>dp[i][0]=max(dp[i−1][0],dp[i−1][1]+prices[i])</code></p>
<p><code>dp[i][1]=max(dp[i−1][1],dp[i−1][0]−prices[i])</code></p>
</li>
<li><p><img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1658026316307.png" alt="1658026316307"></p>
<blockquote>
<p><img src="/2022/07/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1658026498436.png" alt="1658026498436"></p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针算法</title>
    <url>/2022/07/18/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>​    <a id="more"></a></p>
<p>!!!! 本文章为个人知识成果，转载请注明出处。</p>
<p>参考文章</p>
<ul>
<li>[双指针算法基本原理和实践 - huansky - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/huansky/p/13508533.html#:~:text=双指针，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（">https://www.cnblogs.com/huansky/p/13508533.html#:~:text=双指针，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（</a> 快慢指针 ）或者相反方向（ 对撞指针 ）的指针进行扫描，从而达到相应的目的。.,换言之，双指针法充分使用了数组有序这一特征，从而在某些情况下能够简化一些运算。. 在 LeetCode 题库中，关于双指针的问题还是挺多的。. 双指针.) </li>
</ul>
<h2 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h2><p> 双指针，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（<em>快慢指针</em>）或者相反方向（<em>对撞指针</em>）的指针进行扫描 。</p>
<p>双指针根据指针的方向又可以分为：</p>
<ol>
<li>对撞指针</li>
<li>快慢指针</li>
</ol>
<p>双指针算法常常用来结合滑动窗口等算法优化暴力解法。</p>
<h3 id="对撞指针"><a href="#对撞指针" class="headerlink" title="对撞指针"></a>对撞指针</h3><p> 对撞指针是指在线性表遍历时，将指向最左侧的索引定义为<code>左指针(left)</code>，最右侧的定义为<code>右指针(right)</code>，然后从两头向中间进行遍历。 </p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><ol>
<li><h3 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a><a href="https://leetcode-cn.com/problems/reverse-string/">反转字符串</a></h3></li>
</ol>
<blockquote>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>tip: 原地是指：算法开辟的空间必须是固定的，不允许随着输入规模的改动而改动。</p>
<p>思路: 对撞指针，从两头分别读取并交换，直到撞起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length == <span class="number">0</span> || s.length == <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = s.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;right) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = s[left];</span><br><span class="line">            s[left++] = s[right];</span><br><span class="line">            s[right--] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<p>2、盛水最多的容器</p>
<blockquote>
<p><img src="/2022/07/18/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/1658239496827.png" alt="1658239496827"></p>
<p>思路：题目要求的是盛水最多的容器，显然也就是求构成的面积最大的两个数组高度。根据水桶定理，一个水桶，较短的一条边决定了最大的水量，那么直接用较短边的高度*两条边之间的距离就是这个桶所能盛放的最大的水的体积。所以我们定义两个指针，分别指向数组的两端，从两端向中间靠拢，每次移动就移动短的那条边，因为如果你移动长的那条边，那么加入新移动到的高度比原本短的更短，那么面积变小；如果新移动到的边比原本短的更高，那么面积也会变小，因此长度边短了，但是决定桶的容量的是短板的高度，而短板的高度不变，所以移动长边后的面积肯定是变小的。因此每次比较两条边之后，移动短的那条边。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span> <span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> maxArea = <span class="number">0</span>,tempArea=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> left = <span class="number">0</span>,right=height.length-<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">    tempArea = Math.min(height[left] , height[right]) * (right - left);</span><br><span class="line">    <span class="keyword">if</span> (height[left]&gt;=height[right])&#123;</span><br><span class="line">      right--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tempArea &gt; maxArea)&#123;</span><br><span class="line">      maxArea = tempArea;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>3、接雨水问题</p>
<p><img src="/2022/07/18/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/1658240889621.png" alt="1658240889621"></p>
<blockquote>
<p>思路：这题思路与上题类似。首先，桶中能盛放多少水有桶的两条边的较小的那条边决定，那么我们可以把数组的每个高度看成桶的边。对于任意两条边，我们可以移动短边，来计算如果这个桶中没有更高的突起的情况下的盛水量，如果有更高的突起，那么更高的突起和原本桶的更高的边构成一个新的桶，对于这个新的桶，也可以采用如上算法求出接水量。由此我们定义两个指针分别从数组的两端相向而行，同时当前正在接水的桶的最短边的长度，然后移动短边，移动过程中统计，当前接水的桶可以盛放的水量，当找到更高的边后，形成一个新的桶，重复如上操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">maxWater</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 类似于盛水最多的容器那题，定义两个指针，分别指向桶的两个边界</span></span><br><span class="line">  <span class="keyword">int</span> left = <span class="number">0</span>, right = arr.length-<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> totalWaterVolume = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> minHeight = Math.min(arr[left],arr[right]);</span><br><span class="line">  <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[left] &lt;= arr[right]) &#123;</span><br><span class="line">      left++;</span><br><span class="line">      <span class="keyword">if</span> (arr[left] &gt;= minHeight) &#123;</span><br><span class="line">        minHeight = Math.min(arr[left],arr[right]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        totalWaterVolume = totalWaterVolume + (minHeight-arr[left]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      right--;</span><br><span class="line">      <span class="keyword">if</span> (arr[right] &gt;= minHeight) &#123;</span><br><span class="line">        minHeight = Math.min(arr[left],arr[right]);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        totalWaterVolume = totalWaterVolume + (minHeight - arr[right]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 低的边界那边先行，遇到比高的边界还高的或者一样的则移动高边界的指针。移动过程中统计桶盛水的多少。直到两个指针相遇。</span></span><br><span class="line">  <span class="keyword">return</span> totalWaterVolume;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p> 两个指针从同一侧开始遍历数组，将这两个指针分别定义为<code>快指针（fast）</code>和<code>慢指针（slow）</code>，两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如 fast 每次增长两个，slow 每次增长一个。 可以用来判断链表是否为环等实际问题中。这里的快慢指针也可以同样的速率，但是起点不同的两个指针。</p>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><ol>
<li><h3 id="判定链表中是否含有环"><a href="#判定链表中是否含有环" class="headerlink" title="判定链表中是否含有环"></a>判定链表中是否含有环</h3><blockquote>
<p>单链表的特点是每个节点只知道下一个节点，所以一个指针的话无法判断链表中是否含有环的。</p>
<p>如果链表中不包含环，那么这个指针最终会遇到空指针 null 表示链表到头了，这还好说，可以判断该链表不含环。 但是如果链表中含有环，那么这个指针就会陷入死循环，因为环形数组中没有 null 指针作为尾部节点。 </p>
<p>思路： 用两个指针，一个每次前进两步，一个每次前进一步。如果不含有环，跑得快的那个指针最终会遇到 null，说明链表不含环；如果含有环，快指针最终会和慢指针相遇，说明链表含有环。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode fast, slow;</span><br><span class="line">    fast = slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="2">
<li>最长无重复子数组</li>
</ol>
<blockquote>
<p><img src="/2022/07/18/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/1658241872171.png" alt="1658241872171"></p>
<p>思路：利用滑动窗口、哈希表（这里用位图代替）、双指针算法大杂烩进行解题。思路是，首先找出一个滑动窗口，这个滑动窗口内的数字都是不重复的，然后依次向后移动，如果新加入窗口的数字在位图中已经有了，也就是滑动窗口中已经有了，那么移动滑动窗口左端的指针，直到将已有的那个数字退出了滑动窗口。移动的过程中要注意修改位图中的记录。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxLength</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left,right=left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxlength = <span class="number">1</span>;</span><br><span class="line">    BitSet bits = <span class="keyword">new</span> BitSet();</span><br><span class="line">    <span class="keyword">while</span> (right&lt;arr.length)&#123;</span><br><span class="line">        <span class="keyword">if</span> (bits.get(arr[right]))&#123;</span><br><span class="line">            maxlength = Math.max(maxlength,right-left);</span><br><span class="line">            <span class="keyword">while</span> (arr[left]!=arr[right])&#123;</span><br><span class="line">                bits.clear(arr[left++]);</span><br><span class="line">            &#125;</span><br><span class="line">            bits.clear(arr[left++]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            bits.set(arr[right++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    maxlength = Math.max(maxlength,right-left);</span><br><span class="line">    <span class="keyword">return</span> maxlength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="3">
<li>合并区间</li>
</ol>
<blockquote>
<p><img src="/2022/07/18/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/1658242215971.png" alt="1658242215971"></p>
<p>思路：首先题目没说输入的区间是有顺序的，那么我们就要将其顺序化，这里我们先按照区间开始值排序，相同的则按照区间结束值排序，都是按照升序排序。排完序之后，我们可以定义一个快指针，一个慢指针，快指针向后找区间，如果找到的区间开始值比已经合并后的区间的结束值小，那么说明这个区间和已经合并后的上个区间相交，就把该区间合并到上个区间中，同时改变区间的结束值；如果找到的区间的开始值，比上个区间的结束大，则说明已经没有区间和上个区间相交了。则慢指针指向放入当前找到的区间，并将其放入到合并后的区间列表中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Interval&gt; <span class="title">merge</span><span class="params">(ArrayList&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对间隔数组进行排序</span></span><br><span class="line">    intervals.sort(<span class="keyword">new</span> Comparator&lt;Interval&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Interval o1, Interval o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o1.start == o2.start) &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.end - o2.end;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.start - o2.start;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 双指针从头到尾遍历排序后的数组</span></span><br><span class="line">    <span class="keyword">int</span> latter = <span class="number">0</span>, former;</span><br><span class="line">    ArrayList&lt;Interval&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (latter &lt; intervals.size()) &#123;</span><br><span class="line">        former = latter;</span><br><span class="line">        <span class="keyword">int</span> maxEnd = intervals.get(former).end;</span><br><span class="line">        <span class="keyword">while</span> (former &lt; intervals.size() &amp;&amp; maxEnd &gt;= intervals.get(former).start) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals.get(former).end &gt; maxEnd) &#123;</span><br><span class="line">                maxEnd = intervals.get(former).end;</span><br><span class="line">            &#125;</span><br><span class="line">            former++;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(<span class="keyword">new</span> Interval(intervals.get(latter).start, maxEnd));</span><br><span class="line">        latter = former;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="4">
<li>最小覆盖子串</li>
</ol>
<blockquote>
<p><img src="/2022/07/18/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/1658243625815.png" alt="1658243625815"></p>
<p>思路：滑动窗口算法，结合快慢指针优化暴力解法。</p>
<p>![](%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/20220719231215 00_00_00-00_01_13.gif)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//检查是否有小于0的</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hash.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hash[i] &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span> <span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = S.length() + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//记录目标字符串T的字符个数</span></span><br><span class="line">    <span class="keyword">int</span>[] hash = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.length(); i++)</span><br><span class="line">    <span class="comment">//初始化哈希表都为负数，找的时候再加为正</span></span><br><span class="line">        hash[T.charAt(i)] -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//记录左右区间</span></span><br><span class="line">    <span class="keyword">int</span> left = -<span class="number">1</span>, right = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; fast &lt; S.length(); fast++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = S.charAt(fast);</span><br><span class="line">        <span class="comment">//目标字符匹配+1</span></span><br><span class="line">        hash[c]++;</span><br><span class="line">        <span class="comment">//没有小于0的说明都覆盖了，缩小窗口</span></span><br><span class="line">        <span class="keyword">while</span>(check(hash))&#123;</span><br><span class="line">            <span class="comment">//取最优解</span></span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; fast - slow + <span class="number">1</span>)&#123; </span><br><span class="line">                cnt = fast - slow + <span class="number">1</span>;  </span><br><span class="line">                left = slow;</span><br><span class="line">                right = fast;</span><br><span class="line">            &#125;</span><br><span class="line">            c = S.charAt(slow);</span><br><span class="line">            <span class="comment">//缩小窗口的时候减1</span></span><br><span class="line">            hash[c]--;</span><br><span class="line">            <span class="comment">//窗口缩小</span></span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找不到的情况</span></span><br><span class="line">    <span class="keyword">if</span>(left == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">return</span> S.substring(left, right + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>后端 - 基础</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>学习法总结</title>
    <url>/2022/07/18/%E5%AD%A6%E4%B9%A0%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>​    <a id="more"></a></p>
<p>!!!! 本文章为个人知识成果，转载请注明出处。</p>
<p>背景：总感觉自己学的太慢，效率太低，学的总记不住，因此特地学习了有关书籍，总结出学习的方法。</p>
<h5 id="学霸学习模型"><a href="#学霸学习模型" class="headerlink" title="学霸学习模型"></a>学霸学习模型</h5><ul>
<li>学会一个知识</li>
<li>知道自己是如何学会这个知识的</li>
<li>回顾，然后类推学习下一个知识。</li>
</ul>
<p>因为任何知识都是可压缩的，学一通百。学习一个东西最好当时就把他搞懂，不然会导致浪费记忆网。必须高频回顾。</p>
<h5 id="学习低谷"><a href="#学习低谷" class="headerlink" title="学习低谷"></a>学习低谷</h5><p>学习一门技术的时候，初期学习回报率最大，中期回报率最低，只要熬过了中期，回报率呈指数级增长。</p>
<p>根本原因是以前学习的东西都忘掉啦，想学的东西太多了，我们太过傲慢，总认为自己一目十行，急功近利。必须狠下心高频回顾，才能急速推进。</p>
<p><img src="/2022/07/18/%E5%AD%A6%E4%B9%A0%E6%B3%95%E6%80%BB%E7%BB%93/1658155047012.png" alt="1658155047012"></p>
<p>通常人的学习焦虑在于刚学会了基本的加减乘除就像掌握量子力学方程。</p>
]]></content>
      <categories>
        <category>生活</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>经验法</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh协议以及JavaSSH工具使用</title>
    <url>/2022/06/12/ssh%E5%8D%8F%E8%AE%AE%E4%BB%A5%E5%8F%8AJavaSSH%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>​    <a id="more"></a></p>
<p>!!!! 本文章为个人知识成果，转载请注明出处。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>3月中旬，公司的客户突发奇想，想要在我们的系统里面直接下载自己的远程服务器上的某个给定路径上的文件，还要求每次取日志末尾多少行由我自己来定，这种任务被分配到的身上了，给了三天时间来完成开发测试。【os：卧槽，我一看，这是要考验我开发能力啊，那我不得表现一番】。于是开启了苦逼的<strong>调研</strong>加<strong>开发</strong>加<strong>测试</strong>的过程。最后终于搞完了，然后老大让我把过程总结一下，介绍一下相关的知识，并写一个SSH工具类放到公司库中供大家使用。【os: 卧槽，我一看，这是要考验我的<strong>语言表达能力</strong>以及<strong>学习能力</strong>啊，那我不得表现一番，研究透彻了再表达清楚了】</p>
<h2 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h2><p><a href="https://zhuming-github.github.io/2022/06/12/计算机网络总结/">五层网络协议模型</a></p>
<h2 id="远程登录协议简介"><a href="#远程登录协议简介" class="headerlink" title="远程登录协议简介"></a>远程登录协议简介</h2><p>远程登录协议，是对我们在一台机器上操作另一台机器的过程的规范化表示。每台机器都是用了基本的网络层服务，提供了基本的远程登录能力。</p>
<p>传统的远程登录协议有Telnet(终端仿真协议)、 <strong>rcp ftp</strong>、 <strong>rlogin</strong>、<strong>rsh</strong>，其他在通信期间会使用明文传送数据，包括登录时的ID和密码数据没有加密就传到网络上，存在安全上的问题。甚至即使在内部网上，也可能有被在外网上的主机窃取和篡改等危险性。而 Secure Shell，安全外壳协议，简称ssh，一种基于TCP协议实现的应用层协议，将包括密码在内的所有数据都已进行了加密处理，可以进行更安全的远程操作。实现ssh客户端和ssh服务器端的连接，也就是说ssh协议是基于C/S结构，可以用来进行远程控制，或在计算机之间传送文件。但是目前市场上由于协议标准的不同而存在SSH1和SSH2两个不同的版本，两个版本互不兼容，SSH2避免了SSH1协议的非对称加密算法的专利权问题以及解决了SSH1的数据完整性校验的漏洞。基于以上这些，远程登录协议一般采用SSH的版本2。</p>
<p><strong>SSH2主要功能</strong></p>
<ol>
<li>远程联机执行命令相当于 安全的telnet 的远程联机使用 shell的作用</li>
<li>更安全的文件传输相当于安全的FTP服务</li>
</ol>
<h2 id="SSH基本原理"><a href="#SSH基本原理" class="headerlink" title="SSH基本原理"></a>SSH基本原理</h2><ol>
<li>建立加密连接通道-&gt;供后续信息传输用。</li>
</ol>
<p>服务器端把公钥明文【没必要密文传送，公钥本就是公开的】发给客户端，客户端收到公钥后，对自己的~/.ssh/known_hosts文件进行修改，新增或者修改一条 【域名或者ip 公钥】记录。然后计算自己的公私钥，并使用远程机器的公钥加密并传自己的公钥给远程机器。此时</p>
<p>远程机器上有自己的私钥+控制它的机器的公钥</p>
<p>本地机器上有自己的私钥+远程机器上的公钥</p>
<p>这种不对称的方式叫做非对称加密。</p>
<p>客户端发送数据，使用私钥加密，服务器接收到数据后，使用对方的公钥解密；服务器发送数据使用客户端的公钥加密，客户端接收到数据后使用自己的私钥解密，这样就保证了数据传输的安全型。</p>
<p>然后双方机器使用自己的私钥和对方的公钥生成一个仅用于本次会话的临时密钥，采用了Diffie-Hellman算法，两者各自计算出的会话密钥应该是相同的，即对称加密方式。这个临时密钥仅用于本次session会话期间的数据加密。</p>
<ol>
<li><p>服务器用户身份验证-&gt;确定是否要给该用户开放访问权限。有如下方式</p>
</li>
<li><ol>
<li>密码登录：虽然交互数据被加密了，但是为了省事以及防止暴力破解了用户密码，因此不推荐使用</li>
<li>密钥登录：如果采用了此种登录方式，那么不会要求进行密码的输入。在基本加密连接通道建立后，客户端会自动使用服务器的公钥加密并发送自己的公钥ID给服务器，服务器检查自己的authorized_keys 里面是否有此ID对应的公钥，有则生成一个随机数字并用ID对应的公钥加密传递给客户机，同时生成给随机数字的md5哈希后的hash值保存到本地机器。客户机收到后用私钥解密，然后也用md5哈希算法求出hash值，然后传递给服务器与服务器的hash值，对比，相同则通过验证开放权限给客户端。</li>
</ol>
</li>
</ol>
<h2 id="SSH工作流程"><a href="#SSH工作流程" class="headerlink" title="SSH工作流程"></a>SSH工作流程</h2><ol>
<li><p>服务器启动sshd，如果是第一次启动，则会生成对应的公钥和私钥到目录/etc/ssh下；不是第一次启动则直接获取公钥。</p>
</li>
<li><p>然后sshd程序监听配置的端口【默认是22端口】，等待客户端连接</p>
</li>
<li><p>如果某个客户端想要连接远程服务器，先三次握手建立TCP连接</p>
</li>
<li><p>建立底层TCP连接后，然后开始如下内容</p>
</li>
<li><ol>
<li>版本号协商阶段：服务器向客户端发送ssh版本信息，客户端接受后，解析报文，发现如果版本比自己低，且自己支持低版本的ssh，则使用服务器版本进行沟通，否则使用自己的版本的ssh，并且客户端返回自己决定的ssh版本信息，然后服务器最终决定是否具备沟通的条件。如果不支持客户端的ssh版本则断开TCP连接。如果支持则进入下一步。</li>
<li>密钥和算法协商阶段：SSH支持多种加密算法，服务器、客户端双方根据各自支持的算法，协商出最终用于产生会话密钥的密钥交换算法、用于数据信息加密的加密算法、用于进行数字签名和认证的公钥算法以及用于数据完整性保护的HMAC算法。</li>
<li>密钥交换：服务器和客户端通过密钥交换算法，动态生成共享的会话密钥和会话ID，建立加密通道。会话密钥主要用于后续数据传输的加密，会话ID用于在认证过程中标识该SSH连接。这个过程对应上面SSH工作原理的密钥交换过程。</li>
<li>用户认证：SSH客户端向服务器端发起认证请求，服务器端对客户端进行认证。支持密码（password）登录【用户输入用户名密码让服务器校验是否通过，通过之后发送验证】、密钥登录等等。</li>
<li>会话请求：认证通过后，SSH客户端向服务器端发送会话请求，请求建立会话。</li>
<li>会话交互：会话建立后，SSH服务器端和客户端在该会话上进行数据信息的交互。</li>
</ol>
</li>
<li><p>数据传输：用户机与服务器之间直接进行沟通</p>
</li>
</ol>
<p>在工作中如何使用</p>
<p>在你想要远程控制的机器上安装opensssh的服务端程序openssh-server</p>
<p>修改/etc/ssh/sshd_config配置文件，然后启动sshd服务</p>
<p>在你想要控制远程机器的机器上安装openssh-client，并启动即可</p>
<p>关于opensssh工具的具体使用可以看<a href="https://www.cnblogs.com/wwufengg/articles/ssh-openssh-detail.html">这里</a></p>
<h2 id="Java-SSH工具介绍"><a href="#Java-SSH工具介绍" class="headerlink" title="Java SSH工具介绍"></a>Java SSH工具介绍</h2><h3 id="1-JSch"><a href="#1-JSch" class="headerlink" title="1. JSch"></a>1. JSch</h3><p> 用过，玛德，bug一堆，使用体验极差，官方文档描述极差，白白浪费我半天时间。不建议大家使用。</p>
<h3 id="2-Ganymed"><a href="#2-Ganymed" class="headerlink" title="2. Ganymed"></a>2. Ganymed</h3><p>使用过，体验还好，官方提供了文档讲解非常详细，因此最终开发就采用这个工具。这个框架对SSH协议的上述的工作流程的1-4.c进行了封装实现，后续的流程由于涉及用户密码这些无法自动化配置的东西，因此需要使用者编程进行。</p>
<h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4>  <details> 
      <summary>步骤</summary> 
      <ol>
          <li>建立连接->connection = new Connection(ip, port);connection.connect();</li>
          <li>认证登录->boolean isAuthenticated = connection.authenticateWithPassword(username, password);</li>
          <li>开启会话->Session session = connection.openSession();</li>
          <li>执行命令->session.execCommand(command);</li>
          <li>处理结果->StreamGobbler normalInfo = new StreamGobbler(session.getStdout());StreamGobbler errInfo = new StreamGobbler(session.getStderr());</li>
          <li>关闭资源->normalReader.close();errReader.close();session.close();</li>
      </ol>
</details>  

<p><strong>tip:</strong></p>
<ul>
<li><p>SSH协议规定对于本地机器，使用一个窗口来接受远程机器的stdout数据以及stderr数据，当本地机器的窗口被塞满了，远程机器的发送线程|进程会阻塞，本地机器消费掉本地窗口中的数据后，远程机器才会继续发送。如下图，由于stdout与stderr共用一个窗口，所以两者都必须要同时进行消费才能，即开两个线程进行消费，但是不用担心，这个工具给我们提供了StreamGobbler类，其底层开启线程读取数据到本地缓存【如下代码1】，我们只要对此StreamGobbler对象进行同步读取就行了，此时数据读取的代码【如下代码2】。如果不喜欢使用关方的线程读取数据的方法，也可以自己开启两个线程分别处理stdout以及strerr, 两个线程中使用session.waitForCondition或者stdout.available以及stderr.available方法判断是否可以开始读取。</p>
<p><img src="/2022/06/12/ssh%E5%8D%8F%E8%AE%AE%E4%BB%A5%E5%8F%8AJavaSSH%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/1655603467648.png" alt="1655603467648"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StreamGobbler</span><span class="params">(InputStream is)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.is = is;</span><br><span class="line">    t = <span class="keyword">new</span> GobblerThread();</span><br><span class="line">    t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StreamGobbler normalInfo = <span class="keyword">new</span> StreamGobbler(session.getStdout());</span><br><span class="line">StreamGobbler errInfo = <span class="keyword">new</span> StreamGobbler(session.getStderr());</span><br><span class="line"> <span class="comment">// 获取err 以及 正常的执行返回信息，由于err 与 stdout共用一个窗口，所以此处一般必须要都获取</span></span><br><span class="line">BufferedReader normalReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(normalInfo));</span><br><span class="line">BufferedReader errReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(errInfo));</span><br><span class="line"><span class="comment">// 下面这两个循环语句，放在一个线程里面执行没有问题的，因为一个命令执行结果无非就是两种，两种不可能同时出现。所以无需担心：一个远程机器先返回错误信息后导致后返回的标准输出信息丢失。当然如果你是这种语句"cd xx;xxx;xxxx"那么可能会出现这种问题，但是这种极端情况非常非常难以出现。</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    String line = normalReader.readLine();</span><br><span class="line">    <span class="keyword">if</span> (line == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    String line = errReader.readLine();</span><br><span class="line">    <span class="keyword">if</span> (line == <span class="keyword">null</span> || line.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个session只能执行一条命令，这是ssh协议规定了，且每次执行命令的默认路径都是用户home目录下。我们可以用如下方法实现执行多行命令；</p>
<ul>
<li>单行多条命令：[xxx;yyy;sss]</li>
<li>搞个命令的list，开启多个session，每次执行一条命令。虽然一个Connection可以开启多个session，但是服务器端为一个Connection开启的会话个数一般是有限制的，可以通过修改openssh程序的配置改变最大会话数。</li>
<li>session.startShell(),这个我们用过，估计应该是类似JSch那种命令行式的shell吧，直接把控制台转化成远程shell，然后用户输入，执行。</li>
</ul>
</li>
<li><p>认证失败，可能是服务器没有开启密码认证方式</p>
<ul>
<li>服务器开启密码登录方式</li>
<li>使用密钥登录方式</li>
</ul>
</li>
</ul>
<h4 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h4><ul>
<li><p><strong>ChannelCondition</strong></p>
<p>一个接口，定义了本地机器与远程机器交互过程中可能出现的的状态码。</p>
<ul>
<li><a href="http://www.ganymed.ethz.ch/ssh2/javadoc/ch/ethz/ssh2/ChannelCondition.html#EOF">EOF</a>：表示已经读到了文件的末尾，也就是SSH服务器传送过来一个文件结束符</li>
<li>TIMEOUT:表示通道已经超时了但是其他条件可能满足，比如EOF条件满足了，但是也超时了。</li>
</ul>
<p>​     使用<code>(cond &amp; ChannelCondition.CLOSED) != 0</code>，来判断是否以及超时。 </p>
<ul>
<li>CLOSED：表示底层通道已经关闭了，尽管本地窗口中可能仍然有未读取的数据，也会被强制EOF掉，无法读取。</li>
<li>STDOUT_DATA：表示本地窗口中的标准输出数据可以读取了</li>
<li>STDERR_DATA：类上</li>
<li>EOF：表示远程服务机器上的数据都已经发送完毕，但是stdout与stderr流<strong>可能</strong>会被远程机器同时设置成EOF，导致本地窗口数据丢失。</li>
<li>EXIT_STATUS：远程机器结束工作后可能会发送退出状态，此时就可以通过这个状态来判断</li>
</ul>
</li>
<li><p>Connection </p>
<p>用来与服务器建立TCP/IP连接</p>
<p>构造器</p>
<ul>
<li>Connection(String hostname, int port)</li>
</ul>
<p>建立连接</p>
<ul>
<li>connect()：与服务器建立TCP/IP连接，进行后续操作</li>
</ul>
<p>获取连接信息</p>
<ul>
<li>ConnectionInfo getConnectionInfo()：连接信息里面包含了交互双方的加密算法信息，主机的公钥等</li>
</ul>
<p>认证方法（返回值均为boolean）</p>
<ul>
<li>authenticateWithPublicKey(String user, char[] pemPrivateKey,String password)：通过密钥认证登录，没试过，流程大概是：本地机器上生成公私钥，然后将公钥手动拷贝到服务器，然后通过此方法把 自己的私钥加密传输给服务器。这里的password是，pem文件的加密的密码，如果没有被加密，则可以设置为null。</li>
<li>authenticateWithPassword(String user, String password)：密码认证方式，推荐</li>
</ul>
<p>开启会话</p>
<ul>
<li>Session openSession()：会话可用于执行命令</li>
</ul>
<p>创建SCP客户端</p>
<ul>
<li>SCPClient createSCPClient()：返回一个SCPClient对象，该对象可被用于文件传输。</li>
</ul>
</li>
<li><p>SCPClient （用来与服务器之间进行文件传输的类）</p>
<ul>
<li>上传<ul>
<li>public void put(String localFile, String remoteTargetDirectory)：将一个本地文件上传到远程服务器的某个目录下</li>
<li>void put(String[] localFiles, String remoteTargetDirectory)：同上为一个一堆文件</li>
<li>void put(String localFile, String remoteTargetDirectory, String mode)：将一个文件上传并设置其权限</li>
<li>public void put(String localFile, String remoteFileName, String remoteTargetDirectory, String mode)：将一堆文件上传并设置权限</li>
<li>public void put(byte[] data, String remoteFileName, String remoteTargetDirectory): 将一个字节数组上传到某个文件中</li>
<li>…</li>
</ul>
</li>
<li>下载<ul>
<li>get(String remoteFile, String localTargetDirectory)</li>
<li>get(String remoteFile, OutputStream target)：获取文件到某个输出流中</li>
<li>get(String[] remoteFiles, String localTargetDirectory)：将远程目录下的一堆文件拷贝到本地</li>
</ul>
</li>
</ul>
<p>tip：默认远程路径都是用户home目录下。</p>
</li>
<li><p>SFTP与SCP功能类似，但是更加强大，但传输效率不如SCP。</p>
</li>
</ul>
<h4 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取连接对象</span></span><br><span class="line"><span class="comment"> * 调用connect()方法</span></span><br><span class="line"><span class="comment"> * 进行身份认证</span></span><br><span class="line"><span class="comment"> * 开启会话</span></span><br><span class="line"><span class="comment"> * 执行命令</span></span><br><span class="line"><span class="comment"> * 关闭并释放资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SSHClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Logger logger = LoggerFactory.getLogger(SSHClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  <span class="keyword">private</span> String ip;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line">  <span class="keyword">private</span> Connection connection;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SSHClient</span><span class="params">(String configPath)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取配置信息</span></span><br><span class="line">      SSHConfiguration sshConfiguration = <span class="keyword">new</span> SSHConfiguration(<span class="string">"E:\\DataCodeFile\\Java\\IdeaProjects\\Utils\\src\\main\\java\\com\\nju\\zm\\ssh\\ssh.properties"</span>);</span><br><span class="line">      <span class="keyword">this</span>.ip = sshConfiguration.getPropValue(<span class="string">"host.ip"</span>);</span><br><span class="line">      <span class="keyword">this</span>.port = Integer.parseInt(sshConfiguration.getPropValue(<span class="string">"host.port"</span>));</span><br><span class="line">      <span class="keyword">this</span>.username = sshConfiguration.getPropValue(<span class="string">"host.username"</span>);</span><br><span class="line">      <span class="keyword">this</span>.password = sshConfiguration.getPropValue(<span class="string">"host.password"</span>);</span><br><span class="line">      <span class="comment">// 建立TCP/IP连接</span></span><br><span class="line">      <span class="keyword">this</span>.connection = <span class="keyword">new</span> Connection(ip, port);</span><br><span class="line">      <span class="keyword">this</span>.connection.connect();</span><br><span class="line">      <span class="comment">// 密码认证</span></span><br><span class="line">      <span class="keyword">boolean</span> isAuthenticated = <span class="keyword">this</span>.connection.authenticateWithPassword(username, password);</span><br><span class="line">      <span class="comment">// 密钥认证，试了二十几次，一直不行，估计是密钥格式问题</span></span><br><span class="line"><span class="comment">//      boolean isAuthenticated = this.connection.authenticateWithPublicKey(username, new File("C:\\Users\\me\\.ssh\\id_rsa"), null);</span></span><br><span class="line">      <span class="keyword">if</span> (!isAuthenticated) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"认证失败"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      logger.info(<span class="string">"用户&#123;&#125;登录成功"</span>, username);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      logger.info(e.getMessage());</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      logger.info(e.getMessage());</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 执行一条命令</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> command 一条命令</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeCommand</span><span class="params">(String command)</span> </span>&#123;</span><br><span class="line">    Session session = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      session = connection.openSession();</span><br><span class="line">      session.execCommand(command);</span><br><span class="line">      <span class="comment">// 处理命令的执行结果</span></span><br><span class="line">      handleOutput(session);</span><br><span class="line">      Integer exitStatus = session.getExitStatus();</span><br><span class="line">      logger.info(<span class="string">"命令：&#123;&#125; -&gt; 执行结果：&#123;&#125;"</span>, command, Objects.nonNull(exitStatus) ? exitStatus : <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      logger.warn(e.getMessage());</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(session))</span><br><span class="line">          session.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">"资源关闭失败:&#123;&#125;"</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 执行本地的某个shell脚本</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> shellPath 脚本的绝对路径</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runShell</span><span class="params">(String shellPath)</span> </span>&#123;</span><br><span class="line">    Session session = <span class="keyword">null</span>;</span><br><span class="line">    BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">    PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      session = connection.openSession();</span><br><span class="line">      session.requestPTY(<span class="string">"bash"</span>);</span><br><span class="line">      session.startShell();</span><br><span class="line">      reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(shellPath)));</span><br><span class="line">      out = <span class="keyword">new</span> PrintWriter(session.getStdin());</span><br><span class="line">      String readLine = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">while</span> (Objects.nonNull(readLine = reader.readLine())) &#123;</span><br><span class="line">        out.println(readLine);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 必须要有一个logout语句，不然服务器会以为你想保持沟通，便不会发送EOF</span></span><br><span class="line">      out.println(<span class="string">"exit"</span>);</span><br><span class="line">      out.flush();</span><br><span class="line">      <span class="comment">// 处理输出结果</span></span><br><span class="line">      handleOutput(session);</span><br><span class="line">      Integer exitStatus = session.getExitStatus();</span><br><span class="line">      logger.info(<span class="string">"执行结果：&#123;&#125;"</span>, Objects.nonNull(exitStatus) ? exitStatus : <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      logger.info(e.getMessage());</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        out.close();</span><br><span class="line">        reader.close();</span><br><span class="line">        session.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.warn(e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 处理每个会话的输出结果</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> session 一个会话</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleOutput</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">    BufferedReader normalReader = <span class="keyword">null</span>;</span><br><span class="line">    BufferedReader errReader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取err 以及 正常的执行返回信息，由于err 与 stdout共用一个窗口，所以此处一般必须要都获取</span></span><br><span class="line">      normalReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> StreamGobbler(session.getStdout())));</span><br><span class="line">      errReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> StreamGobbler(session.getStderr())));</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        String line = normalReader.readLine();</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(line)) <span class="keyword">break</span>;</span><br><span class="line">        logger.info(<span class="string">"$: &#123;&#125;"</span>,line);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        String line = errReader.readLine();</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(line)) <span class="keyword">break</span>;</span><br><span class="line">        logger.info(<span class="string">"$: &#123;&#125;"</span>,line);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      logger.info(e.getMessage());</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (normalReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">          normalReader.close();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.info(<span class="string">"NormalReader关闭失败&#123;&#125;"</span>, e.getMessage());</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (errReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">          errReader.close();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.info(<span class="string">"ErrReader关闭失败&#123;&#125;"</span>, e.getMessage());</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 下载文件：使用现成的的ScpClient即可，底层会自动帮我们开启会话，关闭等动作</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> remoteFile           远程文件路径 默认是到home目录下的文件</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> localTargetDirectory 本地目录</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getFile</span><span class="params">(String remoteFile, String localTargetDirectory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      SCPClient client = <span class="keyword">new</span> SCPClient(connection);</span><br><span class="line">      client.get(remoteFile, localTargetDirectory);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 上传文件</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> localFile             本地文件路径</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> remoteTargetDirectory 远程目录</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putFile</span><span class="params">(String localFile, String remoteTargetDirectory)</span> </span>&#123;</span><br><span class="line">    SCPClient client = <span class="keyword">new</span> SCPClient(connection);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      client.put(localFile, remoteTargetDirectory);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 关闭资源</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">      connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SSHClient sshClient = <span class="keyword">new</span> SSHClient(<span class="string">"E:\\xx\\ssh\\ssh.properties"</span>);</span><br><span class="line">sshClient.runShell(<span class="string">"xx\\test.txt"</span>);</span><br><span class="line">sshClient.getFile(<span class="string">"nowcoder.txt"</span>,<span class="string">"D:/"</span>);</span><br><span class="line">sshClient.executeCommand(<span class="string">"echo 'HELLO ZI　YOU'"</span>);</span><br><span class="line">sshClient.executeCommand(<span class="string">"echo 'WO LAI　LE'"</span>);</span><br><span class="line">sshClient.close();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端</category>
        <category>基础</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>JavaSSH工具</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1007</title>
    <url>/2019/09/16/PTA-Basic-1007/</url>
    <content><![CDATA[<p>让我们定义d<br>n<br>​​ 为：d<br>​n<br>​​ =p<br>​n+1<br>​​ −p<br>​n<br>​​ ，其中p<br>​i<br>​​ 是第i个素数。显然有d<br>​1<br>​​ =1，且对于n&gt;1有d<br>​n<br>​​ 是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。</p>
<p>现给定任意正整数N(&lt;10<br>​5<br>​​ )，请计算不超过N的满足猜想的素数对的个数。</p>
<p>输入格式:</p>
<pre><code>输入在一行给出正整数N。</code></pre><p>输出格式:</p>
<pre><code>在一行中输出不超过N的满足猜想的素数对的个数。</code></pre><p>输入样例:</p>
<pre><code>20</code></pre><p>输出样例:</p>
<pre><code>4</code></pre><hr>
<p>分析：<br>1题目要求给出一个数字要求输出这个数字以内的素数对个数。</p>
<p>2素数对条件（1为素数，2两个素数相差2）；</p>
<p>思路：</p>
<p>1做一个判断是否时素数的函数。</p>
<p>2因为素数必定不为除2以外的偶数，所以直接从3开始去奇数判断是否为素数，并判断这个数字加2是否也是素数，如果是，则计算素数对个数的变量加1，否则就继续循环，直到超过所给的数字的大小。</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n+<span class="number">1</span>);i+=<span class="number">2</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> n;</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">   <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">   	<span class="keyword">if</span>(isPrime(i)&amp;&amp;isPrime(i+<span class="number">2</span>)&amp;&amp;(i+<span class="number">2</span>)&lt;=n)&#123;</span><br><span class="line">   		num++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d"</span>,num);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-6</title>
    <url>/2020/05/10/LeetCode-6/LeetCode-6/</url>
    <content><![CDATA[<h1 id="Z字形变换"><a href="#Z字形变换" class="headerlink" title="Z字形变换"></a>Z字形变换</h1><a id="more"></a>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</span><br><span class="line"></span><br><span class="line">比如输入字符串为 &quot;LEETCODEISHIRING&quot; 行数为 3 时，排列如下：</span><br><span class="line"></span><br><span class="line">	L   C   I   R</span><br><span class="line">	</span><br><span class="line">	E T O E S I I G</span><br><span class="line">	</span><br><span class="line">	E   D   H   N</span><br><span class="line"></span><br><span class="line">之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;LCIRETOESIIGEDHN&quot;。</span><br><span class="line"></span><br><span class="line">请你实现这个将字符串进行指定行数变换的函数：</span><br><span class="line"></span><br><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;LEETCODEISHIRING&quot;, numRows &#x3D; 3</span><br><span class="line"></span><br><span class="line">输出: &quot;LCIRETOESIIGEDHN&quot;</span><br></pre></td></tr></table></figure>

<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;LEETCODEISHIRING&quot;, numRows &#x3D; 4</span><br><span class="line">输出: &quot;LDREOEIIECIHNTSG&quot;</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">	L     D     R</span><br><span class="line">	E   O E   I I</span><br><span class="line">	E C   I H   N</span><br><span class="line">	T     S     G</span><br></pre></td></tr></table></figure>
<h2 id="思路1-根据规律取字符"><a href="#思路1-根据规律取字符" class="headerlink" title="思路1-根据规律取字符"></a>思路1-根据规律取字符</h2><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(numRows==<span class="number">1</span>)<span class="keyword">return</span> s;</span><br><span class="line">	    <span class="keyword">int</span> n=s.length();</span><br><span class="line">	    <span class="keyword">int</span> cycleLen=<span class="number">2</span>*numRows-<span class="number">2</span>;</span><br><span class="line">	    StringBuilder result=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)&#123;</span><br><span class="line">	    	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j+i&lt;n;j=j+cycleLen)&#123;</span><br><span class="line">	    		result.append(s.charAt(i+j));</span><br><span class="line">	    		<span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;i!=numRows-<span class="number">1</span>&amp;&amp;j+cycleLen-i&lt;n)&#123;</span><br><span class="line">	    			result.append(s.charAt(j+cycleLen-i));<span class="comment">//每一次的周长都是cycleLen</span></span><br><span class="line">	    		&#125;</span><br><span class="line">	    	&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> result.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度：O-n-2"><a href="#时间复杂度：O-n-2" class="headerlink" title="时间复杂度：O(n^2)"></a>时间复杂度：O(n^2)</h3><h2 id="思路2-模拟表现"><a href="#思路2-模拟表现" class="headerlink" title="思路2-模拟表现"></a>思路2-模拟表现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过从左向右迭代字符串，我们可以轻松地确定字符位于 Z 字形图案中的哪一行。</span><br></pre></td></tr></table></figure>
<h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">       List&lt;StringBuilder&gt; rows = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.min(numRows, s.length()); i++)</span><br><span class="line">           rows.add(<span class="keyword">new</span> StringBuilder());</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> curRow = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">boolean</span> goingDown = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">           rows.get(curRow).append(c);</span><br><span class="line">           <span class="keyword">if</span> (curRow == <span class="number">0</span> || curRow == numRows - <span class="number">1</span>) goingDown = !goingDown;</span><br><span class="line">           curRow += goingDown ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       StringBuilder ret = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">       <span class="keyword">for</span> (StringBuilder row : rows) ret.append(row);</span><br><span class="line">       <span class="keyword">return</span> ret.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-5</title>
    <url>/2020/05/10/LeetCode-5/LeetCode-5/</url>
    <content><![CDATA[<h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;longest-palindromic-substring</span><br></pre></td></tr></table></figure>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure>

<h2 id="思路1-中心扩展法"><a href="#思路1-中心扩展法" class="headerlink" title="思路1-中心扩展法"></a>思路1-中心扩展法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从左向右，选定一个字符，然后根据两边可扩展的回文字符串的最大长度，作为该字符所能构建的最大的回文字符串，</span><br><span class="line">用一个方法返回该长度，并与上一个长度比较，进行相应的记录。</span><br><span class="line"></span><br><span class="line">注意：在求解过程中，基数的回文子串与偶数的回文子串是不一样的。比如最长回文子串为aba，对称中心就是b，如果</span><br><span class="line">最长回文子串为abba，则对称中心应该为两个b之间.</span><br></pre></td></tr></table></figure>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(s.length()&lt;<span class="number">1</span>||s==<span class="keyword">null</span>)&#123;<span class="comment">//首先判断特殊情况</span></span><br><span class="line">			<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> len1=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> len2=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> maxLength=<span class="number">0</span>,start=<span class="number">0</span>,end=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">			len1=expend(s,i,i);<span class="comment">//如果回文子串字符数是奇数</span></span><br><span class="line">			len2=expend(s,i,i+<span class="number">1</span>);<span class="comment">//如果回文子串字符数是偶数</span></span><br><span class="line">			maxLength=Math.max(len1, len2);</span><br><span class="line">			<span class="keyword">if</span>(maxLength&gt;(end-start))&#123;</span><br><span class="line">				start=i-((maxLength-<span class="number">1</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">				end=i+(maxLength&gt;&gt;<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s.substring(start,end+<span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">expend</span><span class="params">(String s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(left&gt;-<span class="number">1</span>&amp;&amp;right&lt;s.length()&amp;&amp;s.charAt(left)==s.charAt(right))&#123;</span><br><span class="line">			right++;</span><br><span class="line">			left--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> right-left-<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度：O-n-2"><a href="#时间复杂度：O-n-2" class="headerlink" title="时间复杂度：O(n^2)"></a>时间复杂度：O(n^2)</h3><h2 id="思路2-Manacher"><a href="#思路2-Manacher" class="headerlink" title="思路2-Manacher"></a>思路2-Manacher</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">该算法实质上是中心扩展方法的变质，只不过将中心扩展方法求以一个字符为中心向左右两边扩展的方法利用了此</span><br><span class="line">字符之前的其他字符求的辅助长度：详细见连接：[https:&#x2F;&#x2F;www.cxyxiaowu.com&#x2F;2665.html](https:&#x2F;&#x2F;www.cxyxiaowu.com&#x2F;2665.html &quot;马拉车算法详解&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="代码1-1"><a href="#代码1-1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Five_Manacher</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> s 要添加分隔符的字符串</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> r.toString() 添加之后的字符串</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">addBoundaries</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">		StringBuilder r=<span class="keyword">new</span> StringBuilder();        </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">			r.append(<span class="string">"#"</span>+c);</span><br><span class="line">		&#125;</span><br><span class="line">        r.append(<span class="string">"#"</span>);</span><br><span class="line">		<span class="keyword">return</span> r.toString();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(s==<span class="keyword">null</span>||s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//得到处理之后的字符串（恒为奇数个字符）,此处要保留原字符串</span></span><br><span class="line">		String str=addBoundaries(s);</span><br><span class="line">		<span class="comment">//新字符串的长度</span></span><br><span class="line">		<span class="keyword">int</span> nLen=s.length()*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">		<span class="comment">//辅助数组</span></span><br><span class="line">		<span class="keyword">int</span> p[]= <span class="keyword">new</span> <span class="keyword">int</span>[nLen];</span><br><span class="line">		<span class="comment">//最大回文字符串中心 ，最右边界</span></span><br><span class="line">		<span class="keyword">int</span> center=<span class="number">0</span>,maxRight=<span class="number">0</span>;</span><br><span class="line">		<span class="comment">//最大回文字符串的长度</span></span><br><span class="line">		<span class="keyword">int</span> maxLen=<span class="number">1</span>;</span><br><span class="line">		<span class="comment">//结果字符串的起点</span></span><br><span class="line">		<span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left,right,mirror;</span><br><span class="line">        <span class="keyword">char</span>[]chs=str.toCharArray();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nLen;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i&lt;maxRight)&#123;<span class="comment">//当前字符在最右回文边界左边，可以直接利用镜像字符的辅助数组值</span></span><br><span class="line">				mirror=<span class="number">2</span>*center-i;</span><br><span class="line">				p[i] = (maxRight - i)&gt;p[mirror]?p[mirror]:(maxRight - i);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//防止maxRight-i的长度等于p[mirror],</span></span><br><span class="line">            <span class="comment">//那么就是因为左边的字符而停止扩展回文字符串的，就该继续扩展</span></span><br><span class="line">			left=i-p[i]-<span class="number">1</span>;<span class="comment">//目前到达的左边回文字符串的位置</span></span><br><span class="line">			right=i+p[i]+<span class="number">1</span>;<span class="comment">//目前到达的右边回文字符串的位置</span></span><br><span class="line">			<span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;nLen&amp;&amp;chs[left]==chs[right])&#123;</span><br><span class="line">				left--;</span><br><span class="line">				right++;</span><br><span class="line">				p[i]++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i+p[i]&gt;maxRight)&#123;<span class="comment">//可能会更新最右边界</span></span><br><span class="line">				maxRight=i+p[i];</span><br><span class="line">				center=i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(p[i]&gt;maxLen)&#123;<span class="comment">//最长回文字符串的长度，要实时更新</span></span><br><span class="line">				maxLen=p[i];</span><br><span class="line">				start=(i&gt;&gt;<span class="number">1</span>)-(maxLen&gt;&gt;<span class="number">1</span>);<span class="comment">//i/2代表的是去掉分隔符起始字符的位置，maxLen/2代表将此处回文字符串中分隔符去掉</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s.substring(start,start+maxLen);		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O(n)"></a>时间复杂度：O(n)</h3><h2 id="思路3（最优解）"><a href="#思路3（最优解）" class="headerlink" title="思路3（最优解）"></a>思路3（最优解）</h2><h2 id="代码3"><a href="#代码3" class="headerlink" title="代码3"></a>代码3</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span> || s == <span class="keyword">null</span>)  <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">char</span> []c = s.toCharArray();</span><br><span class="line">		longestPalindrome(c,<span class="number">0</span>);	</span><br><span class="line">		<span class="keyword">return</span> s.substring(start, end+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">longestPalindrome</span><span class="params">(<span class="keyword">char</span> [] c, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=c.length-<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> cur_start = index;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> cur_end = index;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(cur_end&lt;c.length-<span class="number">1</span>&amp;&amp;c[cur_end]==c[cur_end+<span class="number">1</span>])</span><br><span class="line">			cur_end++;</span><br><span class="line">		</span><br><span class="line">		index = cur_end;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(cur_start&gt;<span class="number">0</span>&amp;&amp;cur_end&lt;c.length-<span class="number">1</span>&amp;&amp;c[cur_start-<span class="number">1</span>]==c[cur_end+<span class="number">1</span>]) &#123;</span><br><span class="line">			cur_start--;</span><br><span class="line">			cur_end++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(cur_end-cur_start &gt; end-start) &#123;</span><br><span class="line">			start = cur_start;</span><br><span class="line">			end = cur_end;</span><br><span class="line">		&#125;</span><br><span class="line">		longestPalindrome(c,index+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-2</title>
    <url>/2019/10/19/LeetCode-2/LeetCode-2/</url>
    <content><![CDATA[<h1 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">题目描述：</span><br><span class="line"></span><br><span class="line">给定两个非空链表表示两个非负整数，位数按照逆序存储他们的每个节点只存储单个数字，将两数相加</span><br><span class="line">返回一个新的链表。</span><br><span class="line">你可以假设除了数字0外，这两个数字都不以0开头.&#123;即数字不为（002）转化为输入就是（2-&gt;0-&gt;0）也告诉我们结果不可能出现2-&gt;1-&gt;0-&gt;0这样的&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入（2-&gt;4-&gt;3）,(5-&gt;6-&gt;4)</span><br><span class="line"></span><br><span class="line">输出（7-&gt;0-&gt;8）</span><br><span class="line"></span><br><span class="line">原因：342+465&#x3D;807</span><br></pre></td></tr></table></figure>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一：</span><br><span class="line"></span><br><span class="line">	通过Java自带的ArrayList数组列表，存放数值，并进行运算（首先取出两个数组列表上的相同位置处的数</span><br><span class="line">	值，若一个没有另外一个长则长的部分数值就是0，定义一个carry用于存放余数，定义一个sum用于存放和，然后</span><br><span class="line">	根据将sum对10取余的结果放入ArrayList,注意如果结尾余数不为0，那么还要将余数放入ArrayList中，防止进数</span><br><span class="line">	的丢失）</span><br><span class="line"></span><br><span class="line">二：</span><br><span class="line"></span><br><span class="line">	使用自定义的ListNode节点类（包含值与指向下一个对象的指针），首先初始化一个头结点，注意此头结点不</span><br><span class="line">	作为返回值的一部分，然后定义对输入的两个链表的两指针（用于取出链表上的每个数值），在定义一指向头</span><br><span class="line">	结点的头指针，用于操作结果链表，定义sum,carry分别用于存放和，与进数之后的操作同思路1。</span><br></pre></td></tr></table></figure>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">o0002</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//		ArrayList&lt;Integer&gt;a=new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//		a.add(0);</span></span><br><span class="line"><span class="comment">//		ArrayList&lt;Integer&gt;b=new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//		b.add(0);</span></span><br><span class="line"><span class="comment">//		a.add(0);</span></span><br><span class="line"><span class="comment">//		System.out.println(Arrays.toString(Solution_1(a,b).toArray()));</span></span><br><span class="line">		ListNode a=<span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">		ListNode _a=a;</span><br><span class="line">		_a.next=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">		_a=_a.next;</span><br><span class="line">		_a.next=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">		ListNode b=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">		ListNode _b=b;</span><br><span class="line">		_b.next=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">		_b=_b.next;</span><br><span class="line">		_b.next=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">		ListNode result=Solution_2(a,b);</span><br><span class="line">		<span class="keyword">while</span>(result!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">" "</span>+result.getVal());</span><br><span class="line">			result=result.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">Solution_1</span><span class="params">(ArrayList&lt;Integer&gt;a,ArrayList&lt;Integer&gt;b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len_a=a.size();</span><br><span class="line">		<span class="keyword">int</span> len_b=b.size();</span><br><span class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> next=<span class="number">0</span>;</span><br><span class="line">		ArrayList&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Math.max(len_a, len_b);i++) &#123;</span><br><span class="line">			sum=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(i&lt;len_a) &#123;</span><br><span class="line">				sum=sum+a.get(i);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i&lt;len_b) &#123;</span><br><span class="line">				sum=sum+b.get(i);</span><br><span class="line">			&#125;</span><br><span class="line">			sum=sum+next;</span><br><span class="line">			result.add(sum%<span class="number">10</span>);</span><br><span class="line">			next=sum/<span class="number">10</span>;</span><br><span class="line"><span class="comment">//			if(i==Math.max(len_a,len_b)-1&amp;&amp;next!=0) &#123;//此处防止，最高位的进数丢失。处理最高进项到最高位的算法不好</span></span><br><span class="line"><span class="comment">//				result.add(next);</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(next!=<span class="number">0</span>) &#123;<span class="comment">//放在外面判断更容易理解。</span></span><br><span class="line">			result.add(next);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(result.get(result.size()-<span class="number">1</span>)==<span class="number">0</span>&amp;&amp;result.size()&gt;<span class="number">1</span>) &#123;<span class="comment">//此处解决当所有位数都是0的情况，只保留一位0.此处是我多想了，题目中明确说不会以0开头</span></span><br><span class="line">			result.remove(result.size()-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;<span class="comment">//新建一个节点类</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> val;<span class="comment">//存储当前值</span></span><br><span class="line">		<span class="keyword">public</span> ListNode next;<span class="comment">//指向下一个位置</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.val=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">Solution_2</span><span class="params">(ListNode a,ListNode b)</span> </span>&#123;</span><br><span class="line">		ListNode HeadNode=<span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//头节点，不做返回值的一部分。</span></span><br><span class="line">		ListNode p=a,q=b,curr=HeadNode;</span><br><span class="line">		<span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(p!=<span class="keyword">null</span>||q!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> x=p!=<span class="keyword">null</span>?p.getVal():<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> y=q!=<span class="keyword">null</span>?q.getVal():<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> sum=x+y+carry;</span><br><span class="line">			carry=sum/<span class="number">10</span>;</span><br><span class="line">			curr.next=<span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line">			curr=curr.next;</span><br><span class="line">			<span class="keyword">if</span>(p!=<span class="keyword">null</span>) &#123;</span><br><span class="line">				p=p.next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(q!=<span class="keyword">null</span>) &#123;</span><br><span class="line">				q=q.next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(carry!=<span class="number">0</span>) &#123;</span><br><span class="line">			curr.next=<span class="keyword">new</span> ListNode(carry);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> HeadNode.next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-4</title>
    <url>/2020/05/10/LeetCode-4/LeetCode-4/</url>
    <content><![CDATA[<h1 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h1><a id="more"></a>
<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。</span><br><span class="line"></span><br><span class="line">请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</span><br><span class="line"></span><br><span class="line">你可以假设 nums1 和 nums2 不会同时为空。</span><br></pre></td></tr></table></figure>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">nums1 &#x3D; [1, 3]</span><br><span class="line">nums2 &#x3D; [2]</span><br><span class="line"></span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">nums1 &#x3D; [1, 2]</span><br><span class="line">nums2 &#x3D; [3, 4]</span><br><span class="line"></span><br><span class="line">则中位数是 (2 + 3)&#x2F;2 &#x3D; 2.5</span><br></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将所有数字存储到一个数组中，然后根据中位数的求法求中位数。</span><br></pre></td></tr></table></figure>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,time=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> totalNum=nums1.length+nums2.length;</span><br><span class="line">		<span class="keyword">int</span>[] nums=<span class="keyword">new</span> <span class="keyword">int</span>[totalNum];</span><br><span class="line">		<span class="keyword">while</span>(i&lt;nums1.length&amp;&amp;j&lt;nums2.length)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==nums1.length||j==nums2.length)&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(nums1[i]&lt;=nums2[j])&#123;</span><br><span class="line">					nums[time++]=nums1[i++];</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					nums[time++]=nums2[j++];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;nums1.length)&#123;</span><br><span class="line">			nums[time++]=nums1[i++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(j&lt;nums2.length)&#123;</span><br><span class="line">			nums[time++]=nums2[j++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(totalNum%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> (nums[totalNum&gt;&gt;<span class="number">1</span>]+nums[(totalNum&gt;&gt;<span class="number">1</span>)-<span class="number">1</span>])/<span class="number">2.0</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> nums[totalNum&gt;&gt;<span class="number">1</span>]/<span class="number">1.0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度O-n"><a href="#时间复杂度O-n" class="headerlink" title="时间复杂度O(n)"></a>时间复杂度O(n)</h3>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-1</title>
    <url>/2019/10/19/LeetCode-1/LeetCode-1/</url>
    <content><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题目描述：</span><br><span class="line">	给定一个数组，找出其中何为目标值的两个数。（你可以假设每种输入只有一种答案，且同样的元素不能被重复利用）</span><br><span class="line">	实例：</span><br><span class="line">	 给定nums&#x3D;[2,7,11,15],target&#x3D;9;</span><br><span class="line">	 因为nums[0]+nums[1]&#x3D;&#x3D;target&#x3D;2+7&#x3D;9</span><br><span class="line">	 所以返回[0,1]</span><br><span class="line">	 @author zm</span><br></pre></td></tr></table></figure>
<h3 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">一：</span><br><span class="line"></span><br><span class="line">	二重循环，找到即输出。</span><br><span class="line">二：</span><br><span class="line">	使用map，将数组存入map中，然后遍历这个数组，在map中查找target-a[i]的值如果有，说明有解，直接输出。</span><br><span class="line">三：</span><br><span class="line">	使用map，先将一部分数据存储，可以肯定的是，先输入map中的数据中一定没有相加之和位target的两个数字，然后边输入边查找map中是否有target-a[i]的值，如果有那么就直接输出。</span><br></pre></td></tr></table></figure>

<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">o0001</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a[]=<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">2</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">15</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span> target=<span class="number">9</span>;</span><br><span class="line">		<span class="keyword">int</span>[] b=solution_1(a,target);</span><br><span class="line">		System.out.println(Arrays.toString(b));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 解题思路1：先对数组排序，然后从第i个位置开始，由后向前找，如果找到与a[i]的和就是target的立即返回，如果找到和小于target的结束此次外层循环，继续下一次外层循环。</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@time</span> 时间复杂度：O(n^2)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] solution_1(<span class="keyword">int</span> a[],<span class="keyword">int</span> target) &#123;</span><br><span class="line">		Arrays.sort(a);</span><br><span class="line">		<span class="keyword">int</span>[] b=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=a.length-<span class="number">1</span>;j&gt;i;j--) &#123;</span><br><span class="line">				<span class="keyword">if</span>(a[i]+a[j]==target) &#123;</span><br><span class="line">					b[<span class="number">0</span>]=i;</span><br><span class="line">					b[<span class="number">1</span>]=j;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(a[i]+a[j]&lt;target) &#123;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 解题思路2：将数组中的数据放入map中，然后使用一次循环，在map中看有没有target-a[i]的数值的存在，如果有就立即输出，如果到结尾任然没有就抛出异常。</span></span><br><span class="line"><span class="comment">	 * 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] solution_2(<span class="keyword">int</span> a[],<span class="keyword">int</span> target) &#123;</span><br><span class="line">		Map&lt; Integer, Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++) &#123;</span><br><span class="line">			map.put(a[i], i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> value=target-a[i];</span><br><span class="line">			<span class="keyword">if</span>(map.containsKey(value)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i,map.get(value)&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);<span class="comment">//可以用抛出异常代替没有返回值的情况。</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 思路：先将数组的一部分数值放入map中，然后再剩余的数值中找target-a[i]是否再map中出现的，有出现的说明可以组成解。</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] solution_3(<span class="keyword">int</span> a[],<span class="keyword">int</span> target) &#123;</span><br><span class="line">		Map&lt; Integer, Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> component=target-a[i];</span><br><span class="line">			<span class="keyword">if</span>(map.containsKey(component)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i,map.get(component)&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">			map.put(a[i], i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"数组不存在解"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-3</title>
    <url>/2019/10/20/LeetCode-3/LeetCode-3/</url>
    <content><![CDATA[<h1 id="最长无重字符串"><a href="#最长无重字符串" class="headerlink" title="最长无重字符串"></a>最长无重字符串</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个字符串，找出不含重复字符的最长字串的长度。</span><br></pre></td></tr></table></figure>

<h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定字符串“abcabcbb”,没有重复字符的最长字串是“abc”，那么长度就是3.</span><br><span class="line"></span><br><span class="line">给定字符串“bbbbb”,最长的字串就是&quot;b&quot;,长度是1.</span><br><span class="line"></span><br><span class="line">给定&quot;pwwkew&quot;,最长字串是“wke”,长度是3。</span><br><span class="line"></span><br><span class="line">注意：答案必须是一个字串，“pwke”是子序列，而不是子字符串。</span><br></pre></td></tr></table></figure>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">大体上就是一种思路，只是使用的工具不同罢了。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一：</span><br><span class="line"></span><br><span class="line">将输入的字符串一个一个存入集合中，如果集合中已经含有有某个字符了，说明在此处已经达到了一个符合题目要求的字串，如果它的长度比上一个大，就将它的长度赋值给max.只要已经找到重复的字符了，就应该将集合清空，并将这个重复的字符输入到集合中，用于下一次的计算。如果字符集合中没有这个字符也应该输入字符集合，用于下一次的计算。</span><br><span class="line"></span><br><span class="line">二：</span><br><span class="line"></span><br><span class="line">首先定义两个坐标一个用于定位当前字符的位置，另一个用于定位重复字符在字符串中的位置，然后用每个长度与最大值比较（并决定是否改变最大值）。</span><br><span class="line"></span><br><span class="line">三：</span><br><span class="line"></span><br><span class="line">定义一个map用于存放字符与其相应的位置，然后边加入，边查找有没有重复的字符，如果有，取出当前重复字符的位置（与上一个重复字符的位置比较，防止其坐标比上一个重复的字符坐标小）。然后求长度并用当前对打长度与目前所求长度比对。加入这个字符，与对应的位置。</span><br></pre></td></tr></table></figure>

<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">o0003</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(Solution_3(<span class="string">"pwwkew"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> sub 输入的字符串</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> max 用于存储最长字串的长度</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> max 最长字串的长度</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Solution_1</span><span class="params">(String sub)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">		Set&lt;Character&gt; coll=<span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sub.length();i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(coll.contains(sub.charAt(i))) &#123;<span class="comment">//就算此处集合中已经有了这个字符，也应该清空集合，加入这个字符以便下一次的计算。</span></span><br><span class="line">				<span class="keyword">if</span>(coll.size()&gt;max) &#123;</span><br><span class="line">					max=coll.size();</span><br><span class="line">				&#125;</span><br><span class="line">				coll.clear();<span class="comment">//如果有重复的就清空集合</span></span><br><span class="line">			&#125;</span><br><span class="line">			coll.add(sub.charAt(i));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> i 用于记录重复字符的位置。</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> sub</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Solution_2</span><span class="params">(String sub)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> max=<span class="number">0</span>,len=sub.length();</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">		Set &lt;Character&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		<span class="keyword">while</span>(i&lt;len&amp;&amp;j&lt;len) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!set.contains(sub.charAt(j))) &#123;<span class="comment">//如果集合中没有这个字符，就将其加入集合，并将集合的长度与目前为止的最大长度比较，然后决定是否改变它。</span></span><br><span class="line">				set.add(sub.charAt(j++));<span class="comment">//首先将其加入集合中。</span></span><br><span class="line">				max=Math.max(max, j-i);<span class="comment">//比较。</span></span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				set.remove(sub.charAt(i++));<span class="comment">//如果有这个字符了，就一直删除字符，直到找到重复的那个字符,重复的那个字符也会被删除。</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Solution_3</span><span class="params">(String sub)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len=sub.length(),max=<span class="number">0</span>;</span><br><span class="line">		Map&lt;Character,Integer&gt;map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;j&lt;len;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(map.containsKey(sub.charAt(j))) &#123;</span><br><span class="line">				i=Math.max(i, map.get(sub.charAt(j)));<span class="comment">//i用来存储当前已有字符在字符串中的位置。为什么要与上一个i比较呢？因为上一个i代表的是上一个重复的字符在字符串中的位置，而这一个字的位置可能在上一个字符的后面所以因该取他们的最大值。</span></span><br><span class="line">			&#125;</span><br><span class="line">			max=Math.max(max, j+<span class="number">1</span>-i);<span class="comment">//j+1代表当前字符在字符串中的位置，i代表上一个重复字符在字符串中的位置。</span></span><br><span class="line">			map.put(sub.charAt(j), j+<span class="number">1</span>);<span class="comment">//将字符放入hash表中，如果已经有就覆盖它。</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-9</title>
    <url>/2020/05/13/LeetCode-9/LeetCode-9/</url>
    <content><![CDATA[<h1 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">输入: 121</span><br><span class="line"></span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>
<h2 id="思路1-反转一半数字"><a href="#思路1-反转一半数字" class="headerlink" title="思路1-反转一半数字"></a>思路1-反转一半数字</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">由于数字对称的特点，那么一半的反转，等于另外一半。</span><br></pre></td></tr></table></figure>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> revert = <span class="number">0</span>;		</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span> || (x%<span class="number">10</span> ==<span class="number">0</span> &amp;&amp; x!=<span class="number">0</span>))&#123;<span class="comment">//此处是如果为10的倍数或者负数，但不是0，则不是对称的。</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;<span class="comment">//由于对称数的特性，左边-中间与右边-中间的数值应该一样</span></span><br><span class="line">	<span class="keyword">while</span>(revert&lt;x)&#123;<span class="comment">//反转的数等于时表名有偶数个数位，&gt;时表示奇数个数位</span></span><br><span class="line">		revert =revert*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">		x=x/<span class="number">10</span>;</span><br><span class="line">	&#125;		    </span><br><span class="line">	<span class="keyword">if</span>(revert==x || revert/<span class="number">10</span> ==x)&#123;<span class="comment">//防止有奇数个数位，那么就应该取整再比较</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度：O-n-2"><a href="#时间复杂度：O-n-2" class="headerlink" title="时间复杂度：O(n^2)"></a>时间复杂度：O(n^2)</h3><h2 id="思路2-字符串法"><a href="#思路2-字符串法" class="headerlink" title="思路2-字符串法"></a>思路2-字符串法</h2><p><code>将数字转化为字符串，调用反转函数，返回两者比对值。</code></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-8</title>
    <url>/2020/05/13/LeetCode-8/LeetCode-8/</url>
    <content><![CDATA[<h1 id="字符串转整数"><a href="#字符串转整数" class="headerlink" title="字符串转整数"></a>字符串转整数</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><blockquote>
<p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p>
</blockquote>
<blockquote>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p>
</blockquote>
<blockquote>
<p>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。<br>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。<br>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法&gt;进行有效转换。</p>
</blockquote>
<blockquote>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p>
</blockquote>
<blockquote>
<p>提示：<br>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX<br>(231 − 1) 或 INT_MIN (−231) 。</p>
</blockquote>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释:第一个非空白字符为 &#39;-&#39;, 它是一个负号。</span><br><span class="line">	我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br></pre></td></tr></table></figure>

<h2 id="思路1-逻辑覆盖"><a href="#思路1-逻辑覆盖" class="headerlink" title="思路1-逻辑覆盖"></a>思路1-逻辑覆盖</h2><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">           str=str.trim();</span><br><span class="line">           <span class="keyword">if</span>(str.length()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">char</span> ch;</span><br><span class="line">           <span class="keyword">int</span> flag=<span class="number">1</span>,result=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">               ch=str.charAt(i);</span><br><span class="line">               <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                  <span class="keyword">if</span>(ch==<span class="string">'+'</span>)flag=<span class="number">1</span>;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">'-'</span>)flag=-<span class="number">1</span>;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span>(ch&gt;=<span class="string">'0'</span>&amp;ch&lt;=<span class="string">'9'</span>)result=ch-<span class="string">'0'</span>;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">if</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                       <span class="keyword">if</span>(result&gt;<span class="number">214748364</span>)&#123;</span><br><span class="line">                           <span class="keyword">return</span> flag==<span class="number">1</span>?<span class="number">2147483647</span>:-<span class="number">2147483648</span>;</span><br><span class="line">                       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(result==<span class="number">214748364</span>)&#123;</span><br><span class="line">                           <span class="keyword">if</span>(flag==<span class="number">1</span>&amp;&amp;ch&gt;<span class="string">'7'</span>)<span class="keyword">return</span> <span class="number">2147483647</span>;</span><br><span class="line">                           <span class="keyword">if</span>(flag==-<span class="number">1</span>&amp;&amp;ch&gt;<span class="string">'8'</span>)<span class="keyword">return</span> -<span class="number">2147483648</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                       result=result*<span class="number">10</span>+ch-<span class="string">'0'</span>;</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> flag*result;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O(n)"></a>时间复杂度：O(n)</h3><h2 id="思路2-自动机"><a href="#思路2-自动机" class="headerlink" title="思路2-自动机"></a>思路2-自动机</h2><p><code>暂时未理解</code><br><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/solution/zi-fu-chuan-zhuan-huan-zheng-shu-atoi-by-leetcode-/" title="自动机">https://leetcode-cn.com/problems/string-to-integer-atoi/solution/zi-fu-chuan-zhuan-huan-zheng-shu-atoi-by-leetcode-/</a></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-10</title>
    <url>/2020/05/15/LeetCode-10/LeetCode-10/</url>
    <content><![CDATA[<h1 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 &#39;.&#39; 和 &#39;*&#39; 的正则表达式匹配。</span><br><span class="line"></span><br><span class="line">&#39;.&#39; 匹配任意单个字符</span><br><span class="line">&#39;*&#39; 匹配零个或多个前面的那一个元素</span><br><span class="line">所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">s 可能为空，且只包含从 a-z 的小写字母。</span><br><span class="line">p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。</span><br></pre></td></tr></table></figure>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;ab&quot;</span><br><span class="line">p &#x3D; &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aab&quot;</span><br><span class="line">p &#x3D; &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;mississippi&quot;</span><br><span class="line">p &#x3D; &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<h2 id="思路1-回溯"><a href="#思路1-回溯" class="headerlink" title="思路1-回溯"></a>思路1-回溯</h2><p>递归调用原函数，以模式串为依据，首先判断第一个字符是否匹配，然后根据后一个字符的情况：如果后一个字符是正常的字母，就继续对模式串与匹配取子串进行匹配，如果后一个字符是’*’，那么就有两种情况：前一个字符匹配0次，匹配n次，这时产生连个分支（见下面代码）。此种算法的时空复杂度比较高，主要高在创建字符串，需要消耗大量的实践与空间。</p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(pattern.isEmpty())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> text.isEmpty();			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">boolean</span> firstMatch=(text.length()&gt;=<span class="number">1</span>&amp;&amp;pattern.charAt(<span class="number">0</span>)==text.charAt(<span class="number">0</span>)||pattern.charAt(<span class="number">0</span>)==<span class="string">'.'</span>);</span><br><span class="line">			<span class="keyword">if</span>(pattern.length()&gt;=<span class="number">2</span>&amp;&amp;pattern.charAt(<span class="number">1</span>)==<span class="string">'*'</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> isMatch(text,pattern.substring(<span class="number">2</span>))||(firstMatch&amp;&amp;isMatch(text.substring(<span class="number">1</span>),pattern));<span class="comment">//两个分支</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> isMatch(text.substring(<span class="number">1</span>), pattern.substring(<span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路2-动态规划"><a href="#思路2-动态规划" class="headerlink" title="思路2-动态规划"></a>思路2-动态规划</h2><p><a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/dong-tai-gui-hua-zen-yao-cong-0kai-shi-si-kao-da-b/" title="字符串匹配-动态规划">https://leetcode-cn.com/problems/regular-expression-matching/solution/dong-tai-gui-hua-zen-yao-cong-0kai-shi-si-kao-da-b/</a></p>
<h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> flag;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span>[][] cache;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">       cache = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][p.length()];</span><br><span class="line">       backtracking(<span class="number">0</span>, <span class="number">0</span>, s, p);</span><br><span class="line">       <span class="keyword">return</span> flag;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> sId, <span class="keyword">int</span> pId, String s, String p)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (sId &gt;= s.length()) &#123;</span><br><span class="line">           <span class="keyword">while</span> (pId + <span class="number">1</span> &lt; p.length() &amp;&amp; p.charAt(pId + <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">               pId += <span class="number">2</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (pId &gt;= p.length()) &#123;</span><br><span class="line">               flag = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (pId &gt;= p.length()) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (cache[sId][pId]) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       cache[sId][pId] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">char</span> pc = p.charAt(pId);</span><br><span class="line">       <span class="keyword">char</span> sc = s.charAt(sId);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (pId + <span class="number">1</span> &lt; p.length() &amp;&amp; p.charAt(pId + <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (pc == <span class="string">'.'</span> || pc == sc) &#123;</span><br><span class="line">               backtracking(sId + <span class="number">1</span>, pId, s, p);</span><br><span class="line">           &#125;</span><br><span class="line">           backtracking(sId, pId + <span class="number">2</span>, s, p);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pc == sc || pc == <span class="string">'.'</span>) &#123;</span><br><span class="line">           backtracking(sId + <span class="number">1</span>, pId + <span class="number">1</span>, s, p);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度：O-nm"><a href="#时间复杂度：O-nm" class="headerlink" title="时间复杂度：O(nm)"></a>时间复杂度：O(nm)</h3>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>回溯算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-7</title>
    <url>/2020/05/13/LeetCode-7/LeetCode-7/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h1 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h1><a id="more"></a>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	输入: 120</span><br><span class="line">	输出: 21</span><br><span class="line">注意：</span><br><span class="line">	假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</span><br></pre></td></tr></table></figure>
<h2 id="思路1-逆序取值"><a href="#思路1-逆序取值" class="headerlink" title="思路1-逆序取值"></a>思路1-逆序取值</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不断取出原整数的最后一个数位</span><br></pre></td></tr></table></figure>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> flag=x&gt;<span class="number">0</span>?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">           x=Math.abs(x);</span><br><span class="line">           <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           	<span class="keyword">if</span>(result&gt;<span class="number">214748364</span>)&#123;</span><br><span class="line">               	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(result==<span class="number">214748364</span>)&#123;</span><br><span class="line">               	<span class="keyword">if</span>((x&gt;<span class="number">7</span>&amp;&amp;flag==<span class="number">1</span>)||(flag==-<span class="number">1</span>&amp;&amp;x&gt;<span class="number">8</span>))&#123;</span><br><span class="line">               		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">               	&#125;</span><br><span class="line">               &#125;</span><br><span class="line">               result=result*<span class="number">10</span>+(x%<span class="number">10</span>);</span><br><span class="line">               x/=<span class="number">10</span>;                </span><br><span class="line">           &#125;</span><br><span class="line">       <span class="keyword">return</span> flag*result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O(n)"></a>时间复杂度：O(n)</h3>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数学公式</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-11</title>
    <url>/2020/05/15/LeetCode-11/LeetCode-11/</url>
    <content><![CDATA[<h1 id="盛水最多的容器"><a href="#盛水最多的容器" class="headerlink" title="盛水最多的容器"></a>盛水最多的容器</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器，且 n 的值至少为 2。<br><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt></p>
<p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49</span><br></pre></td></tr></table></figure>
<h2 id="思路1-双指针"><a href="#思路1-双指针" class="headerlink" title="思路1-双指针"></a>思路1-双指针</h2><p>定义两个指针，分别指向数组的两端，然后不断移动指针，由于容器的容积取决于短的那一端，所以一旦一个容积定下来，那么就是两端指针指向的端的那一段所能构成的容器体积的最大值，所以可以移动短的那一端的指针。（而且如果下一个指向的位置比前一个还要短，那么它的容积是不可能超过前一个容器的容积的，所以可以直接跳过该指针指向的那一端）</p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxContainer=<span class="number">0</span>,tempCaontainer=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            tempCaontainer=Math.min(height[i],height[j])*(j-i);</span><br><span class="line">            <span class="keyword">if</span>(tempCaontainer&gt;maxContainer)&#123;</span><br><span class="line">                maxContainer=tempCaontainer;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> cL=height[i],rL=height[j];</span><br><span class="line">            <span class="keyword">if</span>(height[i]&lt;=height[j])&#123;</span><br><span class="line">                <span class="keyword">while</span>(i&lt;j&amp;&amp;cL&gt;=height[i])i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(j&gt;i&amp;&amp;rL&gt;=height[j])j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxContainer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O(n)"></a>时间复杂度：O(n)</h3>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-12</title>
    <url>/2020/05/15/LeetCode-12/LeetCode-12/</url>
    <content><![CDATA[<h1 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a>整数转罗马数字</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</span><br><span class="line"></span><br><span class="line">&gt;字符          数值</span><br><span class="line">&gt;I             1</span><br><span class="line">&gt;V             5</span><br><span class="line">&gt;X             10</span><br><span class="line">&gt;L             50</span><br><span class="line">&gt;C             100</span><br><span class="line">&gt;D             500</span><br><span class="line">&gt;M             1000</span><br><span class="line">例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</span><br><span class="line"></span><br><span class="line">通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</span><br><span class="line"></span><br><span class="line">I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</span><br><span class="line">X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </span><br><span class="line">C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</span><br><span class="line">给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: &quot;III&quot;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: &quot;IV&quot;</span><br></pre></td></tr></table></figure>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 9</span><br><span class="line">输出: &quot;IX&quot;</span><br></pre></td></tr></table></figure>
<h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a>示例 4</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 58</span><br><span class="line">输出: &quot;LVIII&quot;</span><br><span class="line">解释: L &#x3D; 50, V &#x3D; 5, III &#x3D; 3.</span><br></pre></td></tr></table></figure>
<h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5"></a>示例 5</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1994</span><br><span class="line">输出: &quot;MCMXCIV&quot;</span><br><span class="line">解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.</span><br></pre></td></tr></table></figure>
<h2 id="思路1-算法名字"><a href="#思路1-算法名字" class="headerlink" title="思路1-算法名字"></a>思路1-算法名字</h2><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 把阿拉伯数字与罗马数字可能出现的所有情况和对应关系，放在两个数组中</span></span><br><span class="line">        <span class="comment">// 并且按照阿拉伯数字的大小降序排列，这是贪心选择思想</span></span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        String[] romans = &#123;<span class="string">"M"</span>, <span class="string">"CM"</span>, <span class="string">"D"</span>, <span class="string">"CD"</span>, <span class="string">"C"</span>, <span class="string">"XC"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>, <span class="string">"X"</span>, <span class="string">"IX"</span>, <span class="string">"V"</span>, <span class="string">"IV"</span>, <span class="string">"I"</span>&#125;;</span><br><span class="line"></span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; <span class="number">13</span>) &#123;</span><br><span class="line">            <span class="comment">// 特别注意：这里是等号</span></span><br><span class="line">            <span class="keyword">while</span> (num &gt;= nums[index]) &#123;</span><br><span class="line">                <span class="comment">// 注意：这里是等于号，表示尽量使用大的"面值"</span></span><br><span class="line">                stringBuilder.append(romans[index]);</span><br><span class="line">                num -= nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度：O-1"><a href="#时间复杂度：O-1" class="headerlink" title="时间复杂度：O(1)"></a>时间复杂度：O(1)</h3>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-14</title>
    <url>/2020/05/16/LeetCode-14/LeetCode-14/</url>
    <content><![CDATA[<h1 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 “”。<br>说明:</p>
<p>所有输入只包含小写字母 a-z 。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure>
<h2 id="思路1-水平扫描法"><a href="#思路1-水平扫描法" class="headerlink" title="思路1-水平扫描法"></a>思路1-水平扫描法</h2><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length==<span class="number">0</span>)&#123;<span class="comment">//如果字符串数组为0，直接返回""</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(strs.length==<span class="number">1</span>)&#123;<span class="comment">//如果字符串数组只有一个字符串，那么只返回一个字符串</span></span><br><span class="line">            <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        String commonPrefix=strs[<span class="number">0</span>];<span class="comment">//将第一个字符串设置为默认最长公共前缀，然后对其进行修改</span></span><br><span class="line">        <span class="keyword">int</span> maxCommonPrefixLength=strs[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=maxCommonPrefixLength;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[i].indexOf(strs[<span class="number">0</span>].substring(<span class="number">0</span>,j))==<span class="number">0</span>)&#123;</span><br><span class="line">                    commonPrefix=strs[<span class="number">0</span>].substring(<span class="number">0</span>,j);</span><br><span class="line">                    maxCommonPrefixLength=j;</span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//此处加一个break，表示当取到两个字符串得公共部分时立即跳出，进行与下一个字符串得比对，而不是继续缩减公共部分得长度</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    commonPrefix=<span class="string">""</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> commonPrefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度：O-s-s为字符数组总的字符数"><a href="#时间复杂度：O-s-s为字符数组总的字符数" class="headerlink" title="时间复杂度：O(s),s为字符数组总的字符数"></a>时间复杂度：O(s),s为字符数组总的字符数</h3><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/solution/zui-chang-gong-gong-qian-zhui-by-leetcode/" title="更多解法">https://leetcode-cn.com/problems/longest-common-prefix/solution/zui-chang-gong-gong-qian-zhui-by-leetcode/</a></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-15</title>
    <url>/2020/05/16/LeetCode-15/LeetCode-15/</url>
    <content><![CDATA[<h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="思路1-双指针"><a href="#思路1-双指针" class="headerlink" title="思路1-双指针"></a>思路1-双指针</h2><p>首先选定一个数字，打他的右边当作一个数组，进行目标数值的查找，使用双指针，从两头进行“夹”，可以根据三数之和进行冗余循环的过滤。</p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists= <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Arrays.sort(nums);<span class="comment">//对其进行排序</span></span><br><span class="line">        <span class="keyword">int</span> left,right,sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i-<span class="number">1</span>]==nums[i])<span class="keyword">continue</span>;</span><br><span class="line">            left=i+<span class="number">1</span>;</span><br><span class="line">            right=nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                    sum=nums[i]+nums[left]+nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;</span><br><span class="line">                        lists.add(Arrays.asList(nums[i],nums[left],nums[right]));</span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]==nums[left+<span class="number">1</span>])left++;<span class="comment">//结束后跳到最接近右边得哪一个重复的数字位置处</span></span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]==nums[right-<span class="number">1</span>])right--;<span class="comment">//结束后跳到最接近左边得哪一个重复的数字位置处</span></span><br><span class="line">                        left++;<span class="comment">//跳到下一个位置</span></span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)&#123;<span class="comment">//说明右边太大了，要调整小一点。</span></span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;<span class="comment">//说明左边太小了，左边要调整</span></span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度：O-n-2"><a href="#时间复杂度：O-n-2" class="headerlink" title="时间复杂度：O(n^2)"></a>时间复杂度：O(n^2)</h3>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-13</title>
    <url>/2020/05/16/LeetCode-13/LeetCode-13/</url>
    <content><![CDATA[<h1 id="罗马数字转整数"><a href="#罗马数字转整数" class="headerlink" title="罗马数字转整数"></a>罗马数字转整数</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L &#x3D; 50, V&#x3D; 5, III &#x3D; 3.</span><br></pre></td></tr></table></figure>
<h2 id="思路1-算法名字"><a href="#思路1-算法名字" class="headerlink" title="思路1-算法名字"></a>思路1-算法名字</h2><p>根据字符串中的字符，将对应的数字加到结果中，如果返现大小位置相反的字符，就使结果减去这个字符对应的数值。这样避免了使用取子串方式来处理的时间消耗。</p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> preNum=getValue(s.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> currNum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            currNum=getValue(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span>(preNum&lt;currNum)&#123;</span><br><span class="line">                result=result-preNum;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result=result+preNum;</span><br><span class="line">            &#125;</span><br><span class="line">            preNum=currNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result+preNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'I'</span>:result=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'V'</span>:result=<span class="number">5</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'X'</span>:result=<span class="number">10</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'L'</span>:result=<span class="number">50</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'C'</span>:result=<span class="number">100</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'D'</span>:result=<span class="number">500</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'M'</span>:result=<span class="number">1000</span>;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O(n)"></a>时间复杂度：O(n)</h3>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-17</title>
    <url>/2020/05/17/LeetCode-17/LeetCode-17/</url>
    <content><![CDATA[<h1 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png" alt><br>说明:<br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure>
<h2 id="思路1-回溯法"><a href="#思路1-回溯法" class="headerlink" title="思路1-回溯法"></a>思路1-回溯法</h2><p>操作公共列表，保存结果。太聪明了这种算法，代码理解更好。</p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> String map[]=&#123;<span class="string">""</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line">List&lt;String&gt;result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] digitsArray=digits.toCharArray();<span class="comment">//将"12"转化为【'1'、'2'】</span></span><br><span class="line">        len=digitsArray.length;<span class="comment">//此处保存长度，用于递归的结束条件</span></span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)<span class="keyword">return</span> result;<span class="comment">//如果为空串直接返回空列表</span></span><br><span class="line">        <span class="keyword">char</span>[]temp=<span class="keyword">new</span> <span class="keyword">char</span>[len];<span class="comment">//定义一个字符数组用于存储如['a','d']、或者['a','e']，这样的中间结果</span></span><br><span class="line">        letterCombinations(digitsArray,<span class="number">0</span>,temp);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">letterCombinations</span><span class="params">(<span class="keyword">char</span>[] digitsArray,<span class="keyword">int</span> index,<span class="keyword">char</span>[] temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==len)&#123;<span class="comment">//结束条件，如果达到len表明到达digits的末尾之后，此时temp的每一位都有了字符</span></span><br><span class="line">            result.add(String.valueOf(temp));<span class="comment">//将temp数组直接转化为字符串，并存入字符串列表，每一个temp代表一个结果字符串</span></span><br><span class="line">               <span class="keyword">return</span> ;<span class="comment">//返回避免递归无法终止</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> chs[]=map[digitsArray[index]-<span class="string">'0'</span>].toCharArray();<span class="comment">//获得当前索引映射到的字母数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:chs)&#123;<span class="comment">//将此索引的每一个字母先存入到temp中，然后进行下一位temp索引位置处字母的搭配</span></span><br><span class="line">            temp[index]=ch;</span><br><span class="line">            letterCombinations(digitsArray,index+<span class="number">1</span>,temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度：O-3-N-×4-M"><a href="#时间复杂度：O-3-N-×4-M" class="headerlink" title="时间复杂度：O(3^N ×4^M )"></a>时间复杂度：O(3^N ×4^M )</h3>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-18</title>
    <url>/2020/05/17/LeetCode-18/LeetCode-18/</url>
    <content><![CDATA[<h1 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<p>注意：</p>
<p>答案中不可以包含重复的四元组。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><blockquote>
<p>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。</p>
</blockquote>
<blockquote>
<p>满足要求的四元组集合为：</p>
<p>[</p>
<p> [-1,  0, 0, 1],</p>
<p> [-2, -1, 1, 2],</p>
<p> [-2,  0, 0, 2]</p>
<p>]</p>
</blockquote>
<h2 id="思路1-双指针法"><a href="#思路1-双指针法" class="headerlink" title="思路1-双指针法"></a>思路1-双指针法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先选定两个位置作为出发点，然后在这两个位置后面再选定位置作为指针初始位置，进行求和判断，根据求和结果进行指针的移动。此处已经完成了整个算法，但是还需要进行优化，不然可能重复的操作太多。剔除：如果已经确定一个起始位置，那么它的最小值大于target，那么就没有必要继续向后读取数字了，如果最大值小于target，也没必要进行此次循环...</span><br></pre></td></tr></table></figure>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">	            List&lt;List&lt;Integer&gt;&gt; result= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	            <span class="keyword">if</span>(nums.length&lt;<span class="number">4</span>)&#123;</span><br><span class="line">	                <span class="keyword">return</span> result;</span><br><span class="line">	            &#125;</span><br><span class="line">	            Arrays.sort(nums);</span><br><span class="line">	            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">3</span>;i++)&#123;</span><br><span class="line">	                <span class="keyword">if</span>(nums[i]+nums[i+<span class="number">1</span>]+nums[i+<span class="number">2</span>]+nums[i+<span class="number">3</span>]&gt;target)&#123;<span class="comment">//最小的四个数和小于target，结束所有循环</span></span><br><span class="line">	                    <span class="keyword">break</span>;</span><br><span class="line">	                &#125;</span><br><span class="line">	         <span class="keyword">if</span>(nums[i] +nums[nums.length-<span class="number">3</span>]+nums[nums.length-<span class="number">2</span>]+nums[nums.length-<span class="number">1</span>]&lt;target)&#123;<span class="comment">//起始位处所能你达到最大的四个数之和大于target</span></span><br><span class="line">	                    <span class="keyword">continue</span>;</span><br><span class="line">	                &#125;</span><br><span class="line">	               <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])<span class="keyword">continue</span>;<span class="comment">//如果此处为true表示表示此处数字已经被考虑过了</span></span><br><span class="line">	                <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length-<span class="number">2</span>;j++)&#123;</span><br><span class="line">                         <span class="keyword">if</span>(nums[i] +nums[j]+nums[j+<span class="number">1</span>]+nums[j+<span class="number">2</span>]&gt;target)&#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                         &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(nums[i] +nums[j]+nums[nums.length-<span class="number">2</span>]+nums[nums.length-<span class="number">1</span>]&lt;target)&#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">	                  <span class="keyword">if</span>(j&gt;i+<span class="number">1</span>&amp;&amp;nums[j]==nums[j-<span class="number">1</span>])<span class="keyword">continue</span>;<span class="comment">//如果此处为true表示此处数字已经被考虑过了</span></span><br><span class="line">	                    <span class="keyword">int</span> left=j+<span class="number">1</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">	                    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">	                        <span class="keyword">int</span> tempSum=nums[i]+nums[j]+nums[left]+nums[right];</span><br><span class="line">	                        <span class="keyword">if</span>(tempSum==target)&#123;</span><br><span class="line">	                            result.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));</span><br><span class="line">	                            <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]==nums[left+<span class="number">1</span>])left++;</span><br><span class="line">	                            <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]==nums[right-<span class="number">1</span>])right--;</span><br><span class="line">	                            left++;</span><br><span class="line">	                            right--;</span><br><span class="line">	                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tempSum&gt;target)&#123;</span><br><span class="line">	                            right--;</span><br><span class="line">	                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	                            left++;</span><br><span class="line">	                        &#125;</span><br><span class="line">	                    &#125;</span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125;</span><br><span class="line">	            <span class="keyword">return</span> result;</span><br><span class="line">	        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度：O-NlogN"><a href="#时间复杂度：O-NlogN" class="headerlink" title="时间复杂度：O(NlogN)"></a>时间复杂度：O(NlogN)</h3>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-16</title>
    <url>/2020/05/17/LeetCode-16/LeetCode-16/</url>
    <content><![CDATA[<h1 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a>最接近的三数之和</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><blockquote>
<p>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.</p>
<p>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p>
</blockquote>
<h2 id="思路1-双指针法"><a href="#思路1-双指针法" class="headerlink" title="思路1-双指针法"></a>思路1-双指针法</h2><p>选定一个位置，从此位置出发，定义两个指针指向此位置之后的数组两端，然后不断的缩进，不断的判断距离。</p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> currSum=<span class="number">0</span>,left=<span class="number">0</span>,right=<span class="number">0</span>,minLength=<span class="number">2147483624</span>,resultSum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=nums.length-<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;nums[i-<span class="number">1</span>]==nums[i])<span class="keyword">continue</span>;</span><br><span class="line">            left=i+<span class="number">1</span>;</span><br><span class="line">            right=nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                currSum=nums[i]+nums[left]+nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(currSum&gt;target)&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                        <span class="keyword">if</span>(currSum-target&lt;minLength)&#123;</span><br><span class="line">                            minLength=currSum-target;</span><br><span class="line">                            resultSum=currSum;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(currSum&lt;target)&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                        <span class="keyword">if</span>(target-currSum&lt;minLength)&#123;</span><br><span class="line">                            minLength=target-currSum;</span><br><span class="line">                            resultSum=currSum;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> currSum;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> resultSum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度：O-nlogn-O-n-2-O-n-2"><a href="#时间复杂度：O-nlogn-O-n-2-O-n-2" class="headerlink" title="时间复杂度：O(nlogn)+O(n^2 )=O(n^2 )"></a>时间复杂度：O(nlogn)+O(n^2 )=O(n^2 )</h3>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-20</title>
    <url>/2020/05/18/LeetCode-20/LeetCode-20/</url>
    <content><![CDATA[<h1 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a>示例 4</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<h2 id="思路1-栈"><a href="#思路1-栈" class="headerlink" title="思路1-栈"></a>思路1-栈</h2><p>使用栈，遇到左边的就读入，遇到右边的就取出判断是否匹配（注意此处取出时要判断是否已经空栈，如果已经空栈了，直接返回false）.最终还要返回栈是否为空。</p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean isValid(String s) &#123;</span><br><span class="line">		Stack&lt;Character&gt; chs&#x3D; new Stack&lt;&gt;();</span><br><span class="line">		boolean flag&#x3D;true;</span><br><span class="line">		for(char ch:s.toCharArray())&#123;</span><br><span class="line">			switch(ch)&#123;</span><br><span class="line">			case &#39;(&#39;:case &#39;[&#39;:case &#39;&#123;&#39;:chs.push(ch);flag&#x3D;false;break;</span><br><span class="line">			case &#39;)&#39;:if(chs.isEmpty()||chs.pop()!&#x3D;&#39;(&#39;)flag&#x3D;true;break;</span><br><span class="line">			case &#39;]&#39;:if(chs.isEmpty()||chs.pop()!&#x3D;&#39;[&#39;)flag&#x3D;true;break;</span><br><span class="line">			case &#39;&#125;&#39;:if(chs.isEmpty()||chs.pop()!&#x3D;&#39;&#123;&#39;)flag&#x3D;true;break;			</span><br><span class="line">			&#125;</span><br><span class="line">			if(flag)&#123;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return chs.isEmpty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O(n)"></a>时间复杂度：O(n)</h3>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-19</title>
    <url>/2020/05/18/LeetCode-19/LeetCode-19/</url>
    <content><![CDATA[<h1 id="删除链表的倒数第N个结点"><a href="#删除链表的倒数第N个结点" class="headerlink" title="删除链表的倒数第N个结点"></a>删除链表的倒数第N个结点</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<p>说明：</p>
<p>给定的 n 保证是有效的。</p>
<p>进阶：</p>
<p>你能尝试使用一趟扫描实现吗？</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure>
<h2 id="思路1-双指针法（一次遍历）"><a href="#思路1-双指针法（一次遍历）" class="headerlink" title="思路1-双指针法（一次遍历）"></a>思路1-双指针法（一次遍历）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用两个指针，从一个起点不同时（绝大部分情况下）出发，当间隔为n时第二个结点出发，</span><br><span class="line">然后同步移动两个结点，始终保持两个结点的间隔为n,当第一个结点指到null，第二个结</span><br><span class="line">点就是倒数第n+1个结点位置处。</span><br></pre></td></tr></table></figure>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//定义一个哑结点，作为起点。</span></span><br><span class="line">    dummy.next = head;</span><br><span class="line">    ListNode first = dummy;</span><br><span class="line">    ListNode second = dummy;</span><br><span class="line">    <span class="comment">// 移动第一个结点到间隔为n的位置处</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同步移动两个指针，保持间隔始终为n</span></span><br><span class="line">    <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = first.next;</span><br><span class="line">        second = second.next;</span><br><span class="line">    &#125;</span><br><span class="line">    second.next = second.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度：O-L"><a href="#时间复杂度：O-L" class="headerlink" title="时间复杂度：O(L)"></a>时间复杂度：O(L)</h3><h2 id="思路2-两次遍历算法"><a href="#思路2-两次遍历算法" class="headerlink" title="思路2-两次遍历算法"></a>思路2-两次遍历算法</h2><h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">int</span> length  = <span class="number">0</span>;</span><br><span class="line">    ListNode first = head;</span><br><span class="line">    <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    length -= n;</span><br><span class="line">    first = dummy;</span><br><span class="line">    <span class="keyword">while</span> (length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        length--;</span><br><span class="line">        first = first.next;</span><br><span class="line">    &#125;</span><br><span class="line">    first.next = first.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度：O-2-L-n-即为O-L"><a href="#时间复杂度：O-2-L-n-即为O-L" class="headerlink" title="时间复杂度：O(2*L-n)即为O(L)"></a>时间复杂度：O(2*L-n)即为O(L)</h3><p>####总结：<br>    做算法时不要太纠结，也许你所想的算法就是一个死胡同，那就不能钻牛角尖，不然只会浪费时间。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-21</title>
    <url>/2020/05/18/LeetCode-21/LeetCode-21/</url>
    <content><![CDATA[<h1 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>
<h2 id="思路1-递归"><a href="#思路1-递归" class="headerlink" title="思路1-递归"></a>思路1-递归</h2><p>首先取出两链表中小的那一个，然后修改其next，使其等于它的next与另一个链表合并的结果</p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>)<span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="keyword">null</span>)<span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;l2.val)</span><br><span class="line">        &#123;</span><br><span class="line">            l1.next=mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l2.next=mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度：O-n-m"><a href="#时间复杂度：O-n-m" class="headerlink" title="时间复杂度：O(n+m)"></a>时间复杂度：O(n+m)</h3><h2 id="思路2-迭代"><a href="#思路2-迭代" class="headerlink" title="思路2-迭代"></a>思路2-迭代</h2><p>在一个循环里面，不断取出小的节点，然后加到新建节点后面</p>
<h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">       ListNode prehead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">       ListNode prev = prehead;</span><br><span class="line">       <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">               prev.next = l1;</span><br><span class="line">               l1 = l1.next;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               prev.next = l2;</span><br><span class="line">               l2 = l2.next;</span><br><span class="line">           &#125;</span><br><span class="line">           prev = prev.next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">       prev.next = l1 == <span class="keyword">null</span> ? l2 : l1;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> prehead.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度：O-n-m-1"><a href="#时间复杂度：O-n-m-1" class="headerlink" title="时间复杂度：O(n+m)"></a>时间复杂度：O(n+m)</h3>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-23</title>
    <url>/2020/05/19/LeetCode-23/LeetCode-23/</url>
    <content><![CDATA[<h1 id="合并k个排序链表"><a href="#合并k个排序链表" class="headerlink" title="合并k个排序链表"></a>合并k个排序链表</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>
<h2 id="思路1-分治合并"><a href="#思路1-分治合并" class="headerlink" title="思路1-分治合并"></a>思路1-分治合并</h2><p>将数组分为两个部分，然后不断分割，直到分割成一个一个单独的链表，然后相邻两个进行合并，（总共进行了k/2+k/4+..+k/2^…i.次合并），每次合并使用2^i*n</p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode <span class="title">merge</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> lists[l];</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(merge(lists, l, mid), merge(lists, mid + <span class="number">1</span>, r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>)<span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="keyword">null</span>)<span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;l2.val)</span><br><span class="line">        &#123;</span><br><span class="line">            l1.next=mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l2.next=mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度：O-kn×logk"><a href="#时间复杂度：O-kn×logk" class="headerlink" title="时间复杂度：O(kn×logk)"></a>时间复杂度：O(kn×logk)</h3>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>堆</tag>
        <tag>分治算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-22</title>
    <url>/2020/05/19/LeetCode-22/LeetCode-22/</url>
    <content><![CDATA[<h1 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：[</span><br><span class="line">       &quot;((()))&quot;,</span><br><span class="line">       &quot;(()())&quot;,</span><br><span class="line">       &quot;(())()&quot;,</span><br><span class="line">       &quot;()(())&quot;,</span><br><span class="line">       &quot;()()()&quot;</span><br><span class="line">     ]</span><br></pre></td></tr></table></figure>
<h2 id="思路1-回溯法"><a href="#思路1-回溯法" class="headerlink" title="思路1-回溯法"></a>思路1-回溯法</h2><p>可以看成初始只有一个左括号，然后有两种情况（添加一个左括号，添加一个右括号），就这样不断添加下去直到所有的括号书娘达到2*n时，就达到最大值（注意组成的括号字符串中，如果右括号的数目大于左括号的数目就可以不继续此种情况的回溯了）</p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; result= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">char</span> [] temp = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span>*n];</span><br><span class="line">		generateParenthesis(<span class="number">0</span>,<span class="number">0</span>,n,<span class="number">0</span>,temp);</span><br><span class="line">	    <span class="keyword">return</span> result;</span><br><span class="line">	    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> total,<span class="keyword">int</span> currentPos,<span class="keyword">char</span> [] temp)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(left&gt;=right&amp;&amp;left&lt;=total)&#123;<span class="comment">//此处证明目前字符串使合格的</span></span><br><span class="line">				<span class="keyword">if</span>(currentPos&lt;<span class="number">2</span>*total)&#123;</span><br><span class="line">					temp[currentPos]=<span class="string">'('</span>;</span><br><span class="line">					generateParenthesis(left+<span class="number">1</span>,right,total,currentPos+<span class="number">1</span>,temp);<span class="comment">//此处加一个左括号</span></span><br><span class="line">					temp[currentPos]=<span class="string">')'</span>;</span><br><span class="line">					generateParenthesis(left,right+<span class="number">1</span>,total,currentPos+<span class="number">1</span>,temp);<span class="comment">//此处加一个右括号</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(left==total&amp;&amp;right==total)&#123;<span class="comment">//此处为最终的结果了</span></span><br><span class="line">					result.add(<span class="keyword">new</span> String(temp));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-24</title>
    <url>/2020/05/19/LeetCode-24/LeetCode-24/</url>
    <content><![CDATA[<h1 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><blockquote>
<p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</p>
</blockquote>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><h2 id="思路1-递归"><a href="#思路1-递归" class="headerlink" title="思路1-递归"></a>思路1-递归</h2><p>两两交换可以看成，先对前两个节点，交换，再对后面的链表进行此操作，然后将前两个节点加到已经完成交换后的链表前面。</p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode cur=head;</span><br><span class="line">        ListNode next=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur!=<span class="keyword">null</span>)</span><br><span class="line">        	next=cur.next;</span><br><span class="line">        <span class="keyword">if</span>(cur!=<span class="keyword">null</span>&amp;&amp;next!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	cur.next=next.next;</span><br><span class="line">        	next.next=cur;</span><br><span class="line">        	head=next;</span><br><span class="line">        	cur.next=swapPairs(cur.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O(n)"></a>时间复杂度：O(n)</h3><h2 id="思路2-迭代"><a href="#思路2-迭代" class="headerlink" title="思路2-迭代"></a>思路2-迭代</h2><p>首先设置一个哑节点，然后在一个for循环里面不断的每次取两个节点进行交换，并修改哑节点的指向，这样每次修改三个节点，并执行循环。</p>
<h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dummy node acts as the prevNode for the head node</span></span><br><span class="line">        <span class="comment">// of the list and hence stores pointer to the head node.</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        ListNode prevNode = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((head != <span class="keyword">null</span>) &amp;&amp; (head.next != <span class="keyword">null</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Nodes to be swapped</span></span><br><span class="line">            ListNode firstNode = head;</span><br><span class="line">            ListNode secondNode = head.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Swapping</span></span><br><span class="line">            prevNode.next = secondNode;</span><br><span class="line">            firstNode.next = secondNode.next;</span><br><span class="line">            secondNode.next = firstNode;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reinitializing the head and prevNode for next swap</span></span><br><span class="line">            prevNode = firstNode;</span><br><span class="line">            head = firstNode.next; <span class="comment">// jump</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the new head node.</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度：O-n-1"><a href="#时间复杂度：O-n-1" class="headerlink" title="时间复杂度：O(n)"></a>时间复杂度：O(n)</h3>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-30</title>
    <url>/2020/05/21/LeetCode-30/LeetCode-30/</url>
    <content><![CDATA[<h1 id="串联所有的子串"><a href="#串联所有的子串" class="headerlink" title="串联所有的子串"></a>串联所有的子串</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</span><br><span class="line"></span><br><span class="line">注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">  s = <span class="string">"barfoothefoobarman"</span>,</span><br><span class="line">  words = [<span class="string">"foo"</span>,<span class="string">"bar"</span>]</span><br><span class="line">输出：[0,9]</span><br><span class="line">解释：</span><br><span class="line">从索引 0 和 9 开始的子串分别是 <span class="string">"barfoo"</span> 和 <span class="string">"foobar"</span> 。</span><br><span class="line">输出的顺序不重要, [9,0] 也是有效答案。</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">  s &#x3D; &quot;wordgoodgoodgoodbestword&quot;,</span><br><span class="line">  words &#x3D; [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<h2 id="思路1-算法名字"><a href="#思路1-算法名字" class="headerlink" title="思路1-算法名字"></a>思路1-算法名字</h2><p>太强了，见<a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-6/">https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-6/</a></p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> wordNum = words.length;</span><br><span class="line">    <span class="keyword">if</span> (wordNum == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> wordLen = words[<span class="number">0</span>].length();</span><br><span class="line">    HashMap&lt;String, Integer&gt; allWords = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String w : words) &#123;</span><br><span class="line">        <span class="keyword">int</span> value = allWords.getOrDefault(w, <span class="number">0</span>);</span><br><span class="line">        allWords.put(w, value + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将所有移动分成 wordLen 类情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; wordLen; j++) &#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; hasWords = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">//记录当前 HashMap2（这里的 hasWords 变量）中有多少个单词</span></span><br><span class="line">		<span class="comment">//每次移动一个单词长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = j; i &lt; s.length() - wordNum * wordLen + <span class="number">1</span>; i = i + wordLen) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> hasRemoved = <span class="keyword">false</span>; <span class="comment">//防止情况三移除后，情况一继续移除</span></span><br><span class="line">            <span class="keyword">while</span> (num &lt; wordNum) &#123;</span><br><span class="line">                String word = s.substring(i + num * wordLen, i + (num + <span class="number">1</span>) * wordLen);</span><br><span class="line">                <span class="keyword">if</span> (allWords.containsKey(word)) &#123;</span><br><span class="line">                    <span class="keyword">int</span> value = hasWords.getOrDefault(word, <span class="number">0</span>);</span><br><span class="line">                    hasWords.put(word, value + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">//出现情况三，遇到了符合的单词，但是次数超了</span></span><br><span class="line">                    <span class="keyword">if</span> (hasWords.get(word) &gt; allWords.get(word)) &#123;</span><br><span class="line">                        <span class="comment">// hasWords.put(word, value);</span></span><br><span class="line">                        hasRemoved = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">int</span> removeNum = <span class="number">0</span>;</span><br><span class="line">                        <span class="comment">//一直移除单词，直到次数符合了</span></span><br><span class="line">                        <span class="keyword">while</span> (hasWords.get(word) &gt; allWords.get(word)) &#123;</span><br><span class="line">                            String firstWord = s.substring(i + removeNum * wordLen, i + (removeNum + <span class="number">1</span>) * wordLen);</span><br><span class="line">                            <span class="keyword">int</span> v = hasWords.get(firstWord);</span><br><span class="line">                            hasWords.put(firstWord, v - <span class="number">1</span>);</span><br><span class="line">                            removeNum++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        num = num - removeNum + <span class="number">1</span>; <span class="comment">//加 1 是因为我们把当前单词加入到了 HashMap 2 中</span></span><br><span class="line">                        i = i + (removeNum - <span class="number">1</span>) * wordLen; <span class="comment">//这里依旧是考虑到了最外层的 for 循环，看情况二的解释</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="comment">//出现情况二，遇到了不匹配的单词，直接将 i 移动到该单词的后边（但其实这里</span></span><br><span class="line">                <span class="comment">//只是移动到了出现问题单词的地方，因为最外层有 for 循环， i 还会移动一个单词</span></span><br><span class="line">                <span class="comment">//然后刚好就移动到了单词后边）</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    hasWords.clear();</span><br><span class="line">                    i = i + num * wordLen;</span><br><span class="line">                    num = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num == wordNum) &#123;</span><br><span class="line">                res.add(i);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//出现情况一，子串完全匹配，我们将上一个子串的第一个单词从 HashMap2 中移除</span></span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">0</span> &amp;&amp; !hasRemoved) &#123;</span><br><span class="line">                String firstWord = s.substring(i, i + wordLen);</span><br><span class="line">                <span class="keyword">int</span> v = hasWords.get(firstWord);</span><br><span class="line">                hasWords.put(firstWord, v - <span class="number">1</span>);</span><br><span class="line">                num = num - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O(n)"></a>时间复杂度：O(n)</h3>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>双指针</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-28</title>
    <url>/2020/05/21/LeetCode-28/LeetCode-28/</url>
    <content><![CDATA[<h1 id="实现-strStr"><a href="#实现-strStr" class="headerlink" title="实现 strStr()"></a>实现 strStr()</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>实现 strStr() 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。<br>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>
<h2 id="思路1-伪双指针"><a href="#思路1-伪双指针" class="headerlink" title="思路1-伪双指针"></a>思路1-伪双指针</h2><p>任选一个起点，选择长度与needle一致的子串，进行匹配，不同继续到下一个位置，同返回索引。</p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = needle.length(), n = haystack.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; n - L + <span class="number">1</span>; ++start) &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack.substring(start, start + L).equals(needle)) &#123;</span><br><span class="line">                <span class="keyword">return</span> start;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度：O-n-2"><a href="#时间复杂度：O-n-2" class="headerlink" title="时间复杂度：O(n^2)"></a>时间复杂度：O(n^2)</h3><p>####感想<br>竟然有些人用Java的方法做，算了，不喷了。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-29</title>
    <url>/2020/05/21/LeetCode-29/LeetCode-29/</url>
    <content><![CDATA[<h1 id="总题目"><a href="#总题目" class="headerlink" title="总题目"></a>总题目</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p>
<p>返回被除数 dividend 除以除数 divisor 得到的商。</p>
<p>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2</p>
<blockquote>
<p>提示：</p>
</blockquote>
<blockquote>
<p>被除数和除数均为 32 位有符号整数。除数不为 0。假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。</p>
</blockquote>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: dividend &#x3D; 10, divisor &#x3D; 3</span><br><span class="line">输出: 3</span><br><span class="line">解释: 10&#x2F;3 &#x3D; truncate(3.33333..) &#x3D; truncate(3) &#x3D; 3</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: dividend &#x3D; 7, divisor &#x3D; -3</span><br><span class="line">输出: -2</span><br><span class="line">解释: 7&#x2F;-3 &#x3D; truncate(-2.33333..) &#x3D; -2</span><br></pre></td></tr></table></figure>
<h2 id="思路1-化为符数进行运算"><a href="#思路1-化为符数进行运算" class="headerlink" title="思路1-化为符数进行运算"></a>思路1-化为符数进行运算</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1)将被除数和除数都转成负数加减避免运算过程出现溢出。</span><br><span class="line">(2) 通过位运算将每轮的运算结果和除数翻倍来减少运算时间，类似二分法。</span><br><span class="line">(3) 不断循环直到被除数不够一个原除数除，判断是否整型溢出和符号返回结果。</span><br></pre></td></tr></table></figure>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 相同的符号异或运算结果为 0 ，不同符号异或运算结果为 1 。</span></span><br><span class="line">        <span class="keyword">boolean</span> symbol = (dividend &gt; <span class="number">0</span>) ^ (divisor &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将被除数和除数都转成负数做运算。</span></span><br><span class="line">        <span class="keyword">if</span> (dividend &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dividend = -dividend;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (divisor &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            divisor = -divisor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只要没有除尽就继续循环。</span></span><br><span class="line">        <span class="keyword">while</span> (dividend &lt;= divisor) &#123;</span><br><span class="line">            <span class="comment">// 初始化每轮的运算结果为 -1 。</span></span><br><span class="line">            <span class="keyword">int</span> curr = -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 记录每轮运算开始的除数。</span></span><br><span class="line">            <span class="keyword">int</span> temp = divisor;</span><br><span class="line">            <span class="comment">// 每轮直到被除数大于二倍的除数跳出循环。</span></span><br><span class="line">            <span class="keyword">while</span> (dividend &lt;= (temp &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 如果除数翻倍会溢出则跳出当前循环。</span></span><br><span class="line">                <span class="keyword">if</span> (temp &lt;= (Integer.MIN_VALUE &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将当前一轮运算结果翻倍。</span></span><br><span class="line">                curr &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 将当前一轮除数翻倍。</span></span><br><span class="line">                temp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每轮循环结束将被除数减去当前一轮最终除数，类似取模运算。</span></span><br><span class="line">            dividend = dividend - temp;</span><br><span class="line">            <span class="comment">// 叠加每轮的运算结果。</span></span><br><span class="line">            ans += curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果运算结果为正，判断是否溢出并转为正数结果。</span></span><br><span class="line">        <span class="keyword">if</span> (!symbol) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans &lt;= Integer.MIN_VALUE) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = -ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度：O-n-2"><a href="#时间复杂度：O-n-2" class="headerlink" title="时间复杂度：O(n^2)"></a>时间复杂度：O(n^2)</h3>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数学公式</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-25</title>
    <url>/2020/05/20/LeetCode-25/LeetCode-25/</url>
    <content><![CDATA[<h1 id="k个一组翻转链表"><a href="#k个一组翻转链表" class="headerlink" title="k个一组翻转链表"></a>k个一组翻转链表</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</span><br><span class="line"></span><br><span class="line">k 是一个正整数，它的值小于或等于链表的长度。</span><br><span class="line"></span><br><span class="line">如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</span><br><span class="line">说明：</span><br><span class="line">你的算法只能使用常数的额外空间。</span><br><span class="line">你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line"></span><br><span class="line">当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</span><br><span class="line"></span><br><span class="line">当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><h2 id="思路1-模拟法（递归版本）"><a href="#思路1-模拟法（递归版本）" class="headerlink" title="思路1-模拟法（递归版本）"></a>思路1-模拟法（递归版本）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">首先，将链表分为?个长度为k的链表（可能有一个链表的长度不是k），</span><br><span class="line">然后将第i个子链表翻转（注意此处要保留其第一个节点，用于指向下一个子链表），</span><br><span class="line">如此，不断递归，直到某个子链表的长度不是k，那么直接将此子链表接到上一个完</span><br><span class="line">成翻转的子链表的后面。最终就完成了全部链表的反转。注意：移动你链表时移动的步数为k-1是因为第一个节点就是长度为k的子链表的首节点，因此</span><br><span class="line">只要移动k-1个节点就到了第k个节点处。</span><br></pre></td></tr></table></figure>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k==<span class="number">1</span>||head==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">return</span> helper(head,k-<span class="number">1</span>);<span class="comment">//传入k-1是因为默认的head节点指向的是链表的第一个节点，所以只要移动k-1次就到了，第k个节点上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">helper</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode start=head,end=start;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="keyword">for</span> (index=<span class="number">0</span>;index&lt;k&amp;&amp;end!=<span class="keyword">null</span>;++index)&#123;<span class="comment">//让end移动到第k个节点上</span></span><br><span class="line">            end=end.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index!=k||end==<span class="keyword">null</span>)<span class="comment">//这种情况下，说明不够k个，直接返回head，即不翻转</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode node=end.next;<span class="comment">//保留此k个节点之后的哪一个节点</span></span><br><span class="line">        end.next=<span class="keyword">null</span>;<span class="comment">//这里先将k个节点与后面的连接断开，方便翻转链表</span></span><br><span class="line">        reverse(start);<span class="comment">//翻转这k个节点</span></span><br><span class="line">        start.next=helper(node,k);<span class="comment">//让前k个节点的头节点的next指向后k个节点的尾节点</span></span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 翻转链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode pre=head,next=pre.next;</span><br><span class="line">        <span class="keyword">while</span> (next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode tmp=next.next;</span><br><span class="line">            next.next=pre;</span><br><span class="line">            pre=next;</span><br><span class="line">            next=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O(n)"></a>时间复杂度：O(n)</h3><p>由于有<strong>n/k向下取整</strong>个个要翻转的子链表，每个子链表的翻转的时间为k，所以时间复杂度为O(n)</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-31</title>
    <url>/2020/05/22/LeetCode-31/LeetCode-31/</url>
    <content><![CDATA[<h1 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</span><br><span class="line"></span><br><span class="line">如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</span><br><span class="line"></span><br><span class="line">必须原地修改，只允许使用额外常数空间。即使用空间一定。</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</span><br><span class="line">1,2,3 → 1,3,2</span><br><span class="line">3,2,1 → 1,2,3</span><br><span class="line">1,1,5 → 1,5,1</span><br></pre></td></tr></table></figure>
<h2 id="思路1-一次扫描"><a href="#思路1-一次扫描" class="headerlink" title="思路1-一次扫描"></a>思路1-一次扫描</h2><p>从左向右找到第一个连续的升序排放的两个数字，然后从尾部找到比它稍微大一点的数字，交换到升序两个数中小的哪一个位置处，然后对小的那个数字后面的子数组进行排序（升序），使它的后面值最小，那么就是适合题意得解决了。由于子数组中一定是降序排放得，所以直接交换两端的两个数字就可以了。</p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=nums.length-<span class="number">2</span>,j=i+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(nums[i]&lt;nums[j])&#123;</span><br><span class="line">				<span class="keyword">int</span> pos=nums.length-<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">int</span> temp=nums[i];</span><br><span class="line">				<span class="keyword">while</span>(pos&gt;i)&#123;</span><br><span class="line">					<span class="keyword">if</span>(nums[pos]&gt;nums[i])</span><br><span class="line">					&#123;</span><br><span class="line">						nums[i]=nums[pos];</span><br><span class="line">                        nums[pos]=temp;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">						pos--;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">                <span class="keyword">break</span>;		</span><br><span class="line">			&#125;</span><br><span class="line">			i--;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		reserve(nums, i+<span class="number">1</span>, nums.length);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reserve</span><span class="params">(<span class="keyword">int</span> nums[],<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(begin&lt;end)&#123;</span><br><span class="line">			temp=nums[begin];</span><br><span class="line">			nums[begin]=nums[end-<span class="number">1</span>];</span><br><span class="line">			nums[end-<span class="number">1</span>]=temp;</span><br><span class="line">			end--;</span><br><span class="line">			begin++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(n)，一次遍历最坏步数为n，即数组长度，加上逆序的步数（n/2），所以时间复杂度是O(n).</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-27</title>
    <url>/2020/05/20/LeetCode-27/LeetCode-27/</url>
    <content><![CDATA[<h1 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">给定 nums = [3,2,2,3], val = 3,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</span><br><span class="line"></span><br><span class="line">注意这五个元素可为任意顺序。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<h2 id="思路1-双指针法"><a href="#思路1-双指针法" class="headerlink" title="思路1-双指针法"></a>思路1-双指针法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先，使用两个指针分别指向数组的开头与结尾，然后判断第一个指针指向的元素是否与target一致，一致的话将后一个指针指向的元素移动到前面来（注意此处不要移动第一个元素，可以下一次循环时判断上一次移动过来的元素是否等于target）然后移动后一个指针的位置，如此循环。</span><br></pre></td></tr></table></figure>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;<span class="comment">//此处等于因为i移动到n位置时也要判断是否与val一致，如果一致n--，不一致n++,但最终结果总是n+1</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i]==val)&#123;</span><br><span class="line">            nums[i]=nums[n];</span><br><span class="line">            n--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O(n)"></a>时间复杂度：O(n)</h3><p>最坏的情况下结果数组中的元素可能为空，即原数组中全是目标值，那么移动次数总是n次（n为数组长度）。<br>####感想</p>
<blockquote>
<p>算法真的是一件很神奇的东西</p>
</blockquote>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-26</title>
    <url>/2020/05/20/LeetCode-26/LeetCode-26/</url>
    <content><![CDATA[<h1 id="删除数组中的重复项"><a href="#删除数组中的重复项" class="headerlink" title="删除数组中的重复项"></a>删除数组中的重复项</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。<br>说明:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="built_in">print</span>(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定数组 nums &#x3D; [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<h2 id="思路1-双指针"><a href="#思路1-双指针" class="headerlink" title="思路1-双指针"></a>思路1-双指针</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">首先，数组是已经排过序的，所以用两个间隔为1的指针，指向数组的开头两个元素，然后先移动后面一个指针，找到与第一个指针指向的数值不同的数字，然后先将第一个指针移动一位，然后将那个值存放在第一个指针处，然后继续移动后一个指针继续寻找不同的数值，最后返回的是第一个指针的位置加1，因为第一个指针的索引总是结果数组的最后一位，所以其加1就是数组长度。</span><br></pre></td></tr></table></figure>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] != nums[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O(n)"></a>时间复杂度：O(n)</h3><p>此处时间复杂度主要看的是后一个指针的移动步数（因为其总是大于等于前一个指针的移动步数的），任何情况下都是n(n为数组长度).<br>######感想</p>
<blockquote>
<p>我还是太菜了，瞅瞅别人这双指针多优雅。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-35</title>
    <url>/2020/05/24/LeetCode-35/LeetCode-35/</url>
    <content><![CDATA[<h1 id="有效的数独"><a href="#有效的数独" class="headerlink" title="有效的数独"></a>有效的数独</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">输出: false</span><br><span class="line">解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。</span><br><span class="line">     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</span><br></pre></td></tr></table></figure>
<h2 id="思路1-一次迭代"><a href="#思路1-一次迭代" class="headerlink" title="思路1-一次迭代"></a>思路1-一次迭代</h2><p>不断的把数字存入相应的行列九宫格数组中，然后判断所在位置的数字的数目是否合理，不合理直接返回false，最终结束循环后返回true。</p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">isValidSudoku1</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义三个9*9的二维数组，分别用来存储，每一行，每一列，每一个九宫格，由于默认初始化为0。</span></span><br><span class="line">    <span class="keyword">int</span>[][] rows = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">int</span>[][] columns = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">int</span>[][] boxes = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">char</span> num;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> box_index;</span><br><span class="line">    <span class="comment">// 验证</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">        num = board[i][j];</span><br><span class="line">        <span class="keyword">if</span> (num != <span class="string">'.'</span>) &#123;</span><br><span class="line">          n = num-<span class="string">'1'</span>;<span class="comment">//把当前的数值去字符化</span></span><br><span class="line">          box_index = (i / <span class="number">3</span> ) * <span class="number">3</span> + j / <span class="number">3</span>;<span class="comment">//确认当前所在索引是哪一个九宫格内部</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 将当前单元格的值存储到对应的某一行，某一列，以及某一个九宫格中</span></span><br><span class="line">          rows[i][n]+=<span class="number">1</span>;<span class="comment">//行</span></span><br><span class="line">          columns[j][n]+=<span class="number">1</span>;<span class="comment">//列</span></span><br><span class="line">          boxes[box_index][n]+=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 确认是否每个索引添加后的行、列、九宫格都是合格的。</span></span><br><span class="line">          <span class="keyword">if</span> (rows[i][n] &gt; <span class="number">1</span> || columns[j][n] &gt; <span class="number">1</span> || boxes[box_index][n] &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>由于数组格子的数目始终为81个，所以时间复杂度为O(1)</p>
<h2 id="思路2-一次迭代"><a href="#思路2-一次迭代" class="headerlink" title="思路2-一次迭代"></a>思路2-一次迭代</h2><p>将数组换位束字，用位串，来存储数目。</p>
<h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] row = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">int</span>[] col = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">int</span>[] squal = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j)</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> index = board[i][j] - <span class="string">'1'</span>;</span><br><span class="line">                    <span class="keyword">if</span> ((row[i] &amp; (<span class="number">1</span> &lt;&lt; index)) &gt; <span class="number">0</span> || (col[j] &amp; (<span class="number">1</span> &lt;&lt; index)) &gt; <span class="number">0</span> || (squal[i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>] &amp; (<span class="number">1</span> &lt;&lt; index)) &gt; <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    row[i] |= <span class="number">1</span> &lt;&lt; index;</span><br><span class="line">                    col[j] |= <span class="number">1</span> &lt;&lt; index;</span><br><span class="line">                    squal[i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>] |= <span class="number">1</span> &lt;&lt; index;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度：O-1"><a href="#时间复杂度：O-1" class="headerlink" title="时间复杂度：O(1)"></a>时间复杂度：O(1)</h3>]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-32</title>
    <url>/2020/05/23/LeetCode-32/LeetCode-32/</url>
    <content><![CDATA[<h1 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a>最长有效括号</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><blockquote>
<p>输入: “(()”</p>
<p>输出: 2</p>
<p>解释: 最长有效括号子串为 “()”</p>
</blockquote>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><blockquote>
<p>输入: “)()())”</p>
<p>输出: 4</p>
<p>解释: 最长有效括号子串为 “()()”</p>
</blockquote>
<h2 id="思路1-动态规划"><a href="#思路1-动态规划" class="headerlink" title="思路1-动态规划"></a>思路1-动态规划</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">从任意一个字符出发，如果它的前面一个字符是(则，包含他的前面字符串的任意</span><br><span class="line"></span><br><span class="line">子串一定是不合法的，所以将其能形成的合法字符串的长度置为0，如果前面是),</span><br><span class="line"></span><br><span class="line">那么看）所对应的（的前面一个字符。此时该字符位置处的值&#x3D;dp[index-1]</span><br><span class="line"></span><br><span class="line">+dp[index-1-dp[index-1]-1]+2;</span><br></pre></td></tr></table></figure>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">'('</span>) &#123;</span><br><span class="line">                    dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - dp[i - <span class="number">1</span>] - <span class="number">1</span>) == <span class="string">'('</span>) &#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + ((i - dp[i - <span class="number">1</span>]) &gt;= <span class="number">2</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxans = Math.max(maxans, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h3><p>由于只进行了一次字符串的扫描，所以时间复杂度为O(n)</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-36</title>
    <url>/2020/05/25/LeetCode-36/LeetCode-36/</url>
    <content><![CDATA[<h1 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>编写一个程序，通过已填充的空格来解决数独问题。</p>
<p>一个数独的解法需遵循如下规则：</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。<br>空白格用 ‘.’ 表示。<br>注意：<br>给定的数独序列只包含数字 1-9 和字符 ‘.’ 。<br>你可以假设给定的数独只有唯一解。<br>给定数独永远是 9x9 形式的。</p>
<h2 id="思路1-回溯法"><a href="#思路1-回溯法" class="headerlink" title="思路1-回溯法"></a>思路1-回溯法</h2><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">// box size</span></span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">  <span class="comment">// row size</span></span><br><span class="line">  <span class="keyword">int</span> N = n * n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> [][] rows = <span class="keyword">new</span> <span class="keyword">int</span>[N][N + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> [][] columns = <span class="keyword">new</span> <span class="keyword">int</span>[N][N + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> [][] boxes = <span class="keyword">new</span> <span class="keyword">int</span>[N][N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>[][] board;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> sudokuSolved = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">couldPlace</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Check if one could place a number d in (row, col) cell</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> idx = (row / n ) * n + col / n;</span><br><span class="line">    <span class="keyword">return</span> rows[row][d] + columns[col][d] + boxes[idx][d] == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeNumber</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Place a number d in (row, col) cell</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> idx = (row / n ) * n + col / n;</span><br><span class="line"></span><br><span class="line">    rows[row][d]++;</span><br><span class="line">    columns[col][d]++;</span><br><span class="line">    boxes[idx][d]++;</span><br><span class="line">    board[row][col] = (<span class="keyword">char</span>)(d + <span class="string">'0'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNumber</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Remove a number which didn't lead to a solution</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> idx = (row / n ) * n + col / n;</span><br><span class="line">    rows[row][d]--;</span><br><span class="line">    columns[col][d]--;</span><br><span class="line">    boxes[idx][d]--;</span><br><span class="line">    board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeNextNumbers</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Call backtrack function in recursion</span></span><br><span class="line"><span class="comment">    to continue to place numbers</span></span><br><span class="line"><span class="comment">    till the moment we have a solution</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// if we're in the last cell</span></span><br><span class="line">    <span class="comment">// that means we have the solution</span></span><br><span class="line">    <span class="keyword">if</span> ((col == N - <span class="number">1</span>) &amp;&amp; (row == N - <span class="number">1</span>)) &#123;</span><br><span class="line">      sudokuSolved = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if not yet</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// if we're in the end of the row</span></span><br><span class="line">      <span class="comment">// go to the next row</span></span><br><span class="line">      <span class="keyword">if</span> (col == N - <span class="number">1</span>) backtrack(row + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// go to the next column</span></span><br><span class="line">      <span class="keyword">else</span> backtrack(row, col + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Backtracking</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// if the cell is empty</span></span><br><span class="line">    <span class="keyword">if</span> (board[row][col] == <span class="string">'.'</span>) &#123;</span><br><span class="line">      <span class="comment">// iterate over all numbers from 1 to 9</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt; <span class="number">10</span>; d++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (couldPlace(d, row, col)) &#123;</span><br><span class="line">          placeNumber(d, row, col);</span><br><span class="line">          placeNextNumbers(row, col);</span><br><span class="line">          <span class="comment">// if sudoku is solved, there is no need to backtrack</span></span><br><span class="line">          <span class="comment">// since the single unique solution is promised</span></span><br><span class="line">          <span class="keyword">if</span> (!sudokuSolved) removeNumber(d, row, col);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> placeNextNumbers(row, col);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.board = board;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init rows, columns and boxes</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">        <span class="keyword">char</span> num = board[i][j];</span><br><span class="line">        <span class="keyword">if</span> (num != <span class="string">'.'</span>) &#123;</span><br><span class="line">          <span class="keyword">int</span> d = Character.getNumericValue(num);</span><br><span class="line">          placeNumber(d, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtrack(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>(9!)^9</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>回溯算法</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-33</title>
    <url>/2020/05/23/LeetCode-33/LeetCode-33/</url>
    <content><![CDATA[<h1 id="搜索排序数组"><a href="#搜索排序数组" class="headerlink" title="搜索排序数组"></a>搜索排序数组</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><blockquote>
<p>输入: nums = [4,5,6,7,0,1,2], target = 0</p>
<p>输出: 4</p>
</blockquote>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><blockquote>
<p>输入: nums = [4,5,6,7,0,1,2], target = 3</p>
<p>输出: -1</p>
</blockquote>
<h2 id="思路1-二分查找"><a href="#思路1-二分查找" class="headerlink" title="思路1-二分查找"></a>思路1-二分查找</h2><p>见代码</p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> exc=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(exc&lt;nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[exc]&lt;=nums[exc+<span class="number">1</span>])</span><br><span class="line">                exc++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp1=binarySearch(nums,target,<span class="number">0</span>,exc-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> temp2=binarySearch(nums,target,exc,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.max(temp1,temp2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> nums[],<span class="keyword">int</span> target,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]==target)<span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)<span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(nums[right]==target)<span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(left==right)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&gt;target)right=mid-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&lt;target)left=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(nums,target,left,right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(logn)</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-34</title>
    <url>/2020/05/24/LeetCode-34/LeetCode-34/</url>
    <content><![CDATA[<h1 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><blockquote>
<p>输入: [1,3,5,6], 5</p>
</blockquote>
<blockquote>
<p>输出: 2</p>
</blockquote>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><blockquote>
<p>输入: [1,3,5,6], 2</p>
<p>输出: 1</p>
</blockquote>
<h2 id="思路1-算法名字"><a href="#思路1-算法名字" class="headerlink" title="思路1-算法名字"></a>思路1-算法名字</h2><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(logn)</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-37</title>
    <url>/2020/05/25/LeetCode-37/LeetCode-37/</url>
    <content><![CDATA[<h1 id="外观数列"><a href="#外观数列" class="headerlink" title="外观数列"></a>外观数列</h1><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外观数列」是一个整数序列，从数字 <span class="number">1</span> 开始，序列中的每一项都是对前一项的描述。前五项如下：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.     <span class="number">1</span></span><br><span class="line"><span class="number">2</span>.     <span class="number">11</span></span><br><span class="line"><span class="number">3</span>.     <span class="number">21</span></span><br><span class="line"><span class="number">4</span>.     <span class="number">1211</span></span><br><span class="line"><span class="number">5</span>.     <span class="number">111221</span></span><br><span class="line"><span class="number">1</span> 被读作  <span class="string">"one 1"</span>  (<span class="string">"一个一"</span>) , 即 <span class="number">11</span>。</span><br><span class="line"><span class="number">11</span> 被读作 <span class="string">"two 1s"</span> (<span class="string">"两个一"</span>）, 即 <span class="number">21</span>。</span><br><span class="line"><span class="number">21</span> 被读作 <span class="string">"one 2"</span>,  <span class="string">"one 1"</span> （<span class="string">"一个二"</span> ,  <span class="string">"一个一"</span>) , 即 <span class="number">1211</span>。</span><br><span class="line"></span><br><span class="line">给定一个正整数 n（<span class="number">1</span> ≤ n ≤ <span class="number">30</span>），输出外观数列的第 n 项。</span><br><span class="line"></span><br><span class="line">注意：整数序列中的每一项将表示为一个字符串。</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><p>输入: 1<br>输出: “1”<br>解释：这是一个基本样例。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><p>输入: 4<br>输出: “1211”<br>解释：当 n = 3 时，序列是 “21”，其中我们有 “2” 和 “1” 两组，”2” 可以读作 “12”，也就是出现频次 = 1 而 值 = 2；类似 “1” 可以读作 “11”。所以答案是 “12” 和 “11” 组合在一起，也就是 “1211”。</p>
<h2 id="思路1-递归"><a href="#思路1-递归" class="headerlink" title="思路1-递归"></a>思路1-递归</h2><p>以上一个n对应的字符串作为这一次分析的对象，从左向右扫描字符串即可。</p>
<h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] patterns=<span class="keyword">new</span> String[<span class="number">31</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            patterns[<span class="number">1</span>]=<span class="string">"1"</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"1"</span>;        </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(patterns[n]==<span class="keyword">null</span>)&#123;                </span><br><span class="line">                <span class="comment">//下面为递归调用</span></span><br><span class="line">                String lastTime=countAndSay(n-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">char</span>[] array=lastTime.toCharArray();</span><br><span class="line">                StringBuilder result=<span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">                <span class="keyword">int</span> lastPos=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> nextPos;</span><br><span class="line">                <span class="keyword">for</span>(nextPos=<span class="number">1</span>;nextPos&lt;array.length;nextPos++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(array[nextPos]!=array[lastPos])&#123;</span><br><span class="line">                        result.append(nextPos-lastPos).append(array[lastPos]);</span><br><span class="line">                        lastPos=nextPos;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                patterns[n]=result.append(nextPos-lastPos).append(array[lastPos]).toString();</span><br><span class="line">                <span class="keyword">return</span> patterns[n];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> patterns[n];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>未知</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
</search>
