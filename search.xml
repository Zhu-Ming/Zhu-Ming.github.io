<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GIT移动文件导致任务管理器找不到服务</title>
    <url>/2019/12/11/GIT%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6%E5%AF%BC%E8%87%B4%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E6%89%BE%E4%B8%8D%E5%88%B0%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>移动GIT默认文件夹导致任务管理其找不到对应的服务。<br>1打开cmd,输入regedit</p>
<p>2找到HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory<br>\background\shell\git_gui\command，修改它的路径为现在的<br>git-gui.exe程序所在的路径。</p>
<p>3找到HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\background\shell\git_shell\command修改路径为现在的git-<br>bash.exe所在的路径。</p>
<p>完成</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-1</title>
    <url>/2019/10/19/LeetCode-1/</url>
    <content><![CDATA[<p>语言：Java</p>
<p>题目描述：<br>    给定一个数组，找出其中何为目标值的两个数。（你可以假设每种输入只有一种答案，且同样的元素不能被重复利用）<br>    实例：<br>     给定nums=[2,7,11,15],target=9;<br>     因为nums[0]+nums[1]==target=2+7=9<br>     所以返回[0,1]<br>     @author zm<br>实现思路：<br>一：</p>
<pre><code>二重循环，找到即输出。</code></pre><p>二：<br>    使用map，将数组存入map中，然后遍历这个数组，在map中查找target-a[i]的值如果有，说明有解，直接输出。<br>三：<br>    使用map，先将一部分数据存储，可以肯定的是，先输入map中的数据中一定没有相加之和位target的两个数字，然后边输入边查找map中是否有target-a[i]的值，如果有那么就直接输出。</p>
<p>代码：</p>
<pre><code>import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

public class o0001 {
    public static void main(String[] args) {
        int a[]=new int[] {2,9,11,15};
        int target=9;
        int[] b=solution_1(a,target);
        System.out.println(Arrays.toString(b));
    }
    /**
     * 解题思路1：先对数组排序，然后从第i个位置开始，由后向前找，如果找到与a[i]的和就是target的立即返回，如果找到和小于target的结束此次外层循环，继续下一次外层循环。
     * @time 时间复杂度：O(n^2)
     * @param a
     * @param target
     * @return
     */
    public static int[] solution_1(int a[],int target) {
        Arrays.sort(a);
        int[] b=new int[2];
        for(int i=0;i&lt;a.length;i++) {
            for(int j=a.length-1;j&gt;i;j--) {
                if(a[i]+a[j]==target) {
                    b[0]=i;
                    b[1]=j;
                }
                if(a[i]+a[j]&lt;target) {
                        break;
                }
            }
        }
        return b;
    }
    /**
     * 解题思路2：将数组中的数据放入map中，然后使用一次循环，在map中看有没有target-a[i]的数值的存在，如果有就立即输出，如果到结尾任然没有就抛出异常。
     * 时间复杂度：O(n)
     * @param a
     * @param target
     * @return
     */
    public static int[] solution_2(int a[],int target) {
        Map&lt; Integer, Integer&gt; map=new HashMap&lt;&gt;();
        for(int i=0;i&lt;a.length;i++) {
            map.put(a[i], i);
        }
        for(int i=0;i&lt;a.length;i++) {
            int value=target-a[i];
            if(map.containsKey(value)) {
                return new int[] {i,map.get(value)};
            }
        }
        throw new IllegalArgumentException(&quot;No two sum solution&quot;);//可以用抛出异常代替没有返回值的情况。
    }
    /**
     * 思路：先将数组的一部分数值放入map中，然后再剩余的数值中找target-a[i]是否再map中出现的，有出现的说明可以组成解。
     * @param a
     * @param target
     * @return
     */
    public static int[] solution_3(int a[],int target) {
        Map&lt; Integer, Integer&gt; map=new HashMap&lt;&gt;();
        for(int i=0;i&lt;a.length;i++) {
            int component=target-a[i];
            if(map.containsKey(component)) {
                return new int[] {i,map.get(component)};
            }
            map.put(a[i], i);
        }
        throw new IllegalArgumentException(&quot;数组不存在解&quot;);
    }
}</code></pre>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-2</title>
    <url>/2019/10/19/LeetCode-2/</url>
    <content><![CDATA[<p>题目描述：</p>
<p>给定两个非空链表表示两个非负整数，位数按照逆序存储他们的每个节点只存储单个数字，将两数相加<br>返回一个新的链表。<br>你可以假设除了数字0外，这两个数字都不以0开头.{即数字不为（002）转化为输入就是（2-&gt;0-&gt;0）也告诉我们结果不可能出现2-&gt;1-&gt;0-&gt;0这样的}</p>
<p>实例：</p>
<p>输入（2-&gt;4-&gt;3）,(5-&gt;6-&gt;4)</p>
<p>输出（7-&gt;0-&gt;8）</p>
<p>原因：342+465=807</p>
<p>思路：</p>
<p>一：</p>
<pre><code>通过Java自带的ArrayList数组列表，存放数值，并进行运算（首先取出两个数组列表上的相同位置处的数
值，若一个没有另外一个长则长的部分数值就是0，定义一个carry用于存放余数，定义一个sum用于存放和，然后
根据将sum对10取余的结果放入ArrayList,注意如果结尾余数不为0，那么还要将余数放入ArrayList中，防止进数
的丢失）</code></pre><p>二：</p>
<pre><code>使用自定义的ListNode节点类（包含值与指向下一个对象的指针），首先初始化一个头结点，注意此头结点不
作为返回值的一部分，然后定义对输入的两个链表的两指针（用于取出链表上的每个数值），在定义一指向头
结点的头指针，用于操作结果链表，定义sum,carry分别用于存放和，与进数之后的操作同思路1。</code></pre><p>代码：</p>
<pre><code>public class o0002 {
    public static void main(String[] args) {
//        ArrayList&lt;Integer&gt;a=new ArrayList&lt;&gt;();
//        a.add(0);
//        ArrayList&lt;Integer&gt;b=new ArrayList&lt;&gt;();
//        b.add(0);
//        a.add(0);
//        System.out.println(Arrays.toString(Solution_1(a,b).toArray()));
        ListNode a=new ListNode(2);
        ListNode _a=a;
        _a.next=new ListNode(0);
        _a=_a.next;
        _a.next=new ListNode(0);
        ListNode b=new ListNode(0);
        ListNode _b=b;
        _b.next=new ListNode(0);
        _b=_b.next;
        _b.next=new ListNode(0);
        ListNode result=Solution_2(a,b);
        while(result!=null) {
            System.out.println(&quot; &quot;+result.getVal());
            result=result.next;
        }
    }
    public static ArrayList&lt;Integer&gt; Solution_1(ArrayList&lt;Integer&gt;a,ArrayList&lt;Integer&gt;b){
        int len_a=a.size();
        int len_b=b.size();
        int sum=0;
        int next=0;
        ArrayList&lt;Integer&gt; result=new ArrayList&lt;&gt;();
        for(int i=0;i&lt;Math.max(len_a, len_b);i++) {
            sum=0;
            if(i&lt;len_a) {
                sum=sum+a.get(i);
            }
            if(i&lt;len_b) {
                sum=sum+b.get(i);
            }
            sum=sum+next;
            result.add(sum%10);
            next=sum/10;
//            if(i==Math.max(len_a,len_b)-1&amp;&amp;next!=0) {//此处防止，最高位的进数丢失。处理最高进项到最高位的算法不好
//                result.add(next);
//            }
        }
        if(next!=0) {//放在外面判断更容易理解。
            result.add(next);
        }
        while(result.get(result.size()-1)==0&amp;&amp;result.size()&gt;1) {//此处解决当所有位数都是0的情况，只保留一位0.此处是我多想了，题目中明确说不会以0开头
            result.remove(result.size()-1);
        }
        return result;
    }
    static class ListNode{//新建一个节点类
        public int val;//存储当前值
        public ListNode next;//指向下一个位置
        public ListNode(int i) {
            this.val=i;
        }
        public int getVal() {
            return val;
        }
    }
    public static ListNode Solution_2(ListNode a,ListNode b) {
        ListNode HeadNode=new ListNode(0);//头节点，不做返回值的一部分。
        ListNode p=a,q=b,curr=HeadNode;
        int carry=0;
        while(p!=null||q!=null) {
            int x=p!=null?p.getVal():0;
            int y=q!=null?q.getVal():0;
            int sum=x+y+carry;
            carry=sum/10;
            curr.next=new ListNode(sum%10);
            curr=curr.next;
            if(p!=null) {
                p=p.next;
            }
            if(q!=null) {
                q=q.next;
            }
        }
        if(carry!=0) {
            curr.next=new ListNode(carry);
        }
        return HeadNode.next;
    }
}</code></pre>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1003</title>
    <url>/2019/09/15/PTA-Basic-1003/</url>
    <content><![CDATA[<p>“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。</p>
<p>得到“答案正确”的条件是：</p>
<p>字符串中必须仅有 P、 A、 T这三种字符，不可以包含其它字符；]<br>任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串;</p>
<p>如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a、 b、 c 均或者是空字符串，或者是仅由字母 A 组成</p>
<p>的字符串。</p>
<p>现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。</p>
<p>输入格式：<br>每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 n (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。</p>
<p>输出格式：<br>每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出 YES，否则输出 NO。</p>
<p>输入样例：</p>
<p>8</p>
<p>PAT</p>
<p>PAAT</p>
<p>AAPATAA</p>
<p>AAPAATAAAA</p>
<p>xPATx</p>
<p>PT</p>
<p>Whatever</p>
<p>APAAATAA</p>
<p>输出样例：</p>
<p>YES</p>
<p>YES</p>
<p>YES</p>
<p>YES</p>
<p>NO</p>
<p>NO</p>
<p>NO</p>
<p>NO<br>题目分析：</p>
<p>1必须含有P,A,T这三个字符，且不含其他字符。<br>2字符P ,T 的数目必须为1；<br>3字符P与T之间的字符数*P字符前A的个数必须等于字符T后的A的数目。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;

#include&lt;string.h&gt;

int main(void){

int number;
scanf(&quot;%d&quot;,&amp;number);
char str[100];
int i=0;
char* result[number];
while(i&lt;number){
    int number_p=0;
    int number_t=0;
    int flag1=0,flag2=0,flag3=0;
    int index_p=0,index_t=0;
    scanf(&quot;%s&quot;,str);
    getchar();
    for(int j=0;j&lt;strlen(str);j++){
        if(str[j]==&apos;A&apos;){
            flag1=1
        }
        if(str[j]==&apos;P&apos;){
            flag2=1;
            number_p++;
        }
        if(str[j]==&apos;T&apos;){
            flag3=1;
            number_t++;
        }
        if(str[j]!=&apos;A&apos;&amp;&amp;str[j]!
=&apos;T&apos;&amp;&amp;str[j]!=&apos;P&apos;){
            break;
        }else{
            if(str[j]==&apos;P&apos;){
                index_p=j;
            }
            if(str[j]==&apos;T&apos;){
                index_t=j;
                break;
            }
        }
    }
    if(index_p!=index_t&amp;&amp;(index_p*(index_t-index_p-1)==(strlen(str)-index_t-1))

&amp;&amp;flag1&amp;&amp;flag2&amp;&amp;flag3&amp;&amp;number_p==1&amp;&amp;number_t==1){
        result[i]=&quot;YES&quot;;
    }else{
        result[i]=&quot;NO&quot;;
    }
    i++;
}
for(int i=0;i&lt;number;i++){
    printf(&quot;%s\n&quot;,result[i]);
}
return 0;

} </code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-3</title>
    <url>/2019/10/20/LeetCode-3/</url>
    <content><![CDATA[<p>实现语言：Java</p>
<p>题目：</p>
<p>给定一个字符串，找出不含重复字符的最长字串的长度。</p>
<p>实例：</p>
<p>给定字符串“abcabcbb”,没有重复字符的最长字串是“abc”，那么长度就是3.</p>
<p>给定字符串“bbbbb”,最长的字串就是”b”,长度是1.</p>
<p>给定”pwwkew”,最长字串是“wke”,长度是3。</p>
<p>注意：答案必须是一个字串，“pwke”是子序列，而不是子字符串。</p>
<p>思路：</p>
<p>大体上就是一种思路，只是使用的工具不同罢了。</p>
<p>一：</p>
<p>将输入的字符串一个一个存入集合中，如果集合中已经含有有某个字符了，说明在此处已经达到了一个符合题目要求的字串，如果它的长度比上一个大，就将它的长度赋值给max.只要已经找到重复的字符了，就应该将集合清空，并将这个重复的字符输入到集合中，用于下一次的计算。如果字符集合中没有这个字符也应该输入字符集合，用于下一次的计算。</p>
<p>二：</p>
<p>首先定义两个坐标一个用于定位当前字符的位置，另一个用于定位重复字符在字符串中的位置，然后用每个长度与最大值比较（并决定是否改变最大值）。</p>
<p>三：</p>
<p>定义一个map用于存放字符与其相应的位置，然后边加入，边查找有没有重复的字符，如果有，取出当前重复字符的位置（与上一个重复字符的位置比较，防止其坐标比上一个重复的字符坐标小）。然后求长度并用当前对打长度与目前所求长度比对。加入这个字符，与对应的位置。</p>
<p>代码：</p>
<pre><code>import java.util.*;

public class o0003 {
    public static void main(String[] args) {
        System.out.println(Solution_3(&quot;pwwkew&quot;));
    }
    /**
     * @param sub 输入的字符串
     * @param max 用于存储最长字串的长度
     * @return max 最长字串的长度
     */
    public static int Solution_1(String sub) {
        int max=0;
        Set&lt;Character&gt; coll=new HashSet&lt;Character&gt;();
        for(int i=0;i&lt;sub.length();i++) {
            if(coll.contains(sub.charAt(i))) {//就算此处集合中已经有了这个字符，也应该清空集合，加入这个字符以便下一次的计算。
                if(coll.size()&gt;max) {
                    max=coll.size();
                }
                coll.clear();//如果有重复的就清空集合
            }
            coll.add(sub.charAt(i));
        }
        return max;
    }
    /**
     * @param i 用于记录重复字符的位置。
     * @param sub
     * @return
     */
    public static int Solution_2(String sub) {
        int max=0,len=sub.length();
        int i=0,j=0;
        Set &lt;Character&gt; set=new HashSet&lt;&gt;();
        while(i&lt;len&amp;&amp;j&lt;len) {
            if(!set.contains(sub.charAt(j))) {//如果集合中没有这个字符，就将其加入集合，并将集合的长度与目前为止的最大长度比较，然后决定是否改变它。
                set.add(sub.charAt(j++));//首先将其加入集合中。
                max=Math.max(max, j-i);//比较。
            }else {
                set.remove(sub.charAt(i++));//如果有这个字符了，就一直删除字符，直到找到重复的那个字符,重复的那个字符也会被删除。
            }
        }
        return max;
    }
    public static int Solution_3(String sub) {
        int len=sub.length(),max=0;
        Map&lt;Character,Integer&gt;map=new HashMap&lt;&gt;();
        for(int i=0,j=0;j&lt;len;j++) {
            if(map.containsKey(sub.charAt(j))) {
                i=Math.max(i, map.get(sub.charAt(j)));//i用来存储当前已有字符在字符串中的位置。为什么要与上一个i比较呢？因为上一个i代表的是上一个重复的字符在字符串中的位置，而这一个字的位置可能在上一个字符的后面所以因该取他们的最大值。
            }
            max=Math.max(max, j+1-i);//j+1代表当前字符在字符串中的位置，i代表上一个重复字符在字符串中的位置。
            map.put(sub.charAt(j), j+1);//将字符放入hash表中，如果已经有就覆盖它。
        }
        return max;
    }
}</code></pre>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1006</title>
    <url>/2019/09/15/PTA-Basic-1006/</url>
    <content><![CDATA[<p>#1006 换个格式输出整数<br>让我们用字母 B 来表示“百”、字母 S 表示“十”，用 12…n 来表示不为零的个位数字 n（&lt;10），换个格式来输出任一个不超过 3 位的正整数。例如 234 应该被输出为 BBSSS1234，因为它有 2 个“百”、3 个“十”、以及个位的 4。</p>
<p>输入格式：<br>    每个测试输入包含 1 个测试用例，给出正整数 n（&lt;1000）。</p>
<p>输出格式：<br>    每个测试用例的输出占一行，用规定的格式输出 n。</p>
<p>输入样例 1：</p>
<pre><code>234</code></pre><p>输出样例 1：</p>
<pre><code>BBSSS1234</code></pre><p>输入样例 2：</p>
<pre><code>23</code></pre><p>输出样例 2：</p>
<pre><code>SS123</code></pre><hr>
<p>分析：</p>
<p>1因为输入的数字小于1000，所以定义一个数组长度为3的整型数组，存放数字的个位，十位，百位。</p>
<p>2再定义一个足够大的数组存放结果。</p>
<p>3倒叙遍历存放数字的数组，按按百对应下标为2，十位对应的下标为1，个位对应的下标的为0，分别对处理。</p>
<p>4注意一定要在最后将字符数组的最后置为’\0’,否则会输出错误。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
char result[1000];
int number;
scanf(&quot;%d&quot;,&amp;number);

int n=0;
int num[3]={0};
while(number){
    num[n++]=number%10;
    number=number/10;
}
int step=0;
for(int i=3;i&gt;=0;i--){
    int time=num[i];
    if(time==0){
        continue;
    }
    if(i==2)
        for(int j=0;j&lt;time;j++){
        result[step++]=&apos;B&apos;;
    }
    if(i==1)
        for(int j=0;j&lt;time;j++){
        result[step++]=&apos;S&apos;;
    }
    if(i==0){
        for(int j=0;j&lt;time;j++){
        result[step++]=j+&apos;1&apos;;
        }
    }

}
result[step]=&apos;\0&apos;;
printf(&quot;%s&quot;,result);
return 0;
}</code></pre><p>另一种思路：</p>
<p>分析：</p>
<p>利用字符串长度判断输入的是几位数，再利用字符串倒置输出对应的题目要求符号</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

int main()
{
int i,j;
char n[4];
scanf(&quot;%s&quot;,n);

for(i=strlen(n);i&gt;0;i--){
    for(j=1;j&lt;=(n[strlen(n)-i]-&apos;0&apos;);j++){
        if(i==3)
            printf(&quot;B&quot;);
        if(i==2)
            printf(&quot;S&quot;);
        if(i==1)
            printf(&quot;%d&quot;,j);
    }
}
printf(&quot;\n&quot;);
return 0;
}</code></pre><p><a href="https://blog.csdn.net/huaxuewan/article/details/85778884" title="参考资料">https://blog.csdn.net/huaxuewan/article/details/85778884</a></p>
]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1005</title>
    <url>/2019/09/15/PTA-Basic-1005/</url>
    <content><![CDATA[<p>卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。</p>
<p>当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 n=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”，如果 n 不能被数列中的其他数字所覆盖。</p>
<p>现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。</p>
<p>输入格式：<br>    每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 K (&lt;100)，第 2 行给出 K 个互不相同的待验证的正整数 n (1&lt;n≤100)的值，数字间用空格隔开。</p>
<p>输出格式：<br>    每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。</p>
<p>输入样例：</p>
<pre><code>6
3 5 6 7 8 11</code></pre><p>输出样例：</p>
<pre><code>7 6</code></pre><hr>
<p>分析：</p>
<p>1定义一个数组存储输入的数字。</p>
<p>2遍历数组的每一个数字，对它们每个数字求其覆盖的数字，对被覆盖的每个数字一一与输入的数组对比，如果有相同的就将处于该位置的数字置为1，因为题目中提到数字在（1&lt;n&lt;=100）之间，所以便利该数组时可以遇到一就跳过去。</p>
<p>3最后数组中只剩下不能被数组中的其他元素所覆盖的数字了，这就是要求的关键数的数组。</p>
<p>4对这个数组进行排序，直到第一个为1的下标。</p>
<p>5按要求输出下标前面的数字。</p>
<hr>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
//此处是比较函数，用于对处理后的数组排序。
int compare(const void *a,const void *b){
if(*(int *)a&gt;*(int *)b)
return -1;
if(*(int *)a&lt;*(int *)b)
return 1;
return 0;
}
int main(void){
int number;
scanf(&quot;%d&quot;,&amp;number);
int num[number];
int i=0;
while(i&lt;number){ 
    scanf(&quot;%d&quot;,&amp;num[i++]);
}
for(i=0;i&lt;number;i++){
    int n=num[i];
    if(n==1){
        continue;
    }
    while(1){
     if(n==1){
        break;
    }
    if(n%2==0){
        n=n/2;
    }else{
        n=(3*n+1)/2;
    }
    for(int m=0;m&lt;number;m++){
        if(n==num[m]){
            num[m]=1;// 因为数组的数字各不相同，找到被覆盖的即可跳出循环
            break;
        }
      }
    }
}
qsort(num,sizeof(num)/sizeof(int),sizeof(int),compare);
int flag=1;
for(int i=0;i&lt;number;i++）{
    if(num[i]==1)break;
    if(flag){
        flag=0;
        printf(&quot;%d&quot;,num[i]);
    }else{
        printf(&quot; %d&quot;,num[i]);
    }
}
return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle学习</title>
    <url>/2019/09/14/Oracle%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>#####为什么要使用数据库？<br>Java中的数据储存：通过变量（基本了类型：存储少量数据，引用类型存储：存储数据，保证数据的完整性）<br>Java中的数据源：1声明变量直接赋值，2io流从硬盘中读取。<br>Java在处理数据时，需要从硬盘中读取数据，如果数据存放的非常凌乱的话，就会造成数据读取效率的大大降低，还有可能带来数据的冗余。<br>#####解决方法：<br>使用数据库存储数据，数据库时帮助我们更合理的存储数据到硬盘。</p>
<hr>
<p>数据库相关概念：<br>数据：描述事物，且能在计算机中表示的符号集合。<br>数据库：包括数据库管理系统，真正的数据库。<br>数据库管理系统：用户直接用来操作数据库的软件。<br>数据库系统：包括用户，数据库应用系统，数据库管理系统，与数据库。<br>开发人员使用数据库管理系统，普通人使用数据库应用系统。</p>
<hr>
<p>数据库发展阶段：<br>1网状数据库阶段，2层次数据库阶段，3关系数据库阶段。<br>4对象数据库阶段，5NOSQL数据库。</p>
<p>关系数据库特点：A:采用关系结构存与管理数据，B采用结构化语言查询（SQL）作为客户端数据库与服务器之间沟通的桥梁。C此时目前的主流的数据库技术。D采用二维表存储，存储数据，数据的表示，数据之间的关系，常见的有<em>Oracle，MySQL</em>，sqlserver DB2，Access.</p>
<p>对象数据库特点：吧面向对象的方法和数据库技术结合到一起，可以使数据库系统的分析与设计最大程度地与人们对客观世界的认知相符合。</p>
<p>NOSQL数据库特点:<br>A:not only SQL 数据库，如MongoDB，B关系数据库在超大规模和高并发的web2.0的纯动态网站已经显得力不从心，暴露了很多难以克服的问题，NOSQL数据库的产生就是为了解决大规模数据集合和多重数据带来的挑战。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1008</title>
    <url>/2019/09/16/PTA-Basic-1008/</url>
    <content><![CDATA[<p>一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（A<br>​0<br>​​ A<br>​1<br>​​ ⋯A<br>​N−1<br>​​ ）变换为（A<br>​N−M<br>​​ ⋯A<br>​N−1<br>​​ A<br>​0<br>​​ A<br>​1<br>​​ ⋯A<br>​N−M−1<br>​​ ）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p>
<p>输入格式:</p>
<pre><code>每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。</code></pre><p>输出格式:</p>
<pre><code>在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。</code></pre><p>输入样例:</p>
<pre><code>6 2
1 2 3 4 5 6</code></pre><p>输出样例:</p>
<pre><code>5 6 1 2 3 4</code></pre><hr>
<p>分析：</p>
<p>题目要求输入一个数组，将数组右移，并输出。</p>
<p>思路：</p>
<pre><code>本题并没有按照题目要求的那样改变数组，而是改变数组输出的顺

序，先输出原数组从n-m到n-1的数字，再输出0到n-m-2的数字（为什么不输出到n-m-1,这是为了题目的输出

格式要求。），最后在输出下标为n-m-1的数组中的数字。


##注意：

如果右移的位数大于输入数字的个数，就用位数对个数取余，并将余数设置为位移的位数，因为如果唯

一的位数大于数字数目，就会多做一次周期位移（周期位移后数组不变）。</code></pre><p>代码：</p>
<pre><code>#include&lt;stdio.h&gt; 
int main(void){
    int n,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    m=m%n;
    int list[n];
    int k=0;
    while(k&lt;n){
       scanf(&quot;%d&quot;,&amp;list[k++]);
    }  
    int i;
    for(i=n-m;i&lt;n;i++){
        printf(&quot;%d &quot;,list[i]);
    }
    for(i=0;i&lt;n-m-1;i++){
        printf(&quot;%d &quot;,list[i]);
    }
    printf(&quot;%d&quot;,list[i]);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT_Basic-1004</title>
    <url>/2019/09/15/PTA-Basic-1004/</url>
    <content><![CDATA[<p>读入 n（&gt;0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。</p>
<p>输入格式：<br>每个测试输入包含 1 个测试用例，格式为</p>
<p>第 1 行：正整数 n</p>
<p>第 2 行：第 1 个学生的姓名 学号 成绩</p>
<p>第 3 行：第 2 个学生的姓名 学号 成绩<br>  … … …<br>第 n+1 行：第 n 个学生的姓名 学号 成绩</p>
<p>其中姓名和学号均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。</p>
<p>输出格式：<br>对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。</p>
<p>输入样例：</p>
<p>3</p>
<p>Joe Math990112 89</p>
<p>Mike CS991301 100</p>
<p>Mary EE990830 95</p>
<p>输出样例：</p>
<p>Mike CS991301</p>
<p>Joe Math990112</p>
<hr>
<p>分析：</p>
<p>1直接使用结构体的两个对象存储最大和最小分数对应的学生。<br>2在输入时比较分数的大小，比最大的的的就将最大的重新赋值，比最小的小的就将最小的重新赋值。</p>
<p>##代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
typedef struct student{
char name[11];
char id[11];
int score;
};
int main(void){
int number;
scanf(&quot;%d&quot;,&amp;number);
getchar();
struct student max,min;
number--;
scanf(&quot;%s %s %d&quot;,max.name,max.id,&amp;max.score);
min=max;
while(number--){
    getchar();
    char name[11];
    char id[11];
    int score;
    scanf(&quot;%s %s %d&quot;,name,id,&amp;score);
    if(max.score&lt;score){
        strcpy(max.name,name);
        strcpy(max.id,i
        max.score=score;
    }
    if(min.score&gt;score){
        strcpy(min.name,name);
        strcpy(min.id,id);
        min.score=score;
    }
}
printf(&quot;%s %s\n&quot;,max.name,max.id);
printf(&quot;%s %s&quot;,min.name,min.id);
return 0;
}
``</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1007</title>
    <url>/2019/09/16/PTA-Basic-1007/</url>
    <content><![CDATA[<p>让我们定义d<br>n<br>​​ 为：d<br>​n<br>​​ =p<br>​n+1<br>​​ −p<br>​n<br>​​ ，其中p<br>​i<br>​​ 是第i个素数。显然有d<br>​1<br>​​ =1，且对于n&gt;1有d<br>​n<br>​​ 是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。</p>
<p>现给定任意正整数N(&lt;10<br>​5<br>​​ )，请计算不超过N的满足猜想的素数对的个数。</p>
<p>输入格式:</p>
<pre><code>输入在一行给出正整数N。</code></pre><p>输出格式:</p>
<pre><code>在一行中输出不超过N的满足猜想的素数对的个数。</code></pre><p>输入样例:</p>
<pre><code>20</code></pre><p>输出样例:</p>
<pre><code>4</code></pre><hr>
<p>分析：<br>1题目要求给出一个数字要求输出这个数字以内的素数对个数。</p>
<p>2素数对条件（1为素数，2两个素数相差2）；</p>
<p>思路：</p>
<p>1做一个判断是否时素数的函数。</p>
<p>2因为素数必定不为除2以外的偶数，所以直接从3开始去奇数判断是否为素数，并判断这个数字加2是否也是素数，如果是，则计算素数对个数的变量加1，否则就继续循环，直到超过所给的数字的大小。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;  
int isPrime(int n){
//函数
    for(int i=3;i&lt;=(int)sqrt(n+1);i+=2){
        if(n%i==0){
            return 0;
        }
    }
    return 1;
}
int main(void){
int n;
scanf(&quot;%d&quot;,&amp;n);
int num=0;
for(int i=3;i&lt;=n;i+=2){
    if(isPrime(i)&amp;&amp;isPrime(i+2)&amp;&amp;(i+2)&lt;=n){
        num++;
    }
}
printf(&quot;%d&quot;,num);
return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1011</title>
    <url>/2019/09/17/PTA-Basic-1011/</url>
    <content><![CDATA[<p>给定区间 [−2^31,2^31] 内的 3 个整数 A、B 和 C，请判断 A+B 是否大于 C。</p>
<p>输入格式：</p>
<p>输入第 1 行给出正整数 T (≤10)，是测试用例的个数。随后给出 T 组测试用例，每组占一行，顺序给出 A、B 和 C。整数间以空格分隔。</p>
<p>输出格式：</p>
<p>对每组测试用例，在一行中输出 Case #X: true 如果 A+B&gt;C，否则输出 Case #X: false，其中 X 是测试用例的编号（从 1 开始）。</p>
<p>输入样例：</p>
<p>4</p>
<p>1 2 3</p>
<p>2 3 4</p>
<p>2147483647 0 2147483646</p>
<p>0 -2147483648 -2147483647</p>
<p>输出样例：</p>
<p>Case #1: false</p>
<p>Case #2: true</p>
<p>Case #3: true</p>
<p>Case #4: false</p>
<p>分析：</p>
<p>输入：个数，每一行一一组数据。<br>输出：判定结果。</p>
<p>难点：<br>数字的长度过大，使用long long 类型，long long对应的长度为（-2^63,2^63 -1）足够存储数据，与加后的数据了;</p>
<p>对定义后的字符数组赋值时，必须使用strcpy（）函数</p>
<p>思路：输入一组比较一组，结果存放在字符数组中。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main(void){
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    long long number1,number2,number3;
    char result[n][8];
    int i=0;
    while(i&lt;n){
        scanf(&quot;%ld %ld %ld&quot;,&amp;number1,&amp;number2,&amp;number3);
        strcpy(result[i],(number1+number2&gt;number3)?&quot;true&quot;:&quot;false&quot;);
        i++;
    }
    for(i=0;i&lt;n;i++){
        printf(&quot;Case #%d: %s\n&quot;,i+1,result[i]);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1012</title>
    <url>/2019/09/17/PTA-Basic-1012/</url>
    <content><![CDATA[<p>给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字：</p>
<p>A<br>​1<br>​​  = 能被 5 整除的数字中所有偶数的和；<br>A<br>​2<br>​​  = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 n<br>​1<br>​​ −n<br>​2<br>​​ +n<br>​3<br>​​ −n<br>​4<br>​​ ⋯；<br>A<br>​3<br>​​  = 被 5 除后余 2 的数字的个数；<br>A<br>​4<br>​​  = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位；<br>A<br>​5<br>​​  = 被 5 除后余 4 的数字中最大数字。<br>输入格式：<br>每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N，随后给出 N 个不超过 1000 的待分类的正整数。数字间以空格分隔。</p>
<p>输出格式：<br>对给定的 N 个正整数，按题目要求计算 A<br>​1<br>​​ ~A<br>​5<br>​​  并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。</p>
<p>若其中某一类数字不存在，则在相应位置输出 N。</p>
<p>输入样例 1：</p>
<p>13 1 2 3 4 5 6 7 8 9 10 20 16 18</p>
<p>输出样例 1：</p>
<p>30 11 2 9.7 9</p>
<p>输入样例 2：</p>
<p>8 1 2 4 5 6 7 9 16</p>
<p>输出样例 2：</p>
<p>N 11 2 N 9</p>
<p>分析：<br>输入：一个代表个数的数字，后面跟着相应个数的数字。<br>输出：</p>
<p>1number%2==0&amp;&amp;number%5==0的数字的和</p>
<p>2number%5==1的差项和a1-a2+a3-a4…</p>
<p>3number%5==2的个数</p>
<p>4number%5==3的数字的平均数，保留一位小数。</p>
<p>5number%5==4的所有数字中的最大数。</p>
<p>以上所有输出如果不存在时，输出‘N’;</p>
<p>思路：</p>
<p>1输入时就处理数字，对每个数字判断，存放在二维数组，第一行存储个数，第二行存储结果。</p>
<p>2输出时一定要注意，当输出平均数时，要注意到我们使用的时整型数组，因此就要进行相应的处理。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
static int result[2][5];
int num=0;
scanf(&quot;%d&quot;,&amp;nu2m);
int number;
int i=0;
int flag=1;
while(i&lt;num){
    scanf(&quot;%d&quot;,&amp;number);
    if(number%2==0&amp;&amp;number%5==0){
        result[0][0]++;
        result[1][0]=result[1][0]+number;
    }
    if(number%5==1){
        result[0][1]++;
        result[1][1]=result[1][1]+flag*number;
        flag=-flag;
    }
    if(number%5==2){
        result[0][2]++;
        result[1][2]++;
    }
    if(number%5==3){
        result[0][3]++;
        result[1][3]=result[1][3]+number;
    }
    if(number%5==4){
        result[0][4]++;
        result[1][4]=result[1][4]&gt;=number?result[1][4]:number;
    }
    i++;
}

for(i=0;i&lt;4;i++){
    if(i==3){
        if(result[0][i]==0){
            printf(&quot;N &quot;);
        }else{
            printf(&quot;%.1f &quot;,result[1][i]*1.0/result[0][i]);
        }
        continue;
    }
    if(result[0][i]==0){
        printf(&quot;N &quot;);
    }
    else{
        printf(&quot;%d &quot;,result[1][i]);
    }
}
if(result[0][i]==0){
        printf(&quot;N&quot;);
    }
    else{
        printf(&quot;%d&quot;,result[1][i]);
    }
return 0; 
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1009</title>
    <url>/2019/09/17/PTA-Basic-1009/</url>
    <content><![CDATA[<p>给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。</p>
<p>输入格式：<br>测试输入包含一个测试用例，在一行内给出总长度不超过 80 的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用 1 个空格分开，输入保证句子末尾没有多余的空格。</p>
<p>输出格式：<br>每个测试用例的输出占一行，输出倒序后的句子。</p>
<p>输入样例：</p>
<p>Hello World Here I Come</p>
<p>输出样例：</p>
<p>Come I Here World Hello</p>
<p>分析：<br>1给出一句话，要求单词顺序不变，倒序输出所有单词。<br>首先要输出最后一个单词，接着是倒数第二个… ,直到到达首单词。</p>
<p>思路：双指针算法。<br>1用一个字符数组存储输入的字符串；使用两个字符指针，一个用来指向空格的位置，另一个用来输出空格与空格或者空格与     ‘\0’    之间的单词（字符串的末尾会存放一个‘\0’）,然后继续此操作直到到达第一个单词，第一个单词不输出（因题目格式要求）<br>2另外输出第一个单词。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#define MAX 81
int main(void){
char str[MAX];
char *p,*q;
gets(str);
for(p=str+strlen(str)-1;p!=str;p--){//输出到第一个单词停止。
    if(*p==&apos; &apos;){//如果读到一个空格，说明，一个单词已经结束。
        for(q=p+1;*q!=&apos; &apos;&amp;&amp;*q;q++){
            printf(&quot;%c&quot;,*q);
        }
        printf(&quot; &quot;);
    }
}
for(p=str;*p!=&apos; &apos;&amp;&amp;*p;p++){
//此处判定条件中的*p是为了防止输入一个单词时造成死循环。因为只输入一个单词时，也作为字符串末尾也会加上一个&apos;\0&apos;.
    printf(&quot;%c&quot;,*p);
}
return 0;
}</code></pre><p>######如果有更好的思路欢迎交流。</p>
]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1014</title>
    <url>/2019/09/18/PTA-Basic-1014/</url>
    <content><![CDATA[<p>大侦探福尔摩斯接到一张奇怪的字条：我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间星期四 14:04，因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 D，代表星期四；第 2 对相同的字符是 E ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示）；后面两字符串第 1 对相同的英文字母 s 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。</p>
<p>输入格式：</p>
<p>输入在 4 行中分别给出 4 个非空、不包含空格、且长度不超过 60 的字符串。</p>
<p>输出格式：</p>
<p>在一行中输出约会的时间，格式为 DAY HH:MM，其中 DAY 是某星期的 3 字符缩写，即 MON 表示星期一，TUE 表示星期二，WED 表示星期三，THU 表示星期四，FRI 表示星期五，SAT 表示星期六，SUN 表示星期日。题目输入保证每个测试存在唯一解。</p>
<p>输入样例：</p>
<p>3485djDkxh4hhGE </p>
<p>2984akDfkkkkggEdsb </p>
<p>s&amp;hgsfdk </p>
<p>d&amp;Hyscvnm</p>
<p>输出样例：</p>
<p>THU 14:04</p>
<p>分析：</p>
<p>输入：四个字符串，一行一个。</p>
<p>处理：首先找出前面两个字符串中的第一个相应位置上相等的大写字母，并记录字母；以第一个大写字母相同的为第一个相等的字符，找出第二对相等的且为（0-9或A-N）中的字符，并记录。<br>在找出后两个字符串中对应位置上相等字符的下标，并记录。</p>
<p>输出：见题目（注意：小时&lt;10时要补0，分钟小于&lt;10要补0）；</p>
<p>思路：</p>
<p>定义四个字符数组，存储数据。<br>遍历前两字符串，找出第一个字符（大写字母），第二个字符（0-9或A-N）；<br>遍历后面两个字符串，找到第一个对应位置上相等的字符下标。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main(void){
    char str[4][800];
    int i=0;
    while(i&lt;4){
    scanf(&quot;%s&quot;,str[i++]);
    getchar();
    }
    char* res;
    int flag=1;
    int h=0;
    for(i=0;i&lt;strlen(str[1])&amp;&amp;i&lt;strlen(str[0]);i++){
    if(!flag&amp;&amp;((str[0][i]&gt;=&apos;A&apos;&amp;&amp;str[0][i]&lt;=&apos;N&apos;)||(str[0][i]&gt;=&apos;0&apos;&amp;&amp;str[0][i]&lt;=&apos;9&apos;))&amp;&amp;str[0][i]==str[1][i]){
            switch(str[0][i]){
                case &apos;0&apos;:case &apos;1&apos;:case &apos;2&apos;:case &apos;3&apos;:
                case &apos;4&apos;:case &apos;5&apos;:case &apos;6&apos;:case &apos;7&apos;:
                case &apos;8&apos;:case &apos;9&apos;:h=str[0][i]-&apos;0&apos;;break;
                default:h=str[0][i]-&apos;A&apos;+10;break;
            }
            break;
        }
        if(flag&amp;&amp;str[0][i]&gt;=&apos;A&apos;&amp;&amp;str[0][i]&lt;=&apos;G&apos;&amp;&amp;str[0][i]==str[1][i]){
            flag=0;
            switch(str[0][i]){
                case &apos;A&apos;:res=&quot;MON&quot;;break;
                case &apos;B&apos;:res=&quot;TUE&quot;;break;
                case &apos;C&apos;:res=&quot;WED&quot;;break;
                case &apos;D&apos;:res=&quot;THU&quot;;break;
                case &apos;E&apos;:res=&quot;FRI&quot;;break;
                case &apos;F&apos;:res=&quot;SAT&quot;;break;
                case &apos;G&apos;:res=&quot;SUN&quot;;break;
            }
        }
    }
    for(i=0;i&lt;strlen(str[2])&amp;&amp;i&lt;strlen(str[3]);i++){
        if(((str[2][i]&lt;=&apos;z&apos;&amp;&amp;str[2][i]&gt;=&apos;a&apos;)||(str[2][i]&lt;=&apos;Z&apos;&amp;&amp;str[2][i]&gt;=&apos;A&apos;))&amp;&amp;str[2][i]==str[3][i]){
            break;
        }
    }
    printf(&quot;%s %02d:%02d&quot;,res,h,i);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1013</title>
    <url>/2019/09/17/PTA-Basic-1013/</url>
    <content><![CDATA[<p>令 P<br>​<br>​​  表示第 i 个素数。现任给两个正整数 M≤N≤10<br>​4<br>​​ ，请输出 P<br>​M<br>​​  到 P<br>​N<br>​​  的所有素数。</p>
<p>输入格式：<br>输入在一行中给出 M 和 N，其间以空格分隔。</p>
<p>输出格式：<br>输出从 P<br>​M<br>​​  到 P<br>​N<br>​​  的所有素数，每 10 个数字占 1 行，其间以空格分隔，但行末不得有多余空格。</p>
<p>输入样例：</p>
<pre><code>5 27</code></pre><p>输出样例：</p>
<pre><code>11 13 17 19 23 29 31 37 41 43
47 53 59 61 67 71 73 79 83 89
97 101 103</code></pre><p>分析：</p>
<p>输入：整型数字n,m;<br>输出：从第n个素数（包含在内）到第m个素数之间的所有素数.十个换一行。</p>
<p>思路：</p>
<p>1写一个判定素数的函数。<br>2for循环从2开始数每当是素数计算素数的变量num就加一，当变量大于等于n时开始输出，大于m时停止输出。<br>3变量num-n+1就是从n开始第几个素数，每当此数字为十的倍数时，就换行。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
int isPrime(int n){
if(n==1)
return 0;
if(n==2)
return 1;
if(n%2==0){
    return 0;
}
for(int i=3;i&lt;sqrt(n+1);i+=2){
    if(n%i==0){
        return 0;
    }
}
return 1;
}
int main(void){
int n,m;
scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
int num=0;
for(int i=2;i&lt;=1000000;i++){
    if(isPrime(i)){
        num++;
        if(num&gt;m){
            break;
        }
        if(num&gt;=n){
            if((num-n+1)%10==0){
            printf(&quot;%d\n&quot;,i);
            continue;
        }
        if(num!=m) 
            printf(&quot;%d &quot;,i);
        else
            printf(&quot;%d&quot;,i);
        } 
    }
}
return 0;
}</code></pre><p>###注意：此算法还可以在进一步优化，这里就不加赘述了。</p>
]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1015</title>
    <url>/2019/09/18/PTA-Basic-1015/</url>
    <content><![CDATA[<p>##1015 德才论</p>
<p>宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”</p>
<p>现给出一批考生的德才分数，请根据司马光的理论给出录取排名。</p>
<p>输入格式：<br>输入第一行给出 3 个正整数，分别为：N（≤10<br>​5<br>​​ ），即考生总数；L（≥60），为录取最低分数线，即德分和才分均不低于 L 的考生才有资格被考虑录取；H（&lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 L 的考生也按总分排序，但排在第三类考生之后。</p>
<p>随后 N 行，每行给出一位考生的信息，包括：准考证号 德分 才分，其中准考证号为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。</p>
<p>输出格式：<br>输出第一行首先给出达到最低分数线的考生人数 M，随后 M 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。</p>
<p>输入样例：</p>
<pre><code>14 60 80
10000001 64 90
10000002 90 60
10000011 85 80
10000003 85 80
10000004 80 85
10000005 82 77
10000006 83 76
10000007 90 78
10000008 75 79
10000009 59 90
10000010 88 45
10000012 80 100
10000013 90 99
10000014 66 60</code></pre><p>输出样例：<br>    12<br>    10000013 90 99<br>    10000012 80 100<br>    10000003 85 80<br>    10000011 85 80<br>    10000004 80 85<br>    10000007 90 78<br>    10000006 83 76<br>    10000005 82 77<br>    10000002 90 60<br>    10000014 66 60<br>    10000008 75 79<br>    10000001 64 90</p>
<p>分析：</p>
<pre><code>输入：
第一行：学生数 最低分 优秀线
第二行：学生id 学生道德分 学生专业分。
.....

处理:
定义一个学生结构包括id score1 score2 sum(分数和)
在输入时进行分析符合条件的就存储到相应等级的学生数组。

对每个等级的学生数组进行快排。

输出：
遍历每个等级数组并输出。</code></pre><p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
typedef struct student{
    int id;
    int score_psy;
    int score_pro;
    int sum;
}student;
int compare(const void *a,const void *b){
    student stu1=*((student *)a);
    student stu2=*((student *)b);
    if(stu1.sum&gt;stu2.sum){
        return -1;
    }
    if(stu1.sum&lt;stu2.sum){
        return 1;
    }else{
        if(stu1.score_psy&gt;stu2.score_psy){
            return -1;
        }else if(stu1.score_psy&lt;stu2.score_psy){
            return 1;
        }else{
            if(stu1.id&gt;stu2.id){
                return 1;
            }
            return -1;
        }
    }
}
int main(void){
    int id;
    int score_pro;
    int score_psy;
    int num,s1,s2;
    scanf(&quot;%d %d %d&quot;,&amp;num,&amp;s1,&amp;s2);
    struct student students1[num],students2[num],students3[num],students4[num];
    int n1=0,n2=0,n3=0,n4=0;
    int i=0;
    while(num--){
        scanf(&quot;%d %d %d&quot;,&amp;id,&amp;score_psy,&amp;score_pro);
        if(score_pro&gt;=s1&amp;&amp;score_psy&gt;=s1){
            i++;
            if(score_psy&gt;=s2&amp;&amp;score_pro&gt;=s2){
            students1[n1].id=id;
            students1[n1].score_pro=score_pro;
            students1[n1].score_psy=score_psy;
            students1[n1].sum=score_pro+score_psy;
            n1++;
            }else if(score_pro &lt; s2 &amp;&amp; score_psy &gt;= s2){
            students2[n2].id=id;
            students2[n2].score_pro=score_pro;
            students2[n2].score_psy=score_psy;
            students2[n2].sum=score_pro+score_psy;
            n2++;
            }else if(score_pro &lt; s2 &amp;&amp; score_psy &lt; s2 &amp;&amp;score_psy&gt;=score_pro){
            students3[n3].id=id;
            students3[n3].score_pro=score_pro;
            students3[n3].score_psy=score_psy;
            students3[n3].sum=score_pro+score_psy;
            n3++;
            }else{
            students4[n4].id=id;
            students4[n4].score_pro=score_pro;
            students4[n4].score_psy=score_psy;
            students4[n4].sum=score_pro+score_psy;
            n4++; 
            }
        }
    }
    printf(&quot;%d\n&quot;,i);
    qsort(students1,n1,sizeof(student),compare);
    qsort(students2,n2,sizeof(student),compare);
    qsort(students3,n3,sizeof(student),compare);
    qsort(students4,n4,sizeof(student),compare);
    for(int j=0;j&lt;n1;j++){
        printf(&quot;%d %d %d\n&quot;,students1[j].id,students1[j].score_psy,students1[j].score_pro);
    }
    for(int j=0;j&lt;n2;j++){
        printf(&quot;%d %d %d\n&quot;,students2[j].id,students2[j].score_psy,students2[j].score_pro);
    }
    for(int j=0;j&lt;n3;j++){
        printf(&quot;%d %d %d\n&quot;,students3[j].id,students3[j].score_psy,students3[j].score_pro);
    }
    for(int j=0;j&lt;n4;j++){
        printf(&quot;%d %d %d\n&quot;,students4[j].id,students4[j].score_psy,students4[j].score_pro);
    }
    return 0;
}</code></pre><p>####注意：排序条件：先按总分降序，如果总分相同，就按道德分数降序，如果还相等就按学号升序排。</p>
]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1016</title>
    <url>/2019/09/18/PTA-Basic-1016/</url>
    <content><![CDATA[<p>正整数 A 的“D<br>​A<br>​​ （为 1 位整数）部分”定义为由 A 中所有 D<br>​A<br>​​  组成的新整数 P<br>​A<br>​​ 。例如：给定 A=3862767，D<br>​A<br>​​ =6，则 A 的“6 部分”P<br>​A<br>​​  是 66，因为 A 中有 2 个 6。</p>
<p>现给定 A、D<br>​A<br>​​ 、B、D<br>​B<br>​​ ，请编写程序计算 P<br>​A<br>​​ +P<br>​B<br>​​ 。</p>
<p>输入格式：<br>输入在一行中依次给出 A、D<br>​A<br>​​ 、B、D<br>​B<br>​​ ，中间以空格分隔，其中 0&lt;A,B&lt;10<br>​10<br>​​ 。</p>
<p>输出格式：</p>
<p>在一行中输出 P<br>​A<br>​​ +P<br>​B<br>​​  的值。</p>
<p>输入样例 1：</p>
<pre><code>3862767 6 13530293 3</code></pre><p>输出样例 1：</p>
<pre><code>399</code></pre><p>输入样例 2：</p>
<pre><code>3862767 1 13530293 8</code></pre><p>输出样例 2：</p>
<pre><code>0</code></pre><p>分析：</p>
<p>输入：数字1 包含的数1 数字2 包含的数2；<br>处理：<br>对数字1不断取余数，判断是否等于包含的数字1，是的话就在和基础上*10+包含的数字一。<br>对数字2的处理同1；<br>输出：<br>输出上述两个操作过后得到的两个数字的和。</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int num1,num2;
    int d1,d2;
    int sum1=0,sum2=0;
    scanf(&quot;%d %d %d %d&quot;,&amp;num1,&amp;d1,&amp;num2,&amp;d2);
    while(num1){
        int n=num1%10;
        num1=num1/10;
        if(n==d1){
            sum1=sum1*10+d1;
        }
    }
    while(num2){
        int n=num2%10;
        num2=num2/10;
        if(n==d2){
            sum2=sum2*10+d2;
        }
    }
    printf(&quot;%d&quot;,sum1+sum2);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1017</title>
    <url>/2019/09/22/PTA-Basic-1017/</url>
    <content><![CDATA[<p>题目：</p>
<p>本题要求计算 A/B，其中 A 是不超过 1000 位的正整数，B 是 1 位正整数。你需要输出商数 Q 和余数 R，使得 A=B×Q+R 成立。</p>
<p>输入格式：</p>
<pre><code>输入在一行中依次给出 A 和 B，中间以 1 空格分隔。</code></pre><p>输出格式：</p>
<pre><code>在一行中依次输出 Q 和 R，中间以 1 空格分隔。</code></pre><p>输入样例：</p>
<pre><code>123456789050987654321 7</code></pre><p>输出样例：</p>
<pre><code>17636684150141093474 3</code></pre><p>分析：<br>输入：除数为数字，而被除数因为输入的不超过1000位，所以只能用字符串来存储，也就是说这题不能用除法来计算了，只能用字符串模拟除法的原理。</p>
<p>处理：</p>
<pre><code>从高位到低位每一位对被除数取整，并用余数*10加上后一位继续此
操作，并将整数存入结果的字符数组中去（注意如果第一个字符
为‘0’就不存入结果数组中去，否则就加入到数组中去。）继续此操
作，最后将‘\0’送入结果数组。</code></pre><p>输出：</p>
<pre><code>如果结果数组长度为0说明整数部分为0，则输出 ‘0 余数’，不为
0，就输出‘字符数组，余数’。</code></pre><p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main(void){
    int number2;
    char number1[1000] ;
    scanf(&quot;%s %d&quot;,number1,&amp;number2);
    int n=0;//余数，初始值为0。
    char result[1000];
    int j=0;
    int i=0;
    while(i&lt;strlen(number1)){
        n=n*10+number1[i]-&apos;0&apos;;//上一位的余数*10加上此位置的数值
        if(j==0&amp;&amp;n/number2==0)
            ;
        else
            result[j++]=n/number2+&apos;0&apos;;//务必要加上‘0’
        n=n%number2;
        i++;
    }
    result[j]=&apos;\0&apos;;//在数组的末尾加上&apos;\0&apos;,这样在输出的时候才会正常结束。
    if(strlen(result)==0){
        printf(&quot;%s %d&quot;,&quot;0&quot;,n);
    } else{
        printf(&quot;%s %d&quot;,result,n);
}
    return 0;
    }</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1010</title>
    <url>/2019/09/17/PTA-Basic-1010/</url>
    <content><![CDATA[<p>设计函数求一元多项式的导数。（注：x<br>​n<br>​​ （n为整数）的一阶导数为nx<br>​n−1<br>​​ 。）</p>
<p>输入格式:<br>以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。</p>
<p>输出格式:<br>以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是 0，但是表示为 0 0。</p>
<p>输入样例:</p>
<pre><code>3 4 -5 2 6 1 -2 0</code></pre><p>输出样例:</p>
<pre><code>12 3 -10 1 6 0</code></pre><p>分析：</p>
<p>一元多项式条件：系数不为0，指数为大于-1的整数即（指数&gt;=0）;</p>
<p>输入：先输入一个系数再输入一个指数，依此重复，指数递减。</p>
<p>输出：格式见题目，输出求一次导后的的多项式对应的系数与指数。</p>
<p>（注意： “零多项式”，最高项指数为0，但是表示为 0 0，除此以外，只要指数不为0，系数为不为无所谓，也要输出。百度解释0多项式就是0）</p>
<p>因为系数一定不为0，所以如果结果中有“零多项式”，那么一定是输入时的指数为0.一旦指数为0，后面就不会再有输入了。</p>
<p>思路：</p>
<p>1读取一对数字再读一个字符。</p>
<p>2如果指数为0就可以判断后面没有输入了。</p>
<p>3不为0就输出对应求导后的数值，并标记一下此多项式不是“0多项式”。</p>
<p>4如果不是0多项式，就不用输出“0 0”了，如果那么前面一定没有输出，那么就要输出此。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
int n,m;
int flag=0;
char ch;
while(1){
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    ch=getchar();
    if(m!=0){
        if(flag)//此处用于判断是否为第一个输出，是就不用输出空格。
            printf(&quot; &quot;);
        printf(&quot;%d %d&quot;,n*m,m-1);
        flag=1;
    }
    if(ch==&apos;\n&apos;){
        break;
    }
}
if(!flag){
    printf(&quot;0 0&quot;);
}
 return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1018</title>
    <url>/2019/09/22/PTA-Basic-1018/</url>
    <content><![CDATA[<p>题目：</p>
<p>大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示：</p>
<p><img src="https://images.ptausercontent.com/724da598-b37f-4f1f-99b4-71459654ce3a.jpg" alt="剪刀石头布"><br>现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。</p>
<p>输入格式：<br>输入第 1 行给出正整数 N（≤10<br>​5<br>​​ ），即双方交锋的次数。随后 N 行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C 代表“锤子”、J 代表“剪刀”、B 代表“布”，第 1 个字母代表甲方，第 2 个代表乙方，中间有 1 个空格。</p>
<p>输出格式：<br>输出第 1、2 行分别给出甲、乙的胜、平、负次数，数字间以 1 个空格分隔。第 3 行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有 1 个空格。如果解不唯一，则输出按字母序最小的解。</p>
<p>输入样例：</p>
<pre><code>10
C J
J B
C B
B B
B C
C C
C B
J B
B C
J J</code></pre><p>输出样例：</p>
<pre><code>5 3 2
2 3 5
B B</code></pre><p>分析：</p>
<pre><code>输入：第一行各处要输入的次数，以下接着放置n行的数据。

处理：
定义两个二维整型数组（第一行存储字符，第二行存储对应的数目，以字符‘0’为起点每符合一个就再对应的第二行加一）存储字符对应的Ascall码值（为什么不用字符型？能因为字符型数组的如果加的范围超出字符型就会报错）定义两个变量用来存储甲胜利的次数，与平局的次数。

输出：最后遍历两个二维数组找出字符数最大的下标并记录。</code></pre><p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int time;
    scanf(&quot;%d&quot;,&amp;time);
    int A[2][3]={{'B','C','J'},{0,0,0}};//第一层代表可以出的手势，第二层代表此手势获胜的次数。
    int B[2][3]={{'B','C','J'},{0,0,0}};
    char a,b;
    int number=time;
    int N=0,M=0;
    while(time--){
        getchar();
        scanf(&quot;%c %c&quot;,&amp;a,&amp;b);
        if((a==&apos;C&apos;&amp;&amp;b==&apos;J&apos;)||(a==&apos;J&apos;&amp;&amp;b==&apos;B&apos;)||(a==&apos;B&apos;&amp;&amp;b==&apos;C&apos;)){
            N++;
            switch(a){
                case &apos;B&apos;:  A[1][0]=A[1][0]+1;break;
                case &apos;C&apos;:  A[1][1]=A[1][1]+1;break;
                case &apos;J&apos;:  A[1][2]=A[1][2]+1;break;
            }
        }else if((b==&apos;C&apos;&amp;&amp;a==&apos;J&apos;)||(b==&apos;J&apos;&amp;&amp;a==&apos;B&apos;)||(b==&apos;B&apos;&amp;&amp;a==&apos;C&apos;)){
            M++;
            switch(b){
                case &apos;B&apos;:  B[1][0]=B[1][0]+1;break;
                case &apos;C&apos;:  B[1][1]=B[1][1]+1;break;
                case &apos;J&apos;:  B[1][2]=B[1][2]+1;break;
            }
        }else{
        }
            }
        printf(&quot;%d %d %d\n&quot;,N,number-N-M,M);
        printf(&quot;%d %d %d\n&quot;,M,number-N-M,N);
        int indexN=0;
        int indexM=0;
        for(int i=1;i&lt;3;i++){
            if((A[1][i]-&apos;0&apos;)&gt;(A[1][indexN]-&apos;0&apos;)){
                indexN=i;
            }
            if((B[1][i]-&apos;0&apos;)&gt;(B[1][indexM]-&apos;0&apos;)){
                indexM=i;
            }
        }
        printf(&quot;%c %c&quot;,A[0][indexN],B[0][indexM]);
        return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1022</title>
    <url>/2019/09/22/PTA-Basic-1022/</url>
    <content><![CDATA[<p>输入两个非负 10 进制整数 A 和 B (≤2<br>​30<br>​​ −1)，输出 A+B 的 D (1&lt;D≤10)进制数。</p>
<p>输入格式：<br>输入在一行中依次给出 3 个整数 A、B 和 D。</p>
<p>输出格式：<br>输出 A+B 的 D 进制数。</p>
<p>输入样例：</p>
<pre><code>123 456 8</code></pre><p>输出样例：</p>
<pre><code>1103</code></pre><p>输入：因为数字范围（&lt;=2^31-1）所以用long类型。<br>处理：先计算两数字和，再对其进行不断的取余，并存入字符数组。最后加入一个‘\0’<br>输出：逆序输出。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main(void){
    int a,b,D;
    scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;D);
    int d=a+b;
    char result[1000];
    int i;
    for(i=0;;i++){
        result[i]=d%D+&apos;0&apos;;
        d=d/D;
        if(d==0){
            break;
        }
    }
    result[++i]=&apos;\0&apos;;//便于计算长度
    for(i=strlen(result)-1;i&gt;-1;i--)
    printf(&quot;%c&quot;,result[i]);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1023</title>
    <url>/2019/09/22/PTA-Basic-1023/</url>
    <content><![CDATA[<p>题目：</p>
<p>给定数字 0-9 各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意 0 不能做首位）。例如：给定两个 0，两个 1，三个 5，一个 8，我们得到的最小的数就是 10015558。</p>
<p>现给定数字，请编写程序输出能够组成的最小的数。</p>
<p>输入格式：</p>
<pre><code>输入在一行中给出 10 个非负整数，顺序表示我们拥有数字 0、数字 
1、……数字 9 的个数。整数间用一个空格分隔。10 个数字的总个数不
超过 50，且至少拥有 1 个非 0 的数字。</code></pre><p>输出格式：</p>
<pre><code>在一行中输出能够组成的最小的数。</code></pre><p>输入样例：</p>
<pre><code>2 2 0 0 0 3 0 0 1 0</code></pre><p>输出样例：</p>
<pre><code>10015558</code></pre><p>输入：</p>
<p>遍历数字，将相应的整型数组加1（下标代表数字，值代表次数）。优先输出0但是首字符不能为0然后依次输出小的。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    static int number[2][10]={{0,1,2,3,4,5,6,7,8,9},{0}};
    int n=0;
    int sum=0;
    char result[1000];
    int i=0;
    for(i=0;i&lt;10;i++){
        scanf(&quot;%d&quot;,&amp;n);
        number[1][i]=n;
        sum+=n;
    }
    i=0;
    while(sum){//当剩余的总个数为0时说明所有数字都用上了。
        if(i==0){
            for(int j=1;j&lt;10;j++){//首先将1-9的数字次数用掉一次，放在字符串首。
                if(number[1][j]!=0){
                    result[i]=number[0][j]+&apos;0&apos;;
                    number[1][j]--;
                    sum--;
                    break;
                }
            }
        }else{
            for(int j=0;j&lt;10;j++){
                if(number[1][j]!=0){
                    result[i]=number[0][j]+&apos;0&apos;;
                    number[1][j]--;
                    sum--;
                    break;
                }
            }
        }
        i++;
    }
    result[i]=&apos;\0&apos;;
    printf(&quot;%s&quot;,result);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1020</title>
    <url>/2019/09/22/PTA-Basic-1020/</url>
    <content><![CDATA[<p>月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。</p>
<p>注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45/2 = 94.5（亿元）。</p>
<p>输入格式：</p>
<pre><code>每个输入包含一个测试用例。每个测试用例先给出一个不超过 
1000 的正整数 N 表示月饼的种类数、以及不超过 500（以万吨为
单位）的正整数 D 表示市场最大需求量。随后一行给出 N 个正数
表示每种月饼的库存量（以万吨为单位）；最后一行给出 N 个正
数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。</code></pre><p>输出格式：</p>
<pre><code>对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到

小数点后 2 位。</code></pre><p>输入样例：</p>
<pre><code>3 20
18 15 10
75 72 45</code></pre><p>输出样例：</p>
<pre><code>94.50</code></pre><p>分析：</p>
<pre><code>定义一个结构体:月饼的库存，与月饼的单价。对月饼数组按单价进行快排（降序）。优先用库存卖出贵的月饼。</code></pre><p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct Moon{
    double store;
    double simple_price;
}Moon;
int compare(const void *a,const void *b){
    if((*(struct Moon *)a).simple_price&gt;(*(struct Moon *)b).simple_price)
        return -1;
    if((*(struct Moon *)a).simple_price&lt;(*(struct Moon *)b).simple_price)
        return 1;
    return 0;
}
int main(void){
    int n;
    double max;
    scanf(&quot;%d %lf&quot;,&amp;n,&amp;max);//输入数目，销量。
    struct Moon moon[n];
    int i=0;
    while(n-i){
        scanf(&quot;%lf&quot;,&amp;moon[i].store);//存入库存。
        i++;
    }
    i=0;
    while(n-i){//故弄玄虚
        double sum_price;
        scanf(&quot;%lf&quot;,&amp;sum_price);
        moon[i].simple_price=sum_price/moon[i].store;//通过单个月饼的库存与总价计算单价存入数组。
        i++;
    }
    qsort(moon,sizeof(moon)/sizeof(Moon),sizeof(Moon),compare);//降序排列月饼有限卖出贵的。
    double sum=0;
    for(i=0;i&lt;n;i++){
        if(moon[i].store&gt;=max){
            sum=sum+moon[i].simple_price*max;
            max=0;
            break;
        }else{
            sum+=moon[i].simple_price*moon[i].store;
            max=max-moon[i].store;
        }
        if((max-0)&lt;0.01){//如果剩余销量几乎为0跳出循环。
            break;
        }
    }
    printf(&quot;%.2f&quot;,sum);//保留两位小数。
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1021</title>
    <url>/2019/09/22/PTA-Basic-1021/</url>
    <content><![CDATA[<p>题目：</p>
<p>给定一个 k 位整数 N=d<br>​k−1<br>​​ 10<br>​k−1<br>​​ +⋯+d<br>​1<br>​​ 10<br>​1<br>​​ +d<br>​0<br>​​  (0≤d<br>​i<br>​​ ≤9, i=0,⋯,k−1, d<br>​k−1<br>​​ &gt;0)，请编写程序统计每种不同的个位数字出现的次数。例如：给定 N=100311，则有 2 个 0，3 个 1，和 1 个 3。</p>
<p>输入格式：<br>每个输入包含 1 个测试用例，即一个不超过 1000 位的正整数 N。</p>
<p>输出格式：<br>对 N 中每一种不同的个位数字，以 D:M 的格式在一行中输出该位数字 D 及其在 N 中出现的次数 M。要求按 D 的升序输出。</p>
<p>输入样例：</p>
<pre><code>100311</code></pre><p>输出样例：</p>
<pre><code>0:2
1:3
3:1</code></pre><p>分析：<br>输入：因为数字的长度不定，所以用字符数组存储。<br>处理：定义一个二维数组，第一行存储0-9，第二存储出现的次数（初始化为0）。遍历字符数组对应数字加1即可。<br>输出：一行一个，输出出现次数不为0的数字以及次数。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main(void){
    char n[1000];
    scanf(&quot;%s&quot;,&amp;n);
    int number[10]={0};
    for(int i=0;i&lt;strlen(n);i++){
        number[n[i]-&apos;0&apos;]++;
    }
   for(int j=0;j&lt;10;j++){
            if(number[j]!=0){
                printf(&quot;%d:%d\n&quot;,j,number[j]);
            }
        }
        return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1019</title>
    <url>/2019/09/22/PTA-Basic-1019/</url>
    <content><![CDATA[<p>题目：</p>
<p>给定任一个各位数字不完全相同的 4 位正整数，如果我们先把 4 个数字按非递增排序，再按非递减排序，然后用第 1 个数字减第 2 个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的 6174，这个神奇的数字也叫 Kaprekar 常数。</p>
<p>例如，我们从6767开始，将得到</p>
<p>7766 - 6677 = 1089<br>9810 - 0189 = 9621<br>9621 - 1269 = 8352<br>8532 - 2358 = 6174<br>7641 - 1467 = 6174<br>… …<br>现给定任意 4 位正整数，请编写程序演示到达黑洞的过程。</p>
<p>输入格式：<br>输入给出一个 (0,10<br>​4<br>​​ ) 区间内的正整数 N。</p>
<p>输出格式：</p>
<pre><code>如果 N 的 4 位数字全相等，则在一行内输出 N - N = 0000；否
则将计算的每一步在一行内输出，直到 6174 作为差出现，输出格式
见样例。注意每个数字按 4 位数格式输出。</code></pre><p>输入样例 1：</p>
<pre><code>6767</code></pre><p>输出样例 1：</p>
<pre><code>7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174</code></pre><p>输入样例 2：</p>
<pre><code>2222</code></pre><p>输出样例 2：</p>
<pre><code>2222 - 2222 = 0000</code></pre><p>分析：</p>
<pre><code>输入：将输入的数字取余存到数组中去然后快排数组，正序逆序生
成两个数字大的减去小的，如果大数与小数相等只输出相减结束循
环或结果为6174结束循环。否则继续循环。</code></pre><p>输出：</p>
<pre><code>计算过程。</code></pre><p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int compare(const void *a,const void *b){
    if(*(int *)a&gt;*(int *)b){
        return -1;
    }else if(*(int *)a&lt;*(int *)b){
        return 1;
    }else{
        return 0;
    }
}
int print(int * p){
    int number1=(*p)*1000+*(p+1)*100+*(p+2)*10+*(p+3);
    int number2=(*p)+*(p+1)*10+*(p+2)*100+*(p+3)*1000;
    int n=number1-number2;
    printf(&quot;%04d - %04d = %04d\n&quot;,number1,number2,n);
    return n;
}
int main(void){
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    int flag=1;
    int result[4];
    while(1){
        for(int i=0;i&lt;4;i++){
        result[i]=n%10;
        n=n/10;
    }
    qsort(result,sizeof(result)/sizeof(int),sizeof(int),compare);
       n=print(result);
       if(n==0||n==6174){
           break;
       }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1027</title>
    <url>/2019/09/19/PTA-Basic-1027/</url>
    <content><![CDATA[<p>本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印</p>
<pre><code>*****
  ***
    *
  ***
*****</code></pre><p>所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。</p>
<p>给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。</p>
<p>输入格式:<br>输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。</p>
<p>输出格式:<br>首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。</p>
<p>输入样例:</p>
<pre><code>19 *</code></pre><p>输出样例:</p>
<pre><code>*****
 ***
  *
 ***
*****
2</code></pre><p>分析：</p>
<p>此题先根据输入的数字计算出一半+1的行数（2<em>n</em>n-1，其中n为行数）然后每一行输出，空格与2*n-1个字符。然后再进行另一半的操作。<br>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int num;
    char ch;
    scanf(&quot;%d %c&quot;,&amp;num,&amp;ch);
    int i=1; 
    for(;;i++){
        if(2*i*i-1&gt;num){//计算一共有多少层。
            break;
        }
    }
    i=i-1;//行数,去掉对称的哪一行。
    num=num-2*i*i+1;//剩余没有用到的个数。
    int n=i;
    int nums=0;
    for(;n&gt;0;n--){//打印一行
        for(int k=0;k&lt;nums;k++){//这一行的空格从0开始计算。
            printf(&quot; &quot;);
        }
        for(int j=0;j&lt;2*n-2;j++){//
            printf(&quot;%c&quot;,ch);
        }
        printf(&quot;%c\n&quot;,ch);
        nums++;
    }
    nums--;
    for(int j=2;j&lt;=i;j++){
        nums--;
        for(int k=0;k&lt;nums;k++){
            printf(&quot; &quot;);
        }
        for(n=0;n&lt;2*j-2;n++){
            printf(&quot;%c&quot;,ch);
        }
        printf(&quot;%c\n&quot;,ch);
    }
    printf(&quot;%d&quot;,num);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1024</title>
    <url>/2019/09/19/PTA-Basic-1024/</url>
    <content><![CDATA[<p>科学计数法是科学家用来表示很大或很小的数字的一种方便的方法，其满足正则表达式 [+-][1-9].[0-9]+E[+-][0-9]+，即数字的整数部分只有 1 位，小数部分至少有 1 位，该数字及其指数部分的正负号即使对正</p>
<p>数也必定明确给出。</p>
<p>现以科学计数法的格式给出实数 A，请编写程序按普通数字表示法输出 A，并保证所有有效位都被保留。</p>
<p>输入格式：</p>
<pre><code>每个输入包含 1 个测试用例，即一个以科学计数法表示的实数 A。该数字的存储长度不超过 9999 字节，且其指数的绝对值不超过 9999。</code></pre><p>输出格式：</p>
<pre><code>对每个测试用例，在一行中按普通数字表示法输出 A，并保证所有有效位都被保留，包括末尾的 0。</code></pre><p>输入样例 1：</p>
<pre><code>+1.23400E-03</code></pre><p>输出样例 1：</p>
<pre><code>0.00123400</code></pre><p>输入样例 2：</p>
<pre><code>-1.2E+10</code></pre><p>输出样例 2：</p>
<pre><code>-12000000000</code></pre><p>分析：</p>
<p>输入： “[+-][1-9].[0-9]+E[+-][0-9]+” 格式如图，数值正负号，一位1到9之间的整数，小数点，小数部分（长度不定且结果要求保留所有小数部分即小数部分有什么样的数字，结果就得含有这个字符串，可以在不同的位置放小数点），指数部分正负号，指数（0-正无穷）。</p>
<p>处理：首先保留一定是位于第一位的正负号，接着将数字部分的小数点去掉，依次存入到字符数组中，当读到‘E’时就可以保留另一个正负号，与其后面数字代表小数点要移动的位数了，</p>
<p>输出：</p>
<pre><code>根据第一个正负号决定是否输出‘-’号。如果移动的位数为0，直接输出元数字字符；否则 根据第二个正负号判断是左移小数点（符号为负号）还是右移（+）</code></pre><p>1左移：</p>
<pre><code>因为位数为0的情况已经讨论过了，所以剩下的都是位数不为0的。
先输出‘0.’在根据要移动的位数，输出位数-1个0，接着输出字符数组。</code></pre><p>2右移：</p>
<pre><code>先输出第一个字符，根据移动位数是否小于剩余字符串的长度决定是否输出小数点，小于：读到指定位数后输出小数点，接着输出剩余字符数组。
大于等于：不输出小数点可能会输出‘0’，输出移动的位数减去除去第一个字符剩余字符数组的长度个‘0’.




#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main(void){
    char str[10003]={&apos;\0&apos;};//存放输入字符数组
    scanf(&quot;%s&quot;,str);
    int flag=1;//用来标识是否已经读取过小数部分了。
    int f1,f2;//用来记住两个正负号
    char result[10000]={&apos;\0&apos;};//用来存放小数部分除去小数点。
    int j=0;
    int num=0;
    for(int i=0;i&lt;strlen(str);i++){
//判断输入的小数部分的符号
        if(i==0){
            switch(str[i]){
                case &apos;+&apos;:f1=1;break;
                case &apos;-&apos;:f1=-1;
            }
            continue;
        }

//表示小数部分已经读取完毕。
        if(str[i]==&apos;E&apos;){
            flag=0;
            continue;
        }

//将小数部分的数字存放到数组中。
        if(flag&amp;&amp;str[i]&lt;=&apos;9&apos;&amp;&amp;str[i]&gt;=&apos;0&apos;){
            result[j++]=str[i];
        }

//判断输入的指数部分的符号
        if(str[i]==&apos;+&apos;||str[i]==&apos;-&apos;){
            switch(str[i]){
                case &apos;+&apos;:f2=1;break;
                case &apos;-&apos;:f2=-1;
            }
            continue;
        }

//计算指数部分要移动的位数
        if(!flag){
            num=num*10+(str[i]-&apos;0&apos;);
        }
    }
//输出符号（+对应‘’负数对应‘-’）
    if(f1&gt;0){
        printf(&quot;&quot;);
    }else{
        printf(&quot;-&quot;);
    }移动位数为0直接输出原小数
//如果
    if(num==0){
            printf(&quot;%c.%s&quot;,result[0],result+1);
        return 0;
        }
//根据指数部分判断移动方向。大于表示右移。
    if(f2&gt;0){//右移时：
        printf(&quot;%c&quot;,result[0]);//首先输出第一个数字
//根据移动位数判断是否要补0
        if(num&lt;strlen(result+1)){//然后根据要移动位数的长度输出0
        for(int j=1;j&lt;=strlen(result+1);j++){
                    if(j&lt;=num){
                    printf(&quot;%c&quot;,result[j]);
                }
                else{
                    printf(&quot;.%s&quot;,result+j);
                    break;//不要忘了跳出去
                }
            }    
        }else{
                printf(&quot;%s&quot;,result+1);
                for(int j=0;j&lt;num-strlen(result+1);j++){
                    printf(&quot;0&quot;);
                }
            }
    }else{//左移第一个肯定为0.几
            printf(&quot;0.&quot;);
            for(int j=1;j&lt;num;j++){
                printf(&quot;0&quot;);
            }
            printf(&quot;%s&quot;,result);
    }
    return 0;
} </code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1029</title>
    <url>/2019/09/20/PTA-Basic-1029/</url>
    <content><![CDATA[<p>旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及实际被输入的文字，请你列出肯定坏掉的那些键。</p>
<p>输入格式：<br>输入在 2 行中分别给出应该输入的文字、以及实际被输入的文字。每段文字是不超过 80 个字符的串，由字母 A-Z（包括大、小写）、数字 0-9、以及下划线 _（代表空格）组成。题目保证 2 个字符串均非空。</p>
<p>输出格式：<br>按照发现顺序，在一行中输出坏掉的键。其中英文字母只输出大写，每个坏键只输出一次。题目保证至少有 1 个坏键。</p>
<p>输入样例：</p>
<pre><code>7_This_is_a_test
_hs_s_a_es</code></pre><p>输出样例：</p>
<pre><code>7TI</code></pre><p>分析：</p>
<p>存储两个字符串，遍历第一个字符串每个字符，如果字符串二中没有，且其对应的大写字母用来存放结果字符的字符数组中也没有就将其存入数组中并数字加1。跳出循环，最后要在末尾加上‘\0’。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;ctype.h&gt;
int main(void){
    char str[100]={&quot;\0&quot;};
    gets(str);
    char str2[100]={&quot;\0&quot;};
    gets(str2);
    int i=0;
    char result[80]={&quot;\0&quot;};
    int num=0;
    while(str[i]!=&apos;\0&apos;){
        if(!strchr(str2,str[i])){
            char ch=toupper(str[i]);
            if(!strchr(result,ch)){
                result[num++]=ch;
            }
        }
        i++;
    }
    result[num]=&apos;\0&apos;;
    printf(&quot;%s&quot;,result);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1025</title>
    <url>/2019/10/16/PTA-Basic-1025/</url>
    <content><![CDATA[<p>题目：</p>
<p>给定一个常数 K 以及一个单链表 L，请编写程序将 L 中每 K 个结点反转。例如：给定 L 为 1→2→3→4→5→6，K 为 3，则输出应该为 3→2→1→6→5→4；如果 K 为 4，则输出应该为 4→3→2→1→5→6，即最后不到 K 个元素不反转。</p>
<p>输入格式：<br>每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1 个结点的地址、结点总个数正整数 N (≤10<br>​5<br>​​ )、以及正整数 K (≤N)，即要求反转的子链结点的个数。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。</p>
<p>接下来有 N 行，每行格式为：</p>
<p>Address Data Next<br>其中 Address 是结点地址，Data 是该结点保存的整数数据，Next 是下一结点的地址。</p>
<p>输出格式：<br>对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。</p>
<p>输入样例：</p>
<pre><code>00100 6 4
00000 4 99999
00100 1 12309
68237 6 -1
33218 3 00000
99999 5 68237
12309 2 33218</code></pre><p>输出样例：</p>
<pre><code>00000 4 33218
33218 3 12309
12309 2 00100
00100 1 99999
99999 5 68237
68237 6 -1</code></pre><p>思路：<br>定义一个结构体存储节点的地址数据下一个地址，定义一个数组存放结点，在定义一个数组存放从第一个结点出发的有序的结点，然后对有序的结点数组进行反转，交换每k个结点，并将每一个结点的下一个地址设置为下一个结点的地址。</p>
<p>坑：可能输入的结点中有些不在链表中应该舍去它们。<br>代码：</p>
<pre><code>/** 
 * (涉及反转，可回顾一下 1008. 数组元素循环右移问题)
 * 1. 通过数组下标来表示地址，便于链接各个节点
 * 2. 考虑存在无效节点的情况
 */
#include &lt;stdio.h&gt;

typedef struct {
    int address;//节点地址
    int data; //整数数据
    int next;//下一节点的地址  
} Node; 
int main() {
    int addr, N, K;//读取首地址，节点数量，反转个数 
    scanf(&quot;%d %d %d&quot;, &amp;addr, &amp;N, &amp;K);
    Node origin[100001], sort[100001];//创建初始单链表,反转后的单链表 
    for (int i = 0; i &lt; N; i++) {//读取节点
        Node temp; 
        scanf(&quot;%d %d %d&quot;, &amp;temp.address, &amp;temp.data, &amp;temp.next);
        origin[temp.address] = temp;
    }
    for (int i = 0; i &lt; N; i++) {//链接节点 //将链表有序存入sorted数组
        sort[i] = origin[addr];
        addr = sort[i].next;//获取下一个节点的地址 
        if (addr == -1) {
            N = i + 1;//可能有无效的节点，需要更新链表中节点的数量 
            break;
        }
    }   
    for (int i = 0; i &lt; N / K; i++) {//反转的次数 
        for (int j = 0; j &lt; K / 2; j++) {//反转 
            Node temp;
            temp = sort[j + i * K];
            sort[j + i * K] = sort[K - 1 - j + i * K];//数组下标确认好 
            sort[K - 1 - j + i * K] = temp;
        }
    }
    for (int i = 0; i &lt; N; i++) {
        if(i != N - 1) {
            sort[i].next = sort[i+1].address;
            printf(&quot;%05d %d %05d\n&quot;, sort[i].address, sort[i].data, sort[i].next);
        } else {
            sort[i].next = -1;
            printf(&quot;%05d %d %d\n&quot;, sort[i].address, sort[i].data, sort[i].next);
        }
    } 
    return 0;
}</code></pre>]]></content>
      <tags>
        <tag>-PTA-Basic</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1030</title>
    <url>/2019/09/20/PTA-Basic-1030/</url>
    <content><![CDATA[<p>给定一个正整数数列，和正整数 p，设这个数列中的最大值是 M，最小值是 m，如果 M≤mp，则称这个数列是完美数列。</p>
<p>现在给定参数 p 和一些正整数，请你从中选择尽可能多的数构成一个完美数列。</p>
<p>输入格式：<br>输入第一行给出两个正整数 N 和 p，其中 N（≤10^5）是输入的正整数的个数，p（≤10^9）是给定的参数。第二行给出 N 个正整数，每个数不超过10^9。</p>
<p>输出格式：<br>在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。</p>
<p>输入样例：</p>
<pre><code>10 8
2 3 20 4 5 1 6 7 8 9</code></pre><p>输出样例：</p>
<pre><code>8</code></pre><p>分析:</p>
<p>将输入的数字存入数组，对数组进行排序。从第i个开始向后找,每当有值与第i个元素之比小于p时，就看看要不要改变sum的值，下一次进行第i+1此比较时，就从i+1+sum处向后遍历。只有这样，其可能有的sum值才可能大于上一次循环得到的sum值。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int compare(const void * a,const void *b){
    long A=*(long *)a;
    long B=*(long *)b;
    if(A&gt;B){
        return 1;
    }else{
        if(A==B){
            return 0; 
        }else{
            return -1;
        }
    }
}
int main(void){
    int N;
    double p;
    scanf(&quot;%ld %lf&quot;,&amp;N,&amp;p);
    long nums[N];
    long x=0;
    int i=0;
    while(N--){
        scanf(&quot;%d&quot;,&amp;x);
        nums[i++]=x;
    } 
    int MAX=0;
    qsort(nums,i,sizeof(long),compare);
        for(int j=0;j&lt;i;j++){//外层遍历，从0开始，
            for(int k=j+MAX;k&lt;i;k++){
                if(nums[k]*1.0/nums[j]&gt;p){
                    break;
                }
                else{
                    if(k-j+1&gt;MAX){
                        MAX=k-j+1;
                    }
                }
            }
        }
    printf(&quot;%d&quot;,MAX);
    return 0;
}</code></pre><p>注意：</p>
<p>此处存储数值建议使用long存储数字，double存储p的值。</p>
]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1026</title>
    <url>/2019/09/19/PTA-Basic-1026/</url>
    <content><![CDATA[<p>要获得一个 C 语言程序的运行时间，常用的方法是调用头文件 time.h，其中提供了 clock() 函数，可以捕捉从程序开始运行到 clock() 被调用时所耗费的时间。这个时间单位是 clock tick，即“时钟打点”。同时还有一个常数 CLK_TCK，给出了机器时钟每秒所走的时钟打点数。于是为了获得一个函数 f 的运行时间，我们只要在调用 f 之前先调用 clock()，获得一个时钟打点数 C1；在 f 执行完成后再调用 clock()，获得另一个时钟打点数 C2；两次获得的时钟打点数之差 (C2-C1) 就是 f 运行所消耗的时钟打点数，再除以常数 CLK_TCK，就得到了以秒为单位的运行时间。</p>
<p>这里不妨简单假设常数 CLK_TCK 为 100。现给定被测函数前后两次获得的时钟打点数，请你给出被测函数运行的时间。</p>
<p>输入格式：<br>输入在一行中顺序给出 2 个整数 C1 和 C2。注意两次获得的时钟打点数肯定不相同，即 C1 &lt; C2，并且取值在 [0,10<br>​7<br>​​ ]。</p>
<p>输出格式：<br>在一行中输出被测函数运行的时间。运行时间必须按照 hh:mm:ss（即2位的 时:分:秒）格式输出；不足 1 秒的时间四舍五入到秒。</p>
<p>输入样例：</p>
<pre><code>123 4577973</code></pre><p>输出样例：</p>
<pre><code>12:42:59</code></pre><p>分析：<br>此题简单不做赘述，注意一点，转型时注意语言自带的转型功能。</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int number1;
    int number2;

    scanf(&quot;%d %d&quot;,&amp;number1,&amp;number2);
    int h=(int)((number2-number1)/360000);
    printf(&quot;%02d:&quot;,h);
    int m=(int)(((number2-number1)/100 -h * 3600)/60);
    printf(&quot;%02d:&quot;,m);</code></pre><p>#####//此处强制转型一定要在除过后就进行否则会导致数字丢失。<br>        int s=(((int)((number2-number1)<em>1.0/100+0.5)-h</em>3600-m*60));<br>        printf(“%02d”,s);<br>        return 0;<br>    }</p>
]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1034</title>
    <url>/2019/09/22/PTA-Basic-1034/</url>
    <content><![CDATA[<p>题目：</p>
<p>本题要求编写程序，计算 2 个有理数的和、差、积、商。</p>
<p>输入格式：<br>输入在一行中按照 a1/b1 a2/b2 的格式给出两个分数形式的有理数，其中分子和分母全是整型范围内的整数，负号只可能出现在分子前，分母不为 0。</p>
<p>输出格式：<br>分别在 4 行中按照 有理数1 运算符 有理数2 = 结果 的格式顺序输出 2 个有理数的和、差、积、商。注意输出的每个有理数必须是该有理数的最简形式 k a/b，其中 k 是整数部分，a/b 是最简分数部分；若为负数，则须加括号；若除法分母为 0，则输出 Inf。题目保证正确的输出中没有超过整型范围的整数。</p>
<p>输入样例 1：</p>
<pre><code>2/3 -4/2</code></pre><p>输出样例 1：</p>
<pre><code>2/3 + (-2) = (-1 1/3)
2/3 - (-2) = 2 2/3
2/3 * (-2) = (-1 1/3)
2/3 / (-2) = (-1/3)</code></pre><p>输入样例 2：</p>
<pre><code>5/3 0/6</code></pre><p>输出样例 2：</p>
<pre><code>1 2/3 + 0 = 1 2/3
1 2/3 - 0 = 1 2/3
1 2/3 * 0 = 0
1 2/3 / 0 = Inf</code></pre><p>分析：</p>
<p>输入：按格式输入两个有理数（分母一定不为0，符号一定在分子上，分子可能为0）.<br>处理：首先定义一个求最大公约数的函数（注意求最大公约数时的算法一定要快，而且注意负数与正数之间也是有最大公约数的，其最大公约数是正数）。然后定义一个符合题目格式的函数用于输出运算后的结果（先对每个结果判断分母是否为0，如果分母为0直接输出Inf,如果不为0，再判断分子是否为0,为0就直接输出0，否则再对其先进行约分{注意一定要定义一个变量保存最大公约数，因为后面再约分时数字已经改变}，然后在根据分子是否时是负数对其进行假分数的相关操作，），再定义一个求加，减，乘，除的函数。注意输入的所有数字一定要是long型的不然会有俩个测试点过不了。<br>输出：。。。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
long gcd(long a,long b)//最大公约数
{
    if(a&lt;0){
        a=-a;
    }
    if(b&lt;0){
        b=-b;
    }
    long n=(a&gt;b?a:b),m=(a&gt;b?b:a);
    long c=a%b;
    while(c){
        a=b;
        b=c;
        c=a%b;
    }
    return b;
}
void form(long a,long b){
    if(b==0){
        printf(&quot;Inf&quot;);
        return;
    }
    if(a==0){
        printf(&quot;0&quot;);
        return;
    }
    long n=gcd(a,b);//对其进行约分
    a=a/n;
    b=b/n;
    if(a&gt;0){
        long k=a/b;
        if(k==0){
            printf(&quot;%ld/%ld&quot;,a,b);
            return;
        }else{
            a=a%b;
            if(a==0){
                printf(&quot;%ld&quot;,k);
                return;
            }else{
                printf(&quot;%ld %ld/%ld&quot;,k,a,b);
                return;
            }
        }
    }else{
        printf(&quot;(&quot;);
        long k=a/b;
        if(k==0){
            printf(&quot;%ld/%ld)&quot;,a,b);
            return;
        }else{
            a=-a;
            a=a%b;
            if(a==0){
                printf(&quot;%ld)&quot;,k);
                return;
            }else{
                printf(&quot;%ld %ld/%ld)&quot;,k,a,b);
                return;
            }
        }
    }
}
void add(long a1,long a2,long b1,long b2){
    long k=a2;
    long c2=b2*a2;
    a1=a1*b2;
    a2=a2*b2;
    b1=b1*a2;
    b2=b2*k;
    long c1=a1+b1;
    form(a1,a2);
    printf(&quot; + &quot;);
    form(b1,b2);
    printf(&quot; = &quot;);
    form(c1,c2);
}
void ride(long a1,long a2,long b1,long b2){
    long c1=a1*b1;
    long c2=a2*b2;
    form(a1,a2);
    printf(&quot; * &quot;);
    form(b1,b2);
    printf(&quot; = &quot;);
    form(c1,c2);
}
void div(long a1,long a2,long b1,long b2){
    long c1=a1*b2;
    long c2=a2*b1;
    if(c2&lt;0){
        c2=-c2;
        c1=-c1;
    }
    form(a1,a2);
    printf(&quot; / &quot;);
    form(b1,b2);
    printf(&quot; = &quot;);
    form(c1,c2);
}

void sub(long a1,long a2,long b1,long b2){
    long k=a2;
    long c2=b2*a2;
    a1=a1*b2;
    b1=b1*a2;
    a2=a2*b2;
    b2=b2*k;
    long c1=a1-b1;
    form(a1,a2);
    printf(&quot; - &quot;);
    form(b1,b2);
    printf(&quot; = &quot;);
    form(c1,c2);
}
int main(void){
    long a1,a2,b1,b2;
    scanf(&quot;%ld/%ld %ld/%ld&quot;,&amp;a1,&amp;a2,&amp;b1,&amp;b2);
    add(a1,a2,b1,b2);
    printf(&quot;\n&quot;);
    sub(a1,a2,b1,b2);
    printf(&quot;\n&quot;);
    ride(a1,a2,b1,b2);
    printf(&quot;\n&quot;);
    div(a1,a2,b1,b2);
    return 0;
} </code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1028</title>
    <url>/2019/09/20/PTA-Basic-1028/</url>
    <content><![CDATA[<p>某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。</p>
<p>这里确保每个输入的日期都是合法的，但不一定是合理的——假设已知镇上没有超过 200 岁的老人，而今天是 2014 年 9 月 6 日，所以超过 200 岁的生日和未出生的生日都是不合理的，应该被过滤掉。</p>
<p>输入格式：<br>输入在第一行给出正整数 N，取值在(0,10^5]；随后 N 行，每行给出 1 个人的姓名（由不超过 5 个英文字母组成的字符串）、以及按 yyyy/mm/dd（即年/月/日）格式给出的生日。题目保证最年长和最年轻的人没有并列。</p>
<p>输出格式：<br>在一行中顺序输出有效生日的个数、最年长人和最年轻人的姓名，其间以空格分隔。</p>
<p>输入样例：</p>
<pre><code>5
John 2001/05/12
Tom 1814/09/06
Ann 2121/01/30
James 1814/09/05
Steve 1967/11/20</code></pre><p>输出样例：</p>
<pre><code>3 Tom John</code></pre><p>分析：</p>
<p>定义一个结构体，首先日期一定都是合法的，但是不一定合理。定义一个在<br>最早的可能的年份出生的人，与今天出生的人，然后输入的每个人的数据与这两个人对比，合格的就存入person数组中。然后对此数组进行快排，输出第一个元素，与最后一个元素。注意：当没有人时，只输出一个0.</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
typedef struct person{
    char name[6];
    int birthyear;
    int birthmonth;
    int birthday;
}person;
int compare(const void * a,const void * b){
    person A=*(person *)a;
    person B=*(person *)b;
    if(A.birthyear&gt;B.birthyear){
        return 1;
    }else if(A.birthyear&lt;B.birthyear){
        return -1;
    }else{
        if(A.birthmonth&gt;B.birthmonth){
            return 1;
        }else if(A.birthmonth&lt;B.birthmonth){
            return -1;
        }else{
                if(A.birthday&gt;B.birthday){
                return 1;
            }else if(A.birthday&lt;B.birthday){
                return -1;
            }else{
                return 0;
            }
        }
    }
}
int main(void){
    long num;
    scanf(&quot;%ld&quot;,&amp;num);
    long i=0;
    person persons[num],oldperson,p,lastperson;  
    oldperson.birthyear=1814;
    oldperson.birthmonth=9;
    oldperson.birthday=6;
    lastperson.birthyear=2014;
    lastperson.birthmonth=9;
    lastperson.birthday=7;
    while(num--){
        scanf(&quot;%s %d/%d/%d&quot;,p.name,&amp;p.birthyear,&amp;p.birthmonth,&amp;p.birthday);
        if(compare(&amp;p,&amp;oldperson)&gt;=0 &amp;&amp; compare(&amp;p,&amp;lastperson)&lt;0){
            strcpy(persons[i].name,p.name);
            persons[i].birthyear=p.birthyear;
            persons[i].birthmonth=p.birthmonth;
            persons[i].birthday=p.birthday;
            i++;
        }
    }
    qsort(persons,i,sizeof(person),compare);
    if(i!=0)
    printf(&quot;%d %s %s&quot;,i,persons[0].name,persons[i-1].name);
    else{
        printf(&quot;0&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1031</title>
    <url>/2019/09/22/PTA-Basic-1031/</url>
    <content><![CDATA[<p>题目：<br>一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下：</p>
<p>首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值Z；最后按照以下关系对应Z值与校验码M的值：</p>
<p>Z：0 1 2 3 4 5 6 7 8 9 10<br>M：1 0 X 9 8 7 6 5 4 3 2<br>现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。</p>
<p>输入格式：<br>输入第一行给出正整数N（≤100）是输入的身份证号码的个数。随后N行，每行给出1个18位身份证号码。</p>
<p>输出格式：<br>按照输入的顺序每行输出1个有问题的身份证号码。这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常，则输出All passed。</p>
<p>输入样例1：</p>
<pre><code>4
320124198808240056
12010X198901011234
110108196711301866
37070419881216001X</code></pre><p>输出样例1：</p>
<pre><code>12010X198901011234
110108196711301866
37070419881216001X</code></pre><p>输入样例2：</p>
<pre><code>2
320124198808240056
110108196711301862</code></pre><p>输出样例2：</p>
<pre><code>All passed</code></pre><p>分析：<br>输入:第一行给出要输入的身份证的个数。<br>以下输入n行身份证信息。<br>处理：<br>定义一个判断身份证是否合格的函数，判断每一个输入进的身份证是否合格，不合格的存入二维数组，并且数目加1用一个二维字符数组存储不符合条件的身份证号。<br>身份证处理函数：首先检验前17个字符是否都是数字范围内的，然后用前十七个字符分别减去‘0’然后加到总和上去，然后用总和对11取余数，根据对应的余数找到对应的检验码。<br>输出：<br>如果全部合格输出:All passed<br>否则输出不合格的身份证号一行一个。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int check(char * a){
    int i=0;
    for(;i&lt;17;i++){
        if(!(a[i]&lt;=&apos;9&apos;&amp;&amp;a[i]&gt;=&apos;0&apos;)){
            break;
        }
    }
    if(i&lt;17){
        return 0;
    }
    int sum=0;
    sum=(a[0]-&apos;0&apos;)*7+(a[1]-&apos;0&apos;)*9+(a[2]-&apos;0&apos;)*10+(a[3]-&apos;0&apos;)*5+(a[4]-&apos;0&apos;)*8+
    (a[5]-&apos;0&apos;)*4+(a[6]-&apos;0&apos;)*2+(a[7]-&apos;0&apos;)*1+(a[8]-&apos;0&apos;)*6+(a[9]-&apos;0&apos;)*3+
    (a[10]-&apos;0&apos;)*7+(a[11]-&apos;0&apos;)*9+(a[12]-&apos;0&apos;)*10+(a[13]-&apos;0&apos;)*5+(a[14]-&apos;0&apos;)*8+
    (a[15]-&apos;0&apos;)*4+(a[16]-&apos;0&apos;)*2;
    sum=sum%11;
    int flag=0;
    switch(sum){
        case 0:flag=(a[17]==&apos;1&apos;);break;
        case 1:flag=(a[17]==&apos;0&apos;);break;
        case 2:flag=(a[17]==&apos;X&apos;);break;
        case 3:flag=(a[17]==&apos;9&apos;);break;
        case 4:flag=(a[17]==&apos;8&apos;);break;
        case 5:flag=(a[17]==&apos;7&apos;);break;
        case 6:flag=(a[17]==&apos;6&apos;);break;
        case 7:flag=(a[17]==&apos;5&apos;);break;
        case 8:flag=(a[17]==&apos;4&apos;);break;
        case 9:flag=(a[17]==&apos;3&apos;);break;
        case 10:flag=(a[17]==&apos;2&apos;);break;
    }
     return flag;
}
int main(void){
    int num;
    scanf(&quot;%d&quot;,&amp;num);
    char res[num][19];
    int i=0;
    char ch[19];
    while(num--){
        scanf(&quot;%s&quot;,ch);
        if(!check(ch)){
            strcpy(res[i++],ch);
        }
    }
    if(i==0){
        printf(&quot;All passed&quot;); 
    }else{
        for(int j=0;j&lt;i;j++){
            printf(&quot;%s\n&quot;,res[j]);
        }
    }
    return 0;
} </code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1037</title>
    <url>/2019/09/23/PTA-Basic-1037/</url>
    <content><![CDATA[<p>题目：</p>
<p>如果你是哈利·波特迷，你会知道魔法世界有它自己的货币系统 —— 就如海格告诉哈利的：“十七个银西可(Sickle)兑一个加隆(Galleon)，二十九个纳特(Knut)兑一个西可，很容易。”现在，给定哈利应付的价钱 P 和他实付的钱 A，你的任务是写一个程序来计算他应该被找的零钱。</p>
<p>输入格式：<br>输入在 1 行中分别给出 P 和 A，格式为 Galleon.Sickle.Knut，其间用 1 个空格分隔。这里 Galleon 是 [0, 10<br>​^7<br>​​ ] 区间内的整数，Sickle 是 [0, 17) 区间内的整数，Knut 是 [0, 29) 区间内的整数。</p>
<p>输出格式：</p>
<p>在一行中用与输入同样的格式输出哈利应该被找的零钱。如果他没带够钱，那么输出的应该是负数。</p>
<p>输入样例 1：</p>
<pre><code>10.16.27 14.1.28</code></pre><p>输出样例 1：</p>
<pre><code>3.2.1</code></pre><p>输入样例 2：</p>
<pre><code>14.1.28 10.16.27</code></pre><p>输出样例 2：</p>
<pre><code>-3.2.1</code></pre><p>分析：</p>
<p>输入:Galleon1.Sickle1.Knut1 Galleon2.Sickle2.Knut2<br>处理：先将每个分别化为最小单位的货币和，然后用实收减去应收，所得结果即为多的或少的。然后对此进行单位换算，先化为高位的，再化为中位的，剩下的就是最低单位的数字。<br>输出：Galleon3.Sickle3.Knut3</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    long p[3]={0};
    long a[3]={0};
    scanf(&quot;%d.%d.%d %d.%d.%d&quot;,&amp;p[0],&amp;p[1],&amp;p[2],&amp;a[0],&amp;a[1],&amp;a[2]);
    long c[3]={0};
    long x=a[0]*29*17+a[1]*29+a[2];
    long y=p[0]*29*17+p[1]*29+p[2];
    x=x-y;
    c[0]=(x)/(29*17);
    c[1]=(x-c[0]*29*17)/29;
    c[2]=(x-c[0]*29*17-c[1]*29);
//此处的一个坑就是当欠钱时值输出一个负号。
    printf(&quot;%d.%d.%d&quot;,c[0],(c[1]&gt;0?c[1]:-c[1]),(c[2]&gt;0?c[2]:-c[2]));//如果第一是负数时后面的就不用输出负号了。
    return 0;
    }</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1033</title>
    <url>/2019/09/22/PTA-Basic-1033/</url>
    <content><![CDATA[<p>题目：</p>
<p>旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及坏掉的那些键，打出的结果文字会是怎样？</p>
<p>输入格式：<br>输入在 2 行中分别给出坏掉的那些键、以及应该输入的文字。其中对应英文字母的坏键以大写给出；每段文字是不超过 10<br>^5<br>​​  个字符的串。可用的字符包括字母 [a-z, A-Z]、数字 0-9、以及下划线 _（代表空格）、,、.、-、+（代表上档键）。题目保证第 2 行输入的文字串非空。</p>
<p>注意：如果上档键坏掉了，那么大写的英文字母无法被打出。</p>
<p>输出格式：<br>在一行中输出能够被打出的结果文字。如果没有一个字符能被打出，则输出空行。</p>
<p>输入样例：</p>
<pre><code>7+IE.
7_This_is_a_test.</code></pre><p>输出样例：</p>
<pre><code>_hs_s_a_tst</code></pre><p>分析:</p>
<pre><code>输入：第一行输入坏掉的字符（如果有字母则对应
的字母不能出现，如果有下划线则不下划线，有加号大写字母甭能出现）</code></pre><hr>
<pre><code>处理：
先定义两个尽可能大的字符数组一个用来存储坏键，一个用来存储要输入的字符串。

定义一个删除字符的函数，然后遍历第一个字符串分别在第二个字符串中删去相应的字符。

输出：处理后的字符串如果字符串长度为0则输出空行。</code></pre><p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;ctype.h&gt;
char * Remove(char*a,char b){
    char * src,*dst;
    src=a;
    dst=a;
    while(*src!=&apos;\0&apos;){
        *dst=*src;
        src++;
        if(*dst!=b){
            dst++;
        }
    }
    *dst=&apos;\0&apos;;
    return a;
}
int main(void){
    char a[110000]={},b[110000]={};
    gets(a);
    gets(b);
    int i=0;
    while(a[i]!=&apos;\0&apos;){
                if(a[i]!=&apos;+&apos;){//shang dang jian mei hua
                            if(a[i]&gt;=&apos;A&apos;&amp;&amp;a[i]&lt;=&apos;Z&apos;){
                                Remove(b,tolower(a[i]));
                                Remove(b,toupper(a[i]));
                            }else{
                                Remove(b,a[i]);
                            }
                }else{
                    for(char j=&apos;A&apos;;j&lt;(&apos;Z&apos;+1);j++){
                        Remove(b,j);
                    }
            }
        i++;
    }

    if(strlen(b)!=0){
        printf(&quot;%s&quot;,b);
    }else{
        printf(&quot;\n&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1035</title>
    <url>/2019/10/16/PTA-Basic-1035/</url>
    <content><![CDATA[<p>题目：</p>
<p>根据维基百科的定义：</p>
<p>插入排序是迭代算法，逐一获得输入数据，逐步产生有序的输出序列。每步迭代中，算法从输入序列中取出一元素，将之插入有序序列中正确的位置。如此迭代直到全部元素有序。</p>
<p>归并排序进行如下迭代操作：首先将原始序列看成 N 个只包含 1 个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下 1 个有序的序列。</p>
<p>现给定原始序列和由某排序算法产生的中间序列，请你判断该算法究竟是哪种排序算法？</p>
<p>输入格式：<br>输入在第一行给出正整数 N (≤100)；随后一行给出原始序列的 N 个整数；最后一行给出由某排序算法产生的中间序列。这里假设排序的目标序列是升序。数字间以空格分隔。</p>
<p>输出格式：<br>首先在第 1 行中输出Insertion Sort表示插入排序、或Merge Sort表示归并排序；然后在第 2 行中输出用该排序算法再迭代一轮的结果序列。题目保证每组测试的结果是唯一的。数字间以空格分隔，且行首尾不得有多余空格。</p>
<p>输入样例 1：</p>
<pre><code>10
3 1 2 8 7 5 9 4 6 0
1 2 3 7 8 5 9 4 6 0</code></pre><p>输出样例 1：</p>
<pre><code>Insertion Sort
1 2 3 5 7 8 9 4 6 0</code></pre><p>输入样例 2：</p>
<pre><code>10
3 1 2 8 7 5 9 4 0 6
1 3 2 8 5 7 4 9 0 6</code></pre><p>输出样例 2：</p>
<pre><code>Merge Sort
1 2 3 8 4 5 7 9 0 6</code></pre><p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;

int isinsertion(int n, int num[], int half[]);
int nextmerge(int n, int num[], int half[]);

int comp(const void *a, const void *b)
{
    return *(int *)a - *(int *)b;
}

int main()
{
    int n, num[100], half[100];
    int i;
    scanf(&quot;%d&quot;, &amp;n);
    for(i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;num[i]);
    for(i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;half[i]);

    if(isinsertion(n, num, half)) nextmerge(n, num, half);。//既然不是插入排序，那就一定是归并排序，直接进行下一次排序。

    for(i = 0; i &lt; n; i++){//另一种解决末尾不能有空格的方式。
        printf(&quot;%d%c&quot;, num[i], i == n - 1 ? &apos;\n&apos; : &apos; &apos;);
    }
    return 0;
}

int isinsertion(int n, int num[], int half[])
{
    int i, lenth;
    for(i = 0; i &lt; n - 1 &amp;&amp; half[i] &lt;= half[i + 1]; i++){//先判段排好序的结果是否符合插入排序的判断条件。即开始到某一下标处都是有序的其他的与元素组一样排列。不用担心length处的数字与后一个相同，题目保证了结果唯一，所以你直接取相同数字的后一个。
        continue;
    }
    for(i++, lenth = i; i &lt; n &amp;&amp; half[i] == num[i]; i++){//length代表目前有序的最后一个。然后i继续遍历判断与数组是否相等。
        continue;
    }
    if(i &lt; n)//不是的情况下。
        return 1;
    printf(&quot;Insertion Sort\n&quot;);//此处已经可以判断是插入排序了，因此只需在进行一次排序就可以了。
    lenth++;
    qsort(num, lenth, sizeof(int), comp);
    return 0;
}

int nextmerge(int n, int num[], int half[])
{
    int i, j, lenth;
    printf(&quot;Merge Sort\n&quot;);
    for(lenth = 1, i = 0; i &lt; n &amp;&amp; lenth &lt;= n; lenth *=2){//分n/2次，第一次排序每一个，第二次每两个拍一次顺序，只需要调用qsort函数并改变数组的起始位置就可以了。每次的长度为上一次的2倍
        for(i = 0; i &lt; n &amp;&amp; num[i] == half[i]; i++) ;//判断是否与结果数组完全相同，如果已经完全相同了就没有必要进行下一次排序了。即i已经不符合条件了。
        for(j = 1; j &lt; = n / lenth; j++){//数组依据每一段的长度可以分为n/length段，对每一段排序就饿可以了。
            qsort(num + j * lenth/*每一次排序的起始位置*/, lenth, sizeof(int), comp);
        }
        qsort(num + j * lenth, n % lenth, sizeof(int), comp);//排序剩余的部分数字
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1032</title>
    <url>/2019/09/22/PTA-Basic-1032/</url>
    <content><![CDATA[<p>题目：</p>
<p>为了用事实说明挖掘机技术到底哪家强，PAT 组织了一场挖掘机技能大赛。现请你根据比赛结果统计出技术最强的那个学校。</p>
<p>输入格式：<br>输入在第 1 行给出不超过 10<br>​5<br>​​  的正整数 N，即参赛人数。随后 N 行，每行给出一位参赛者的信息和成绩，包括其所代表的学校的编号（从 1 开始连续编号）、及其比赛成绩（百分制），中间以空格分隔。</p>
<p>输出格式：<br>在一行中给出总得分最高的学校的编号、及其总分，中间以空格分隔。题目保证答案唯一，没有并列。</p>
<p>输入样例：</p>
<pre><code>6
3 65
2 80
1 100
2 70
3 40
3 0</code></pre><p>输出样例：</p>
<pre><code>2 150</code></pre><p>分析：</p>
<p>输入：第一行给出要输入的数目，随后每一行给出一个学校的得分。<br>处理：<br>先定义一个学校编号的数组越大越好（其数组下标就是输入的学校的编号），定义一个得分最大的学校的编号，与对应的分数，然后输入n次一个学校的编号与得分，如果输入的分数加到对应的学校后比当前最高的学校搞，就改变两个量，最后输入结束时就得到了，最大的学校的编号与分数了。<br>输出：学校的编号 学校的总分数。<br>注意：此题如果采用排序的话可能会运行超时。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int schools[100001]={0};
    int max=0;
    int max_school=0;
    int n,a,b;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++){
        scanf(&quot;%d %d&quot;,&amp;a,&amp;b);
        schools[a]=schools[a]+b;
        if(schools[a]&gt;max){
            max=schools[a];
            max_school=a;
        }
    }
    printf(&quot;%d %d&quot;,max_school,max);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1036</title>
    <url>/2019/09/22/PTA-Basic-1036/</url>
    <content><![CDATA[<p>美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。2014 年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！</p>
<p>输入格式：<br>输入在一行中给出正方形边长 N（3≤N≤20）和组成正方形边的某种字符 C，间隔一个空格。</p>
<p>输出格式：<br>输出由给定字符 C 画出的正方形。但是注意到行间距比列间距大，所以为了让结果看上去更像正方形，我们输出的行数实际上是列数的 50%（四舍五入取整）。</p>
<p>输入样例：</p>
<pre><code>10 a</code></pre><p>输出样例：</p>
<pre><code>aaaaaaaaaa
a        a
a        a
a        a
aaaaaaaaaa</code></pre><p>分析：见题目，行数是列数的一半的四舍五入。第一行与最后一行输出n个字符，其他输出2个字符与n-2个空格。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int num;
    char ch;
    scanf(&quot;%d %c&quot;,&amp;num,&amp;ch);
    int lines=(int)((num*1.0/2)+0.5);
    for(int n=0;n&lt;lines;n++){
        if(n==0||n==lines-1){
            for(int i=0;i&lt;num;i++){
                printf(&quot;%c&quot;,ch);
            }
            if(n==0){
                printf(&quot;\n&quot;);
            }
        }else{
            printf(&quot;%c&quot;,ch);
            for(int n=0;n&lt;num-2;n++){
                printf(&quot; &quot;);
            }
            printf(&quot;%c\n&quot;,ch);
        }
    }
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1040</title>
    <url>/2019/09/24/PTA-Basic-1040/</url>
    <content><![CDATA[<p>字符串 APPAPT 中包含了两个单词 PAT，其中第一个 PAT 是第 2 位(P)，第 4 位(A)，第 6 位(T)；第二个 PAT 是第 3 位(P)，第 4 位(A)，第 6 位(T)。</p>
<p>现给定字符串，问一共可以形成多少个 PAT？</p>
<p>输入格式：</p>
<p>输入只有一行，包含一个字符串，长度不超过10^5，只包含 P、A、T 三种字母。</p>
<p>输出格式：</p>
<p>在一行中输出给定字符串中包含多少个 PAT。由于结果可能比较大，只输出对 1000000007 取余数的结果。</p>
<p>输入样例：</p>
<pre><code>APPAPT</code></pre><p>输出样例：</p>
<pre><code>2</code></pre><p>思路：输入一个字符串。<br>处理：定义三个变量，分别用来计算p，pa,pat的总数。<br>从前向后数，计算p的个数，如果遇到a就说明已经有了(已数p的数目)个pa，如果有遇到a,则将已经有的pa数加上已经有的p数（a前有多少个p代表有多少个pa）,如果遇到T就说明有了pa个数个pat,再遇到t时就将已经有的pat个数加上以前有的pa数。<br>输出：输出结果对1000000007 取余的结果。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int p=0,pa=0,pat=0;
    char ch;
    while((ch=getchar())!=&apos;\n&apos;){
    if(ch==&apos;P&apos;)p++;
    if(ch==&apos;A&apos;)pa=pa+p;
    if(ch==&apos;T&apos;)pat=(pat+pa)%1000000007;//为什么在这里要对其取余，而不在输出时？

    /*因为pat存储的就是结果数目，如果在加的过程中超出了范围
    会导致内存溢出，数据就会存储出错，对结果取余也就不对了，
    在求总数的过程中对其进行取余一旦超过1000000007但是其还
    在整型范围内所以一旦超出就对其进行取余。*/
    }
    printf(&quot;%d&quot;,pat);
    return 0;
}</code></pre><p>思路二：<br>思路分析：先数出一共有多少T，然再遍历字符串，遇到一个T就减去一个，遇到一个p就将P的个数加1，遇到一个a就说明后面有剩余T个数个T,那么就有T的个数个pat,每遇到一个A就用已有的pat个数加上后面剩余的T的个数。最后得出总数，同样这里也要取余。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
int main() {
    string s;
    cin &gt;&gt; s;
    int len = s.length(), result = 0, countp = 0, countt = 0;
    //先输出一共有有多少T;
    for (int i = 0; i &lt; len; i++) {
        if (s[i] == &apos;T&apos;)
            countt++;
    }
    for (int i = 0; i &lt; len; i++) {
        if (s[i] == &apos;P&apos;) countp++;
        if (s[i] == &apos;T&apos;) countt--;
        if (s[i] == &apos;A&apos;) result = (result + countp * countt) % 1000000007;
    }
    cout &lt;&lt; result;
    return 0;
}</code></pre><p>参考文章：<br><a href="https://blog.csdn.net/zhanshen112/article/details/83629587">https://blog.csdn.net/zhanshen112/article/details/83629587</a></p>
]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1042</title>
    <url>/2019/09/24/PTA-Basic-1042/</url>
    <content><![CDATA[<p>请编写程序，找出一段给定文字中出现最频繁的那个英文字母。</p>
<p>输入格式：<br>输入在一行中给出一个长度不超过 1000 的字符串。字符串由 ASCII 码表中任意可见字符及空格组成，至少包含 1 个英文字母，以回车结束（回车不算在内）。</p>
<p>输出格式：<br>在一行中输出出现频率最高的那个英文字母及其出现次数，其间以空格分隔。如果有并列，则输出按字母序最小的那个字母。统计时不区分大小写，输出小写字母。</p>
<p>输入样例：</p>
<pre><code>This is a simple TEST.  There ARE numbers and other symbols 1&amp;2&amp;3...........</code></pre><p>输出样例：</p>
<pre><code>e 7</code></pre><p>分析：定义一个26个字母（小写）的整型数组，每次遇到字母（如果大写就将其化为小写）存储到字母-97（‘a’对应的ascall码值）下标的位置。最后遍历数组找出最大数字的下标，并将其转为字符输出。</p>
<p>代码:</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int strs[26]={0};
    char ch;
    while((ch=getchar())!=&apos;\n&apos;){
        if((ch&lt;=&apos;z&apos;&amp;&amp;ch&gt;=&apos;a&apos;)||(ch&gt;=&apos;A&apos;&amp;&amp;ch&lt;=&apos;Z&apos;)){
            if(ch&lt;97){
                ch=ch-&apos;A&apos;+&apos;a&apos;;
            }
            strs[ch-97]++;
        }
    }
    int a=0;
    for(int i=1;i&lt;26;i++){
        if(strs[i]&gt;strs[a]){
            a=i;
        }
    }
    printf(&quot;%c %d&quot;,a+97,strs[a]);
    return 0;
}</code></pre><p>思路二：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;ctype.h&gt;
int map[255]={0};
int main(void){
    int maxNum=0;
    char  maxChar=&apos;a&apos;;
    char ch;
    while((ch=getchar())!=&apos;\n&apos;){
        if((ch&gt;=&apos;a&apos;&amp;&amp;ch&lt;=&apos;z&apos;)||(ch&gt;=&apos;A&apos;&amp;&amp;ch&lt;=&apos;Z&apos;)){
            ch=tolower(ch);
            map[ch]++;
            if(map[ch]&gt;=map[maxChar]){
                if(map[ch]==map[maxChar]){
                    if(maxChar&gt;ch)
                        maxChar=ch;
                }else{
                    maxChar=ch;
                }
            }
        }

    }
    printf(&quot;%c %d&quot;,maxChar,map[maxChar]);
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1039</title>
    <url>/2019/09/23/PTA-Basic-1039/</url>
    <content><![CDATA[<p>题目：</p>
<p>小红想买些珠子做一串自己喜欢的珠串。卖珠子的摊主有很多串五颜六色的珠串，但是不肯把任何一串拆散了卖。于是小红要你帮忙判断一下，某串珠子里是否包含了全部自己想要的珠子？如果是，那么告诉她有多少多余的珠子；如果不是，那么告诉她缺了多少珠子。</p>
<p>为方便起见，我们用[0-9]、[a-z]、[A-Z]范围内的字符来表示颜色。例如在图1中，第3串是小红想做的珠串；那么第1串可以买，因为包含了全部她想要的珠子，还多了8颗不需要的珠子；第2串不能买，因为没有黑色珠子，并且少了一颗红色的珠子。</p>
<p><img src="https://images.ptausercontent.com/b7e2ffa6-8819-436d-ad79-a41263abe914.jpg" alt="串串"></p>
<p>图 1</p>
<p>输入格式：</p>
<pre><code>每个输入包含 1 个测试用例。每个测试用例分别在 2 行中先后给出
摊主的珠串和小红想做的珠串，两串都不超过 1000 个珠子。</code></pre><p>输出格式：</p>
<pre><code>如果可以买，则在一行中输出 Yes 以及有多少多余的珠子；如果不
可以买，则在一行中输出 No 以及缺了多少珠子。其间以 1 个空格
分隔。</code></pre><p>输入样例 1：</p>
<pre><code>ppRYYGrrYBR2258
YrR8RrY</code></pre><p>输出样例 1：</p>
<pre><code>Yes 8</code></pre><p>输入样例 2：</p>
<pre><code>ppRYYGrrYB225
YrR8RrY</code></pre><p>输出样例 2：</p>
<pre><code>No 2</code></pre><p>分析：此题与上一题采用相同的思路，先定义一个整型数组（范围要能把字母与数字的ascall码值包含在内），然后输入字符，如果字符符合条件就将字符对应的ascall码对应的数组下标所对应的数组+1，表示此种字符输入一次。输入要查找的字符串时，字符对应的数目-1.最后遍历数组将所有符数加到一起，所以正数加到一起，负数表示缺少的字符数目，正数表示多余的字符数目，如果有负数优先输出：No 缺少的数目（&gt;0）。反之 就输出Yes 多余的数目。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
        int chars[250]={0};
        char ch;
        while((ch=getchar())!=&apos;\n&apos;){
            if((ch&lt;=&apos;z&apos;&amp;&amp;ch&gt;=&apos;a&apos;)||(ch&lt;=&apos;Z&apos;&amp;&amp;ch&gt;=&apos;A&apos;)||ch&lt;=&apos;9&apos;&amp;&amp;ch&gt;=&apos;0&apos;){
                chars[ch]++;
            }
        }
        while((ch=getchar())!=&apos;\n&apos;){
            if((ch&lt;=&apos;z&apos;&amp;&amp;ch&gt;=&apos;a&apos;)||(ch&lt;=&apos;Z&apos;&amp;&amp;ch&gt;=&apos;A&apos;)||ch&lt;=&apos;9&apos;&amp;&amp;ch&gt;=&apos;0&apos;){
                chars[ch]--;
            }
        }
        int sum1=0;
        int sum2=0;
        int i=0;
        while(i&lt;250){
            if(chars[i]&lt;0){
                sum2+=chars[i];
            }else{
                sum1+=chars[i];
                }
                i++;
        }
        if(sum2&lt;0){
            printf(&quot;No %d&quot;,-sum2);
        }else{
            printf(&quot;Yes %d&quot;,sum1);
            }
        return 0;
    }</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1038</title>
    <url>/2019/09/23/PTA-Basic-1038/</url>
    <content><![CDATA[<p>题目：<br>本题要求读入 N 名学生的成绩，将获得某一给定分数的学生人数输出。</p>
<p>输入格式：<br>输入在第 1 行给出不超过 10<br>​^5<br>​​  的正整数 N，即学生总人数。随后一行给出 N 名学生的百分制整数成绩，中间以空格分隔。最后一行给出要查询的分数个数 K（不超过 N 的正整数），随后是 K 个分数，中间以空格分隔。</p>
<p>输出格式：<br>在一行中按查询顺序给出得分等于指定分数的学生人数，中间以空格分隔，但行末不得有多余空格。</p>
<p>输入样例：</p>
<pre><code>10
60 75 90 55 75 99 82 90 75 50
3 75 90 88</code></pre><p>输出样例：</p>
<pre><code>3 2 0</code></pre><p>分析：</p>
<p>输入：数目 与 得分。<br>处理：此题不好用循环去一个一个遍历，查找比对。<br>因为题目说了数字范围是1-100的整数，所以直接定义一个长度为101的数组，每输入一个分数时，就再分数对应的下标所在的数组存储的数目加1.输入要查找的得分时通过得分直接找到相应的次数，并输出，如果输出最后一个数字时，不用输出空格。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main()
{
    int n,m;
    scanf(&quot;%d&quot;,&amp;n);
    int score1[101]={0};
    int score2;
    while(n--)
    {
        scanf(&quot;%d&quot;,&amp;score2);
        score1[score2]++;
    }
    scanf(&quot;%d&quot;,&amp;m);
    int score3;
    while(m--)
    {
        scanf(&quot;%d&quot;,&amp;score3);
        printf(&quot;%d&quot;,score1[score3]);
        if(m!=0)
            printf(&quot; &quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1045</title>
    <url>/2019/09/25/PTA-Basic-1045/</url>
    <content><![CDATA[<p>著名的快速排序算法里有一个经典的划分过程：我们通常采用某种方法取一个元素作为主元，通过交换，把比主元小的元素放到它的左边，比主元大的元素放到它的右边。 给定划分后的 N 个互不相同的正整数的排列，请问有多少个元素可能是划分前选取的主元？</p>
<p>例如给定 $N = 5$, 排列是1、3、2、4、5。则：</p>
<p>1 的左边没有元素，右边的元素都比它大，所以它可能是主元；<br>尽管 3 的左边元素都比它小，但其右边的 2 比它小，所以它不能是主元；<br>尽管 2 的右边元素都比它大，但其左边的 3 比它大，所以它不能是主元；<br>类似原因，4 和 5 都可能是主元。<br>因此，有 3 个元素可能是主元。</p>
<p>输入格式：<br>输入在第 1 行中给出一个正整数 N（≤10<br>​5<br>​​ ）； 第 2 行是空格分隔的 N 个不同的正整数，每个数不超过 10<br>​9<br>​​ 。</p>
<p>输出格式：<br>在第 1 行中输出有可能是主元的元素个数；在第 2 行中按递增顺序输出这些元素，其间以 1 个空格分隔，行首尾不得有多余空格。</p>
<p>输入样例：<br>5<br>1 3 2 4 5<br>输出样例：<br>3<br>1 4 5</p>
<p>我的思路：<br>使用for循环，从左边开始遍历如果有比它大的就标记它自己与那个数字，但是不跳出循环继续遍历，继续标识不合格的数字，如果一次循环下来没有找到比它大的数字那么说明他是合格的，合格的就存入另外一个数组。如果不是合格的那么后面比它小的都不合格了，所以不用遍历这些，最后最后得出一个主元的递增数列。但是这个方发还是有一个测试点1超时了。我还是可以的能把别人一半运行超时的思路减到一个。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main(void){
    unsigned int num;
    scanf(&quot;%d&quot;,&amp;num);
    int res[num];
    memset(res,0,sizeof(res));

    int  nums[2][num];
    memset(nums,0,sizeof(nums));
    int i=0;
    while(i&lt;num){
        scanf(&quot;%d&quot;,&amp;nums[0][i++]);
    }
    int time=0;
    for(i=0;i&lt;num;i++){
        int key=nums[0][i];
            if(nums[1][i]!=1){
                int j=i+1;
                int flag=0;
                for(;j&lt;num;j++){
                    if(nums[0][j]&lt;key){
                        nums[1][j]=1;
                        nums[1][i]=1;
                        flag=1;
                    }
                }
                if(!flag){
                    res[time]=key;
                    time++;
                }
        }
    }
    printf(&quot;%d\n&quot;,time);
    for(int j=0;j&lt;time;j++){
        if(j==0){
            printf(&quot;%d&quot;,res[j]);
        }else{
            printf(&quot; %d&quot;,res[j]);
        }
    }
    printf(&quot;\n&quot;);
    return 0;
}</code></pre><p>思路二：<br>定义两个数组一个用来存储原数组，另一个用来存储对原数组排序后的数组。<br>遍历原数组，如果对应已经排好序的数组的相同位置也为那么这个数可能为主元（特例：3 2 1，1 2 3）还要保证他是原数组前面最大的哪一个，这又符合这两条件他才是主元，存入数组。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;

int cmp(const void *a, const void *b)
{
  return *((int *)a)-*((int *)b);
}

int main()
{
  int iNum=0;
  scanf(&quot;%d&quot;,&amp;iNum);
  int iData[iNum],iData_s[iNum];
  for(int i=0;i&lt;iNum;i++)
  {
    scanf(&quot;%d&quot;,&amp;iData[i]);
    iData_s[i]=iData[i];
  }
  qsort(iData_s,iNum,sizeof(int),cmp);//快速排序
  int iZY[iNum];
  int iCnt=0,iMax=0;
  for(int i=0;i&lt;iNum;i++)
  {
    if(iMax&lt;iData[i])//iMax就是前i-1个数字中最大的哪一个。
    {
      iMax=iData[i];
      if(iData[i]==iData_s[i])   //如果是前i个最大的数字，且对应排好序的数组数字也是它，那么它就是主元。
      {
        iZY[iCnt++]=iData[i];
      }
    }
  }
  printf(&quot;%d\n&quot;,iCnt);//下面两种输出方法，区别在于icnt=0的情况
  for(int i=0;i&lt;iCnt;i++)
  {
    if(i==0)
    {
      printf(&quot;%d&quot;,iZY[i]);
    }
    else
    {
      printf(&quot; %d&quot;,iZY[i]);
    }
  }
  printf(&quot;\n&quot;);//一个测试点好像有毛病，当主元数目为0时，还要要输出个换行。
 return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1044</title>
    <url>/2019/09/25/PTA-Basic-1044/</url>
    <content><![CDATA[<p>题目：</p>
<p>火星人是以 13 进制计数的：</p>
<p>地球人的 0 被火星人称为 tret。<br>地球人数字 1 到 12 的火星文分别为：jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec。<br>火星人将进位以后的 12 个高位数字分别称为：tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou。<br>例如地球人的数字 29 翻译成火星文就是 hel mar；而火星文 elo nov 对应地球数字 115。为了方便交流，请你编写程序实现地球和火星数字之间的互译。</p>
<p>输入格式：<br>输入第一行给出一个正整数 N（&lt;100），随后 N 行，每行给出一个 [0, 169) 区间内的数字 —— 或者是地球文，或者是火星文。</p>
<p>输出格式：<br>对应输入的每一行，在一行中输出翻译后的另一种语言的数字。</p>
<p>输入样例：</p>
<pre><code>4
29
5
elo nov
tam</code></pre><p>输出样例：</p>
<pre><code>hel mar
may
115
13</code></pre><p>分析：<br>    定义一个字符串数组，用来存储n个字符串，然后对每个字符串判断是数字还是字母，分别调用不同的函数。<br>数字》字符串：<br>因为数字范围是【0-169），所以火星文只有两位。用数字对13取整得到高位，然后再对13取余，得到低位。如果高位有数，而低位为0则不用输出低位对应的火星文，如果高位低位都不为0，就正常输出。<br>字符串到数字：<br>在函数中定义两个字符串数组分别对应高位与低位的字符串，然后对传入的字符串查找是否包含某一个火星文，包含高位上的火星文就拿对应的下标<em>13，低位布用</em>13，为了减少运行时间可以添加变量控制循环。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
void changeToNumber(char *a);
void changeToString(int num);
int main(void){
    int num=0;
    scanf(&quot;%d&quot;,&amp;num);
    getchar();
    char str[num][10];
    int i=0;
    while(i&lt;num){
        gets(str[i++]);
    }
    i=0;
    for(;i&lt;num;i++){
        if(str[i][0]&lt;=&apos;9&apos;&amp;&amp;str[i][0]&gt;=&apos;0&apos;){
            int sum=0;
            for(int j=0;j&lt;strlen(str[i]);j++){
                sum=sum*10+(str[i][j]-&apos;0&apos;);
            }
            changeToString(sum);
        }else{
            changeToNumber(str[i]);
        }
    }
    return 0;
}
void changeToString(int num){
    int n=num/13;
    int m=num%13;
    if(n&gt;0){
        switch(n){
            case 1:printf(&quot;tam&quot;);break;
            case 2:printf(&quot;hel&quot;);break;
            case 3:printf(&quot;maa&quot;);break;
            case 4:printf(&quot;huh&quot;);break;
            case 5:printf(&quot;tou&quot;);break;
            case 6:printf(&quot;kes&quot;);break;
            case 7:printf(&quot;hei&quot;);break;
            case 8:printf(&quot;elo&quot;);break;
            case 9:printf(&quot;syy&quot;);break;
            case 10:printf(&quot;lok&quot;);break;
            case 11:printf(&quot;mer&quot;);break;
            case 12:printf(&quot;jou&quot;);break;
        }
    }
    if(n&gt;0&amp;&amp;m&gt;0){
        printf(&quot; &quot;);
    }
    if(n&gt;0&amp;&amp;m==0){
        printf(&quot;\n&quot;);
        return;
    }
        switch(m){
            case 0:printf(&quot;tret\n&quot;);break;
            case 1:printf(&quot;jan\n&quot;);break;
            case 2:printf(&quot;feb\n&quot;);break;
            case 3:printf(&quot;mar\n&quot;);break;
            case 4:printf(&quot;apr\n&quot;);break;
            case 5:printf(&quot;may\n&quot;);break;
            case 6:printf(&quot;jun\n&quot;);break;
            case 7:printf(&quot;jly\n&quot;);break;
            case 8:printf(&quot;aug\n&quot;);break;
            case 9:printf(&quot;sep\n&quot;);break;
            case 10:printf(&quot;oct\n&quot;);break;
            case 11:printf(&quot;nov\n&quot;);break;
            case 12:printf(&quot;dec\n&quot;);break;
        }
} 

void changeToNumber(char *a){
    static char chrs1[13][5]={&quot;##&quot;,&quot;tam&quot;, &quot;hel&quot;, &quot;maa&quot;, &quot;huh&quot;, &quot;tou&quot;, &quot;kes&quot;, &quot;hei&quot;, &quot;elo&quot;, &quot;syy&quot;, &quot;lok&quot;, &quot;mer&quot;, &quot;jou&quot;};
    static char chrs2[13][5]={&quot;tret&quot;,&quot;jan&quot;, &quot;feb&quot;, &quot;mar&quot;, &quot;apr&quot;, &quot;may&quot;, &quot;jun&quot;, &quot;jly&quot;, &quot;aug&quot;, &quot;sep&quot;, &quot;oct&quot;, &quot;nov&quot;, &quot;dec&quot;};
    int sum=0;
    int flag1=1,flag2=1;
    for(int i=0;i&lt;13;i++){
        if(strstr(a,chrs1[i])&amp;&amp;flag1){
            sum=sum+(i)*13;
            flag1=0;
        }
        if(strstr(a,chrs2[i])&amp;&amp;flag2){
            sum=sum+i;
            flag2=0;
        }
        if(!flag1&amp;&amp;!flag2){
            break;
        }
    }
    printf(&quot;%d\n&quot;,sum);
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1043</title>
    <url>/2019/09/25/PTA-Basic-1043/</url>
    <content><![CDATA[<p>题目：<br>给定一个长度不超过 10<br>​4<br>​​  的、仅由英文字母构成的字符串。请将字符重新调整顺序，按 PATestPATest…. 这样的顺序输出，并忽略其它字符。当然，六种字符的个数不一定是一样多的，若某种字符已经输出完，则余下的字符仍按 PATest 的顺序打印，直到所有字符都被输出。</p>
<p>输入格式：<br>输入在一行中给出一个长度不超过 10<br>​4<br>​​  的、仅由英文字母构成的非空字符串。</p>
<p>输出格式：<br>在一行中按题目要求输出排序后的字符串。题目保证输出非空。</p>
<p>输入样例：</p>
<pre><code>redlesPayBestPATTopTeePHPereatitAPPT</code></pre><p>输出样例：</p>
<pre><code>PATestPATestPTetPTePePee</code></pre><p>分析：<br>定义一个整型数组用下标对应字母，数值对应个数。另外用一个变量存储符合条件的字符总数，然后进行输出，每次查找对应的字母是否还有数目，如果有就输出并字符总数减去1没有就跳过字母。</p>
<p>代码：</p>
<p>c++实现：</p>
<pre><code>#include &lt;iostream&gt;
#include&lt;stdio.h&gt;
using namespace std;

int main()
{
    int chars[6]={0};
    string str;
    cin&gt;&gt;str;
    int len=str.length();
    int sum=0;
    for(int i=0;i&lt;len;i++){
        switch(str.at(i)){
            case &apos;P&apos;:chars[0]++;sum++;break;
            case &apos;A&apos;:chars[1]++;sum++;break;
            case &apos;T&apos;:chars[2]++;sum++;break;
            case &apos;e&apos;:chars[3]++;sum++;break;
            case &apos;s&apos;:chars[4]++;sum++;break;
            case &apos;t&apos;:chars[5]++;sum++;break;
            default:break;
        }
    }
    while(sum){
        if(chars[0]){
            chars[0]--;
            sum--;
            cout&lt;&lt;&apos;P&apos;;
        }
        if(chars[1]){
            chars[1]--;
            sum--;
            cout&lt;&lt;&apos;A&apos;;
        }
        if(chars[2]){
            chars[2]--;
            sum--;
            cout&lt;&lt;&apos;T&apos;;
        }
        if(chars[3]){
            chars[3]--;
            sum--;
            cout&lt;&lt;&apos;e&apos;;
        }
        if(chars[4]){
            chars[4]--;
            sum--;
            cout&lt;&lt;&apos;s&apos;;
        }
        if(chars[5]){
            chars[5]--;
            sum--;
            cout&lt;&lt;&apos;t&apos;;
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1047</title>
    <url>/2019/09/26/PTA-Basic-1047/</url>
    <content><![CDATA[<p>题目：</p>
<p>编程团体赛的规则为：每个参赛队由若干队员组成；所有队员独立比赛；参赛队的成绩为所有队员的成绩和；成绩最高的队获胜。</p>
<p>现给定所有队员的比赛成绩，请你编写程序找出冠军队。</p>
<p>输入格式：<br>输入第一行给出一个正整数 N（≤10<br>​4<br>​​ ），即所有参赛队员总数。随后 N 行，每行给出一位队员的成绩，格式为：队伍编号-队员编号 成绩，其中队伍编号为 1 到 1000 的正整数，队员编号为 1 到 10 的正整数，成绩为 0 到 100 的整数。</p>
<p>输出格式：<br>在一行中输出冠军队的编号和总成绩，其间以一个空格分隔。注意：题目保证冠军队是唯一的。</p>
<p>输入样例：</p>
<pre><code>6
3-10 99
11-5 87
102-1 0
102-3 100
11-9 89
3-2 61</code></pre><p>输出样例：</p>
<pre><code>11 176</code></pre><p>分析：此题与前面的挖掘机那题完全一样。<br>定义一个足够大的数组要把队伍编号都包含在内，然后把输输入一个队伍的相关信息，可以跳过中间一个数字的读取，队伍编号就是对应其在数组的位置，每次就<br>把输入的分数加到对应的位置，然后跟目前位置最大的比，如果比它大就把它存储下来，最后直接输出队伍编号，与分数。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int schools[10001];
    int max=0;
    int max_school=0;
    int n,a,b;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++){
        scanf(&quot;%d-%*d %d&quot;,&amp;a,&amp;b);//%*d代表不接受此输入。
        schools[a]=schools[a]+b;
        if(schools[a]&gt;max){
            max=schools[a];
            max_school=a;
        }
    }
    printf(&quot;%d %d&quot;,max_school,max);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1041</title>
    <url>/2019/09/24/PTA-Basic-1041/</url>
    <content><![CDATA[<p>每个 PAT 考生在参加考试时都会被分配两个座位号，一个是试机座位，一个是考试座位。正常情况下，考生在入场时先得到试机座位号码，入座进入试机状态后，系统会显示该考生的考试座位号码，考试时考生需要换到考试座位就座。但有些考生迟到了，试机已经结束，他们只能拿着领到的试机座位号码求助于你，从后台查出他们的考试座位号码。</p>
<p>输入格式：<br>输入第一行给出一个正整数 N（≤1000），随后 N 行，每行给出一个考生的信息：准考证号 试机座位号 考试座位号。其中准考证号由 16 位数字组成，座位从 1 到 N 编号。输入保证每个人的准考证号都不同，并且任何时候都不会把两个人分配到同一个座位上。</p>
<p>考生信息之后，给出一个正整数 M（≤N），随后一行中给出 M 个待查询的试机座位号码，以空格分隔。</p>
<p>输出格式：<br>对应每个需要查询的试机座位号码，在一行中输出对应考生的准考证号和考试座位号码，中间用 1 个空格分隔。</p>
<p>输入样例：</p>
<pre><code>4
3310120150912233 2 4
3310120150912119 4 1
3310120150912126 1 3
3310120150912002 3 2
2
3 4</code></pre><p>输出样例：</p>
<pre><code>3310120150912002 2
3310120150912119 1</code></pre><p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
typedef struct stu{
    char id[17];
    int sitNum;
    int examNum;
}stu;
int main(void){
    int num;
    scanf(&quot;%d&quot;,&amp;num);
    stu stus[num];
    int i=0;
    while(i&lt;num){
        scanf(&quot;%s %d %d&quot;,(stus[i].id),&amp;(stus[i].sitNum),&amp;(stus[i].examNum));
        i++;
    }
    int num1=0;
    scanf(&quot;%d&quot;,&amp;num1);
    while(num1--){
        int n;
        scanf(&quot;%d&quot;,&amp;n);
        for(int i=0;i&lt;num;i++){
            if(stus[i].sitNum==n){
                printf(&quot;%s %d\n&quot;,stus[i].id,stus[i].examNum);
            }
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1046</title>
    <url>/2019/09/26/PTA-Basic-1046/</url>
    <content><![CDATA[<p>题目：</p>
<p>划拳是古老中国酒文化的一个有趣的组成部分。酒桌上两人划拳的方法为：每人口中喊出一个数字，同时用手比划出一个数字。如果谁比划出的数字正好等于两人喊出的数字之和，谁就赢了，输家罚一杯酒。两人同赢或两人同输则继续下一轮，直到唯一的赢家出现。</p>
<p>下面给出甲、乙两人的划拳记录，请你统计他们最后分别喝了多少杯酒。</p>
<p>输入格式：<br>输入第一行先给出一个正整数 N（≤100），随后 N 行，每行给出一轮划拳的记录，格式为：</p>
<p>甲喊 甲划 乙喊 乙划<br>其中喊是喊出的数字，划是划出的数字，均为不超过 100 的正整数（两只手一起划）。</p>
<p>输出格式：<br>在一行中先后输出甲、乙两人喝酒的杯数，其间以一个空格分隔。</p>
<p>输入样例：</p>
<pre><code>5
8 10 9 12
5 10 5 10
3 8 5 12
12 18 1 13
4 16 12 15</code></pre><p>输出样例：</p>
<pre><code>1 2</code></pre><p>分析：<br>定义变量存储甲乙败的次数，对每次输入的数字判断即可。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int num;
    scanf(&quot;%d&quot;,&amp;num);
    int i=0,j=0;
    int a,b,c,d;
    while(num--){
        scanf(&quot;%d %d %d %d&quot;,&amp;a,&amp;b,&amp;c,&amp;d);
        int res=a+c;
        if(b==res&amp;&amp;d!=res){
            j++;
        }else if(b!=res&amp;&amp;d==res){
            i++;
        }else{
            continue;
        }
    }
    printf(&quot;%d %d&quot;,i,j);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1048</title>
    <url>/2019/09/26/PTA-Basic-1048/</url>
    <content><![CDATA[<p>题目：</p>
<p>本题要求实现一种数字加密方法。首先固定一个加密用正整数 A，对任一正整数 B，将其每 1 位数字与 A 的对应位置上的数字进行以下运算：对奇数位，对应位的数字相加后对 13 取余——这里用 J 代表 10、Q 代表 11、K 代表 12；对偶数位，用 B 的数字减去 A 的数字，若结果为负数，则再加 10。这里令个位为第 1 位。</p>
<p>输入格式：<br>输入在一行中依次给出 A 和 B，均为不超过 100 位的正整数，其间以空格分隔。</p>
<p>输出格式：<br>在一行中输出加密后的结果。</p>
<p>输入样例：</p>
<pre><code>1234567 368782971</code></pre><p>输出样例：</p>
<pre><code>3695Q8118</code></pre><p>分析：<br>定义三个字符串数组分别用来存储输入的两个字符串与处理后的结果，先定义一个反转字符串的函数。然后将两个字符串都反转一下然后对应开始遍历字符串，取长度最大的那个为上限，长度不够时那个位置对应的数字就是0相应的处理就可以了。<br>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
char * strrev(char *a){//反转字符串。
    char *b=a;
    int i=strlen(a)-1,j=0;
    char ch;
    while(i&gt;j){
        ch=a[i];
        a[i]=a[j];
        a[j]=ch;
        i--;
        j++;
    }
    return a;
}
int main(void){
    char strs1[101];
    char strs2[101];
    char result[101];
    memset(strs1,&apos;\0&apos;,101);
    memset(strs2,&apos;\0&apos;,101);
    memset(result,&apos;\0&apos;,101);
    scanf(&quot;%s %s&quot;,strs1,strs2);
    strrev(strs1);
    strrev(strs2);
    int i=0;
    int len=(strlen(strs1)&gt;strlen(strs2)?strlen(strs1):strlen(strs2));//取最长的那个为上限。
    while(len--){
        i++;
        if(i%2!=0){//为奇数
            int x=(strs1[i-1]-&apos;0&apos;)&gt;-1?(strs1[i-1]-&apos;0&apos;):0;
            int y=(strs2[i-1]-&apos;0&apos;)&gt;-1?(strs2[i-1]-&apos;0&apos;):0;
            y=(y+x)%13;
            if(y&lt;10){
                result[i-1]=y+&apos;0&apos;;
            }else{
                switch(y){
                    case 10:result[i-1]=&apos;J&apos;;break;
                    case 11:result[i-1]=&apos;Q&apos;;break;
                    case 12:result[i-1]=&apos;K&apos;;break;
                }
            }
        }else{
            int x=(strs1[i-1]-&apos;0&apos;)&gt;-1?(strs1[i-1]-&apos;0&apos;):0;
            int y=(strs2[i-1]-&apos;0&apos;)&gt;-1?(strs2[i-1]-&apos;0&apos;):0;
            y=y-x;
            if(y&lt;0){
                y=y+10;
            }
            result[i-1]=y+&apos;0&apos;;
        }
    }
    strrev(result);//最后要将数组反转一下。
    printf(&quot;%s&quot;,result);
    return 0;
}</code></pre><p>###总结：做任何算法包括事情前都要有一个大致思路，不然就会在做的过程中迷失方向。</p>
]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1049</title>
    <url>/2019/09/27/PTA-Basic-1049/</url>
    <content><![CDATA[<p>题目：</p>
<p>给定一个正数数列，我们可以从中截取任意的连续的几个数，称为片段。例如，给定数列 { 0.1, 0.2, 0.3, 0.4 }，我们有 (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) (0.4) 这 10 个片段。</p>
<p>给定正整数数列，求出全部片段包含的所有的数之和。如本例中 10 个片段总和是 0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0。</p>
<p>输入格式：<br>输入第一行给出一个不超过 10<br>​5<br>​​  的正整数 N，表示数列中数的个数，第二行给出 N 个不超过 1.0 的正数，是数列中的数，其间以空格分隔。</p>
<p>输出格式：<br>在一行中输出该序列所有片段包含的数之和，精确到小数点后 2 位。</p>
<p>输入样例：</p>
<pre><code>4

0.1 0.2 0.3 0.4</code></pre><p>输出样例：</p>
<pre><code>5.00</code></pre><p>分析：<br>此题并不难，只要在做题目前，思考一下，不难得出一个推导的公式<br>（sum = n1<em>n</em>1+n2<em>(n-1)*2+n3</em>(n-2)<em>3+…(nk</em>(n-k-1)*k)…）<br>注意点：双精度浮点数输入输出时用%lf，单精度用%f，不能混合用不然输入或输出的数据可能会出错。<br>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int num;
    scanf(&quot;%d&quot;,&amp;num);
    double nums[num];
    int i=0;
    while(i&lt;num){
        scanf(&quot;%lf&quot;,&amp;nums[i]);
        i++;
    }
    double sum=0;
    int n=num;
    for(i=0;i&lt;num;i++){
        sum=sum+1.0*nums[i]*n*(i+1);
        n--;
    }
    printf(&quot;%.2f&quot;,sum);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1051</title>
    <url>/2019/09/27/PTA-Basic-1051/</url>
    <content><![CDATA[<p>复数可以写成 (A+Bi) 的常规形式，其中 A 是实部，B 是虚部，i 是虚数单位，满足 i<br>​2<br>​​ =−1；也可以写成极坐标下的指数形式 (R×e<br>​(Pi)<br>​​ )，其中 R 是复数模，P 是辐角，i 是虚数单位，其等价于三角形式 R(cos(P)+isin(P))。</p>
<p>现给定两个复数的 R 和 P，要求输出两数乘积的常规形式。</p>
<p>输入格式：<br>输入在一行中依次给出两个复数的 R<br>​1<br>​​ , P<br>​1<br>​​ , R<br>​2<br>​​ , P<br>​2<br>​​ ，数字间以空格分隔。</p>
<p>输出格式：<br>在一行中按照 A+Bi 的格式输出两数乘积的常规形式，实部和虚部均保留 2 位小数。注意：如果 B 是负数，则应该写成 A-|B|i 的形式。</p>
<p>输入样例：</p>
<pre><code>2.3 3.5 5.2 0.4</code></pre><p>输出样例：</p>
<pre><code>-8.68-8.23i</code></pre><p>思路：</p>
<pre><code>将输入的复数模，与对应的叫反别转化为直角坐标下的实部与虚部。然后符合复数乘法即可。

注意：双精度浮点数输入输出时用%lf，单精度用%f，不能混合用不然输入或输出的数据可能会出错。</code></pre><p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
int main(){
    double a1,a2,b1,b2;
    double r1,r2,p1,p2;
    scanf(&quot;%lf %lf %lf %lf&quot;,&amp;r1,&amp;p1,&amp;r2,&amp;p2);
    a1=r1*cos(p1);
    a2=r1*sin(p1);
    b1=r2*cos(p2);
    b2=r2*sin(p2);
    double s1=a1*b1-a2*b2;
    double s2=a1*b2+a2*b1;
    if (fabs(s1) &lt; 0.001) s1 = 0;
    if (fabs(s2) &lt; 0.001) s2 = 0;
    if (s2 &gt;= 0)
        printf(&quot;%.2f+%.2fi&quot;, s1, s2);
    else
        printf(&quot;%.2f%.2fi&quot;, s1, s2);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1053</title>
    <url>/2019/09/28/PTA-Basic-1053/</url>
    <content><![CDATA[<p>在不打扰居民的前提下，统计住房空置率的一种方法是根据每户用电量的连续变化规律进行判断。判断方法如下：</p>
<p>在观察期内，若存在超过一半的日子用电量低于某给定的阈值 e，则该住房为“可能空置”；</p>
<p>若观察期超过某给定阈值 D 天，且满足上一个条件，则该住房为“空置”。</p>
<p>现给定某居民区的住户用电量数据，请你统计“可能空置”的比率和“空置”比率，即以上两种状态的住房占居民区住房总套数的百分比。</p>
<p>输入格式：<br>输入第一行给出正整数 N（≤1000），为居民区住房总套数；正实数 e，即低电量阈值；正整数 D，即观察期阈值。随后 N 行，每行按以下格式给出一套住房的用电量数据：</p>
<p>K E<br>​1<br>​​  E<br>​2<br>​​  … E<br>​K<br>​​ </p>
<p>其中 K 为观察的天数，E<br>​i<br>​​  为第 i 天的用电量。</p>
<p>输出格式：<br>在一行中输出“可能空置”的比率和“空置”比率的百分比值，其间以一个空格分隔，保留小数点后 1 位。</p>
<p>输入样例：</p>
<pre><code>5 0.5 10
6 0.3 0.4 0.5 0.2 0.8 0.6
10 0.0 0.1 0.2 0.3 0.0 0.8 0.6 0.7 0.0 0.5
5 0.4 0.3 0.5 0.1 0.7
11 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1
11 2 2 2 1 1 0.1 1 0.1 0.1 0.1 0.1</code></pre><p>输出样例：</p>
<pre><code>40.0% 20.0%</code></pre><p>（样例解释：第2、3户为“可能空置”，第4户为“空置”，其他户不是空置。）</p>
<p>分析：<br>按题目走。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int sum=0;
    double e,d;
    scanf(&quot;%d %lf %lf&quot;,&amp;sum,&amp;e,&amp;d);
    int maybe=0,must=0;
    for(int i=0;i&lt;sum;i++){
        int days=0;
        int sum=0;
        scanf(&quot;%d&quot;,&amp;days);
        for(int j=0;j&lt;days;j++){
            double en;
            scanf(&quot;%lf&quot;,&amp;en);
            if(en&lt;e){
                sum++;
            }
        }
        if(days&gt;d&amp;&amp;sum&gt;(int)(days/2)){
            must++;
        }else if(sum&gt;(int)(days/2)){
            maybe++;
        }else{    
        }
    }
    printf(&quot;%.1f&quot;,100*(maybe*1.0/sum));
    printf(&quot;%c &quot;,&apos;%&apos;);
    printf(&quot;%.1f&quot;,100*(must*1.0/sum));
    printf(&quot;%c&quot;,&apos;%&apos;);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1056</title>
    <url>/2019/09/29/PTA-Basic-1056/</url>
    <content><![CDATA[<p>题目：</p>
<p>给定 N 个非 0 的个位数字，用其中任意 2 个数字都可以组合成 1 个 2 位的数字。要求所有可能组合出来的 2 位数字的和。例如给定 2、5、8，则可以组合出：25、28、52、58、82、85，它们的和为330。</p>
<p>输入格式：<br>输入在一行中先给出 N（1 &lt; N &lt; 10），随后给出 N 个不同的非 0 个位数字。数字间以空格分隔。</p>
<p>输出格式：<br>输出所有可能组合出来的2位数字的和。</p>
<p>输入样例：</p>
<pre><code>3 2 8 5</code></pre><p>输出样例：</p>
<pre><code>330</code></pre><p>分析：<br>用数组存储输入的数字，然后遍历数组，将情况分为为0不为0两种情况，<br>为0只要找十位的数字即可，不为0，找完十位和还要找个位。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int add(int a[],int n);
int main()
{
    int n;
    int *a=NULL;
    scanf(&quot;%d&quot;,&amp;n);
    a=malloc(sizeof(int)*n);
    int i=0;
    while(i&lt;n){
        scanf(&quot;%d&quot;,&amp;a[i++]);
    }
    int sum=0;
    sum=add(a,n);
    printf(&quot;%d&quot;,sum);
    return 0;
}
int add(int a[],int n){
    int sum=0;
    for(int i=0;i&lt;n;i++){
        if(a[i]!=0){
                for(int j=i+1;j&lt;n;j++){
                    sum=sum+a[i]*10+a[j];
                    sum=sum+a[i]+a[j]*10;
                }
        }else{
            for(int j=i+1;j&lt;n;j++){
                    sum=sum+a[i]+a[j]*10;
                }
        }
    }
    return sum;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1050</title>
    <url>/2019/09/27/PTA-Basic-1050/</url>
    <content><![CDATA[<p>本题要求将给定的 N 个正整数按非递增的顺序，填入“螺旋矩阵”。所谓“螺旋矩阵”，是指从左上角第 1 个格子开始，按顺时针螺旋方向填充。要求矩阵的规模为 m 行 n 列，满足条件：m×n 等于 N；m≥n；且 m−n 取所有可能值中的最小值。</p>
<p>输入格式：<br>输入在第 1 行中给出一个正整数 N，第 2 行给出 N 个待填充的正整数。所有数字不超过 10<br>​4<br>​​ ，相邻数字以空格分隔。</p>
<p>输出格式：<br>输出螺旋矩阵。每行 n 个数字，共 m 行。相邻数字以 1 个空格分隔，行末不得有多余空格。</p>
<p>输入样例：</p>
<pre><code>12
37 76 20 98 76 42 53 95 60 81 58 93</code></pre><p>输出样例：</p>
<pre><code>98 95 93
42 37 81
53 20 76
58 60 76</code></pre><p>分析：<br>    难点：</p>
<pre><code>1.求一个数字最接近的两个约数。//用于求行数与列数
2.每一层输出时可能会位置出错。</code></pre><p>思路：</p>
<pre><code>对一个数开平方，然后从它的根向下（包含跟）找

到的第一个能把它整除的数就是最接近的两个数字

中的小的哪一个，大的哪一个只要原数取整即可。且大的哪一个为行数，小的哪一个为列数。

对输入进来的数组进行排序，然后定义一个二维数组存储螺旋矩阵（从最外面一层开始，分为上部赋值，

右部赋值，下部赋值，左部赋值，然后进行第二层的赋值。。。）

把螺旋矩阵看成一个不断重复相同操作的过程。</code></pre><p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;math.h&gt;
//求一个数字最接近平方根的数字，就是其接近的约数。
int func(int n){
    int m=sqrt(n);
    while(m!=1){
        if(n%m==0){
            return m;
        }
        m--;
    }
    return 1;
}
int cmp(const void *a,const void *b){
    return *(int *)b-*(int *)a;
}
int main(){
    int N,n,m,t=0;
    scanf(&quot;%d&quot;,&amp;N);
    int a[N];
    while(t&lt;N){
        scanf(&quot;%d&quot;,&amp;a[t++]);
    }
    qsort(a,N,sizeof(int),cmp);//对数组排序从大到小
    n=func(N); //列数
    m=N/n;//获得行数，行数一定大于等于列数
    int b[m][n]; //定义一个二维矩阵
    int level=n/2+n%2; //一共有几层螺旋圈
    t=0;
    int j=0;
    for(int i=1;i&lt;=level;i++){
        //实现第i层的上面部分.
         for( j=i-1;j&lt;=n-i&amp;&amp;t&lt;N;j++){//行数为[i-1]列数为[i-1,n-i]
             b[i-1][j]=a[t++];
         }
         //实现第i层的右边
         for( j=i;j&lt;=(m-i)&amp;&amp;t&lt;N;j++){//行数为[i,m-i][n-i]
             b[j][n-i]=a[t++];
         }
         //实现第i层的下面
         for( j=n-i-1;j&gt;=(i-1)&amp;&amp;t&lt;N;j--){//行数为[m-i]列数为[n-i,i-1]
             b[m-i][j]=a[t++];
         }
         //实现第i层的左面
         for( j=m-i-1;j&gt;(i-1)&amp;&amp;t&lt;N;j--){//行数为[m-i-1，i]列数为[i-1]
             b[j][i-1]=a[t++];
         }
    }
    for(int i=0;i&lt;m;i++){
        for(int j=0;j&lt;n;j++){
            if(j!=0)
                printf(&quot; &quot;);
            printf(&quot;%d&quot;,b[i][j]);
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1052</title>
    <url>/2019/09/28/PTA-Basic-1052/</url>
    <content><![CDATA[<p>题目：</p>
<p>萌萌哒表情符号通常由“手”、“眼”、“口”三个主要部分组成。简单起见，我们假设一个表情符号是按下列格式输出的：</p>
<pre><code>[左手]([左眼][口][右眼])[右手]</code></pre><p>现给出可选用的符号集合，请你按用户的要求输出表情。</p>
<p>输入格式：<br>输入首先在前三行顺序对应给出手、眼、口的可选符号集。每个符号括在一对方括号 []内。题目保证每个集合都至少有一个符号，并不超过 10 个符号；每个符号包含 1 到 4 个非空字符。</p>
<p>之后一行给出一个正整数 K，为用户请求的个数。随后 K 行，每行给出一个用户的符号选择，顺序为左手、左眼、口、右眼、右手——这里只给出符号在相应集合中的序号（从 1 开始），数字间以空格分隔。</p>
<p>输出格式：<br>对每个用户请求，在一行中输出生成的表情。若用户选择的序号不存在，则输出 Are you kidding me? @/@。</p>
<p>输入样例：</p>
<pre><code>[╮][╭][o][~\][/~]  [&lt;][&gt;]
 [╯][╰][^][-][=][&gt;][&lt;][@][⊙]
[Д][▽][_][ε][^]  ...
4
1 1 2 2 2
6 8 1 5 5
3 3 4 3 3
2 10 3 9 3</code></pre><p>输出样例：</p>
<pre><code>╮(╯▽╰)╭
&lt;(@Д=)/~
o(^ε^)o
Are you kidding me? @\/@</code></pre><p>思路：<br>第一行给出手的符号库，<br>第二行给出眼的符号库，<br>第三行给出口的符号库。<br>定义三个二维数组，每一行存储字符串。<br>然后存储输入进的数字，<br>根据每一行对手，眼，口的坐标选择，输出相应的字符串符号。若没有，则输出Are you kidding me? @/@<br>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main()
{
  char Hand[10][5]={0};
  char Eye[10][5]={0};
  char Mouth[10][5]={0};
  char temp=0;
  int iHand=0,iEye=0,iMouth=0;//字符计数
  while((temp=getchar())!=&apos;\n&apos;)
  {
    if(temp==&apos;[&apos;)
    {
      scanf(&quot;%[^]]&quot;,szHand[iHand++]);
    }
  }
  while((temp=getchar())!=&apos;\n&apos;)
  {
    if(temp==&apos;[&apos;)
    {
      scanf(&quot;%[^]]&quot;,szEye[iEye++]);
    }
  }
  while((temp=getchar())!=&apos;\n&apos;)
  {
    if(temp==&apos;[&apos;)
    {
      scanf(&quot;%[^]]&quot;,szMouth[iMouth++]);
    }
  }
  int iNum=0,iMood[5]={0};
  scanf(&quot;%d&quot;,&amp;iNum);
  for(int i=0;i&lt;iNum;i++)
  {
    for(int j=0;j&lt;5;j++)
    {
      scanf(&quot;%d&quot;,iMood+j);
    }
    //选择输出，注意表情是从1开始，数组是从0开始
    if(iMood[0]&gt;0&amp;&amp;iMood[0]&lt;=iHand
     &amp;&amp;iMood[1]&gt;0&amp;&amp;iMood[1]&lt;=iEye
     &amp;&amp;iMood[2]&gt;0&amp;&amp;iMood[2]&lt;=iMouth
     &amp;&amp;iMood[3]&gt;0&amp;&amp;iMood[3]&lt;=iEye
     &amp;&amp;iMood[4]&gt;0&amp;&amp;iMood[4]&lt;=iHand)
     {
       printf(&quot;%s(%s%s%s)%s&quot;,szHand[iMood[0]-1],szEye[iMood[1]-1],
           szMouth[iMood[2]-1],szEye[iMood[3]-1],szHand[iMood[4]-1]);
     }
     else
     {
       printf(&quot;Are you kidding me? @\\/@&quot;);
     }
     if(i!=iNum-1)
     {
       printf(&quot;\n&quot;);
     }
  }
  return 0;

}</code></pre><p>注意：<br>scanf函数有一种格式控制可以输入指定符号前的字符串，即%[^…]，其中…可以是任意字符，之前的任意多个字符会被输入，如果加上<em>，即%</em>[^…]，就是忽略…前的任意多字符。因为有[]两个字符作为数据的前后标记，因此可以用getchar试探读入，读入回车则结束，读入[则接收数据。<br>参考链接：<a href="https://blog.csdn.net/bawangtu/article/details/81287293">https://blog.csdn.net/bawangtu/article/details/81287293</a></p>
]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1055</title>
    <url>/2019/09/29/PTA-Basic-1055/</url>
    <content><![CDATA[<p>题目:</p>
<p>拍集体照时队形很重要，这里对给定的 N 个人 K 排的队形设计排队规则如下：</p>
<p>每排人数为 N/K（向下取整），多出来的人全部站在最后一排；</p>
<p>后排所有人的个子都不比前排任何人矮；</p>
<p>每排中最高者站中间（中间位置为 m/2+1，其中 m 为该排人数，除法向下取整）；</p>
<p>每排其他人以中间人为轴，按身高非增序，先右后左交替入队站在中间人的两侧（例如5人身高为190、188、186、175、170，则队形为175、188、190、186、170。这里假设你面对拍照者，所以你的左边是中间人的右边）。</p>
<p>若多人身高相同，则按名字的字典序升序排列。这里保证无重名。</p>
<p>现给定一组拍照人，请编写程序输出他们的队形。</p>
<p>输入格式：<br>每个输入包含 1 个测试用例。每个测试用例第 1 行给出两个正整数 N（≤10<br>​4<br>​​ ，总人数）和 K（≤10，总排数）。随后 N 行，每行给出一个人的名字（不包含空格、长度不超过 8 个英文字母）和身高（[30, 300] 区间内的整数）。</p>
<p>输出格式：<br>输出拍照的队形。即K排人名，其间以空格分隔，行末不得有多余空格。注意：假设你面对拍照者，后排的人输出在上方，前排输出在下方。</p>
<p>输入样例：</p>
<pre><code>10 3
Tom 188
Mike 170
Eva 168
Tim 160
Joe 190
Ann 168
Bob 175
Nick 186
Amy 160
John 159</code></pre><p>输出样例：</p>
<pre><code>Bob Tom Joe Nick
Ann Mike Eva
Tim Amy John</code></pre><p>分析：</p>
<p>定一个一个结构体，其拥有姓名，身高。然后将输入的信息转化为人，然后根据题目要求降序排序，先输出最后一排，接着倒数第二排，每排定义适合题意的个数个人，然后根据题目，先将最大的人插入中间，接着依左右，左右（题目中的右左为面向摄像机的方向）赋值。<br>最后遍历输出。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt; 
#include&lt;stdlib.h&gt;
int cmp(const void *a ,const void *b);
typedef struct {
    char name[9];
    int height;
}human;
int main(void){
    int sum,n;
    scanf(&quot;%d %d&quot;,&amp;sum,&amp;n);
    human humen[sum];
    for(int i=0;i&lt;sum;i++){
        scanf(&quot;%s %d&quot;,&amp;humen[i].name,&amp;(humen[i].height));//输入到人的数组中去
        getchar();
    }
    qsort(humen,sum,sizeof(human),cmp);//对人的数组进行重大到小排序。
    int begin=0;
    int x=0;
    while(begin&lt;sum){
        if(begin==0){
             x=sum/n+sum%n;//如果是最后一排的话要将剩余的人数插入到其中
        }else{
             x=sum/n;//如果不是最后一排的话，直接得到人数。
        }
        int index=x/2;//中间的人，题目中的m/2+1是根据下标从1开始计算的。
            human hus[x];
            strcpy(hus[index--].name,humen[begin++].name);//先将中间的人赋值，并将人修改为左边的哪一个人。
            int step=1;//初始步长为1
            while(index&gt;-1&amp;&amp;index&lt;x){
                step++;//左右相距的人头数（刚进入是相距2个人头）
                strcpy(hus[index].name,humen[begin++].name);
                index=index+step;//每次操作完都要改变坐标此处是将下标由左边变化到右边
                if(!(index&gt;-1&amp;&amp;index&lt;x))//检验变化后的坐标是否合法。
                    break;
                strcpy(hus[index].name,humen[begin++].name);//给右边赋值
                step++;//每一次左右赋值完之后，后面一个左右的距离就多了一个人头。
                index=index-step;//将下标放到下一次要赋值的人头处。
            }
            for(int i=0;i&lt;x;i++){//输出这一排的人。
                printf(&quot;%s%c&quot;,hus[i].name,(i==x-1?&apos;\n&apos;:&apos; &apos;));
            }
    }
    return 0;
}
int cmp(const void *a,const void *b){//先依据身高排序（降序），如果身高相同依据姓名排序（升序）
    human human1=*(human *)a;
    human human2=*(human *)b;
    if(human1.height&gt;human2.height){
        return -1;
    }else{
        if(human1.height==human2.height){
            return strcmp(human1.name,human2.name);
        }else{
            return 1;
        }
    }
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1058</title>
    <url>/2019/10/07/PTA-Basic-1058/</url>
    <content><![CDATA[<p>题目：</p>
<p>批改多选题是比较麻烦的事情，本题就请你写个程序帮助老师批改多选题，并且指出哪道题错的人最多。</p>
<p>输入格式：<br>输入在第一行给出两个正整数 N（ ≤ 1000）和 M（≤ 100），分别是学生人数和多选题的个数。随后 M 行，每行顺次给出一道题的满分值（不超过 5 的正整数）、选项个数（不少于 2 且不超过 5 的正整数）、正确选项个数（不超过选项个数的正整数）、所有正确选项。注意每题的选项从小写英文字母 a 开始顺次排列。各项间以 1 个空格分隔。最后 N 行，每行给出一个学生的答题情况，其每题答案格式为 (选中的选项个数 选项1 ……)，按题目顺序给出。注意：题目保证学生的答题情况是合法的，即不存在选中的选项数超过实际选项数的情况。</p>
<p>输出格式：<br>按照输入的顺序给出每个学生的得分，每个分数占一行。注意判题时只有选择全部正确才能得到该题的分数。最后一行输出错得最多的题目的错误次数和编号（题目按照输入的顺序从 1 开始编号）。如果有并列，则按编号递增顺序输出。数字间用空格分隔，行首尾不得有多余空格。如果所有题目都没有人错，则在最后一行输出 Too simple。</p>
<p>输入样例：</p>
<pre><code>3 4 
3 4 2 a c
2 5 1 b
5 3 2 b c
1 5 4 a b d e
(2 a c) (2 b d) (2 a c) (3 a b e)
(2 a c) (1 b) (2 a b) (4 a b d e)
(2 b d) (1 e) (2 b c) (4 a b c d)</code></pre><p>输出样例：</p>
<pre><code>6
5
2 
2 3 4</code></pre><p>分析：</p>
<p>定义一个非常大的数组存储所有可能的题目答案，定义一个非常大的数组存储每题的得分，定义一个非常大的数组存储每题出错的次数，定义一个非常大题目存储媒体正确答案的个数，定义一个非常大的学生数组。<br>在输入是就开始计算每一位学生的得分以及此题的出错次数。<br>最后输出每一位学生的分数，以及最高出错次数，和对应的题目（按升序排列）。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
int timu[100][5]={0};//定义一个二维数组存储题目正确的答案初始化每个都是0（表示错误）
int score[100]={0};//存储每一题目的得分
int time[100]={0};//存储每个题目的出错次数
int righttime[100]={0}; //存储每个题目标准答案的个数
int stu[1001]={0};//存储每个学生的得分
int main(void){
    int n=0,m=0;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);//输入学生数，与题目数。
    for(int i=0;i&lt;m;i++){
        int x=0;
        scanf(&quot;%d %*d %d&quot;,&amp;score[i],&amp;righttime[i]);//将每一个题目的分数存储到数组中去，并存储正确答案的个数以便下面计算答对的题目数是否为全部的正确数目
        char ch;
        while((ch=getchar())!=&apos;\n&apos;){//此处开始读取正确的选项。如果读到a就将timu数组的第0为赋值为1.
            if(ch&lt;=&apos;e&apos;&amp;&amp;ch&gt;=&apos;a&apos;){
                int k=ch-&apos;a&apos;;
                timu[i][k]=1;
            }
        }
    }
    int max=0; 
    for(int i=0;i&lt;n;i++){
        int t=0;
        char ch;
        int step0=0;//计算输入的选项的个数
        int step1=0;//计算选对的个数
        while((ch=getchar())!=&apos;\n&apos;){
            if(ch==&apos;(&apos;){ //读到这个就代表开始了新的一个题目，要将选项数目，答对数目初始化为0.
                step0=0;
                step1=0;
                continue;
            }else if(ch==&apos; &apos;){
                continue;
            }else if(ch&lt;=&apos;5&apos;&amp;&amp;ch&gt;=&apos;0&apos;){
                step0=ch-&apos;0&apos;; //计算选项数目
            }else{
                if(ch==&apos;)&apos;){//如果输入的选项都对但是总数不达标也不对。
                    if(step0==step1&amp;&amp;step0==righttime[t]){//对的步数符合初始化步数 
                        stu[i]+=score[t];//将分数加到第i为学生上去
                    }else{//否则此题就出错了
                        time[t]++;//这个题目的出错次数加1
                        if(time[t]&gt;max){
                            max=time[t];//如果比出错次数最大值大就交换值
                        }
                    }
                    t++;//下一题 
                }
                if(ch&lt;=&apos;e&apos;&amp;&amp;ch&gt;=&apos;a&apos;){
                    int k=ch-&apos;a&apos;;
                    if(timu[t][k]){//输入的选项对应的数组下标有值表示输入的答案是正确的
                        step1++;//对的步数加1 
                    }
                }
            }
        }
    }
    for(int i=0;i&lt;n;i++){
        printf(&quot;%d\n&quot;,stu[i]);//输出每一位学生的得分
    }
    if(max&gt;0){//如果最大值不为0就要统计出错的题目
    printf(&quot;%d&quot;,max);
        for(int i=0;i&lt;m;i++){
            if(time[i]==max){
                printf(&quot; %d&quot;,i+1);
            }
        }
    }else{//否则直接输出
        printf(&quot;Too simple&quot;);
    }
    return 0;
} </code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1060</title>
    <url>/2019/10/07/PTA-Basic-1060/</url>
    <content><![CDATA[<p>题目：</p>
<p>英国天文学家爱丁顿很喜欢骑车。据说他为了炫耀自己的骑车功力，还定义了一个“爱丁顿数” E ，即满足有 E 天骑车超过 E 英里的最大整数 E。据说爱丁顿自己的 E 等于87。</p>
<p>现给定某人 N 天的骑车距离，请你算出对应的爱丁顿数 E（≤N）。</p>
<p>输入格式：</p>
<p>输入第一行给出一个正整数 N (≤10<br>​5<br>​​ )，即连续骑车的天数；第二行给出 N 个非负整数，代表每天的骑车距离。</p>
<p>输出格式：<br>在一行中给出 N 天的爱丁顿数。</p>
<p>输入样例：</p>
<pre><code>10
6 7 6 9 3 10 8 2 7 8</code></pre><p>输出样例：</p>
<pre><code>6</code></pre><p>分析：首先什么是爱丁顿数？<br>        对输入的一个数组满足有e个数子大于e的最大整数，正如样例：此数组中数字大于六的个数是六，六又是最大的，所以它是爱丁顿数。</p>
<pre><code>处理：对输入的数组进行由大到小倒序排序，然后遍历直到找到大于下标的位置处。（对于某一个数字如果它比对应的下标大，那么前面比它大的也比它的下标大，，就这么找下去直到找到不合适的下标）</code></pre><p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int cmp(const void *a,const void *b){
    return *(int *)b-*(int *)a;
}
int main(void){
    int n=0;
    scanf(&quot;%d&quot;,&amp;n);
    int nums[n];
    int i=0;
    for(i=0;i&lt;n;i++){
        scanf(&quot;%d&quot;,&amp;nums[i]);
    }
    qsort(nums,n,sizeof(int),cmp);//倒序排列
    for(i=0;i&lt;n&amp;&amp;nums[i]&gt;(i+1);i++);//空语句
    printf(&quot;%d&quot;,i);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1054</title>
    <url>/2019/09/28/PTA-Basic-1054/</url>
    <content><![CDATA[<p>题目：</p>
<p>本题的基本要求非常简单：给定 N 个实数，计算它们的平均值。但复杂的是有些输入数据可能是非法的。一个“合法”的输入是 [−1000,1000] 区间内的实数，并且最多精确到小数点后 2 位。当你计算平均值的时候，不能把那些非法的数据算在内。</p>
<p>输入格式：<br>输入第一行给出正整数 N（≤100）。随后一行给出 N 个实数，数字间以一个空格分隔。</p>
<p>输出格式：<br>对每个非法输入，在一行中输出 ERROR: X is not a legal number，其中 X 是输入。最后在一行中输出结果：The average of K numbers is Y，其中 K 是合法输入的个数，Y 是它们的平均值，精确到小数点后 2 位。如果平均值无法计算，则用 Undefined 替换 Y。如果 K 为 1，则输出 The average of 1 number is Y。</p>
<p>输入样例 1：</p>
<pre><code>7
5 -3.2 aaa 9999 2.3.4 7.123 2.35</code></pre><p>输出样例 1：</p>
<pre><code>ERROR: aaa is not a legal number
ERROR: 9999 is not a legal number
ERROR: 2.3.4 is not a legal number
ERROR: 7.123 is not a legal number
The average of 3 numbers is 1.38</code></pre><p>输入样例 2：</p>
<pre><code>2

aaa -9999</code></pre><p>输出样例 2：</p>
<pre><code>ERROR: aaa is not a legal number
ERROR: -9999 is not a legal number
The average of 0 numbers is Undefined</code></pre><p>分析：</p>
<p>定义一个判断数字是否合法的函数（数字以数字或‘-’开头，不能只有‘-’，‘.’后面的数字长度不能大于2），注意如果输入数字中只有一个合法，不要不要用总和去除以1计算结果，而是直接输出The average of 1 number is ？。还有就是字符串赋值并不是想Java中的那样直接给就可以了，而是要调用函数复制。</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
int check(char* s);
int main(void){
    int n=0;
    scanf(&quot;%d&quot;,&amp;n);
    char str[n][10000];
    char s[10000];
    int i=0;
    double sum=0;
    int m=n;
    while(n--){
        scanf(&quot;%s&quot;,s);
        if(check(s)){
            sum+=atof(s);//函数atof将数字字符串转化为数字。
        }else{
            strcpy(str[i++],s);
        }
    }
    m=m-i;
    for(int k=0;k&lt;i;k++){
        printf(&quot;ERROR: %s is not a legal number\n&quot;,str[k]); 
    }
    if(m&gt;1)
    printf(&quot;The average of %d numbers is %.2lf\n&quot;,m,sum/m);
    if(m==0)
    printf(&quot;The average of 0 numbers is Undefined\n&quot;);
    if(m==1)
    printf(&quot;The average of 1 number is %.2lf&quot;,sum);
    return 0;
}
int  check(char* s){
    int sum=0;
    int n=0;
    for(int i=0;i&lt;strlen(s);i++){
        if(i==0){
            if(!(s[i]==&apos;-&apos;||(s[i]&lt;=&apos;9&apos;&amp;&amp;s[i]&gt;=&apos;0&apos;))){
                return 0;
            }else{
                if(strlen(s)==1&amp;&amp;s[i]==&apos;-&apos;){
                    return 0;
                }
            }
        }else{
            if(sum&gt;0){
                n++;
                if(n&gt;2){
                    return 0;
                }
            }
            if(s[i]==&apos;.&apos;){
                sum++;
                if(sum&gt;=2){
                    return 0;
                }
            }
        }
    }
    double res=atof(s);
    if(res&gt;1000||res&lt;-1000){
        return 0;
    }
    return 1;
} </code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1062</title>
    <url>/2019/10/07/PTA-Basic-1062/</url>
    <content><![CDATA[<p>题目：<br>一个分数一般写成两个整数相除的形式：N/M，其中 M 不为0。最简分数是指分子和分母没有公约数的分数表示形式。</p>
<p>现给定两个不相等的正分数 N<br>​1<br>​​ /M<br>​1<br>​​  和 N<br>​2<br>​​ /M<br>​2<br>​​ ，要求你按从小到大的顺序列出它们之间分母为 K 的最简分数。</p>
<p>输入格式：</p>
<p>输入在一行中按 N/M 的格式给出两个正分数，随后是一个正整数分母 K，其间以空格分隔。题目保证给出的所有整数都不超过 1000。</p>
<p>输出格式：<br>在一行中按 N/M 的格式列出两个给定分数之间分母为 K 的所有最简分数，按从小到大的顺序，其间以 1 个空格分隔。行首尾不得有多余空格。题目保证至少有 1 个输出。</p>
<p>输入样例：</p>
<pre><code>7/18 13/20 12</code></pre><p>输出样例：</p>
<pre><code>5/12 7/12</code></pre><p>分析:</p>
<pre><code>此题不能使用浮点数的比较，而是使用分数的比较性质。
求两个数字的最大公约数，如果存在就跳此数。</code></pre><p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
int check(int n,int m){//求最大公约数的最简单方法
    if (m)//分母不为0
                while ((n %= m) &amp;&amp; (m %= n)) ;
        return n + m;
}
int main()
{
    int n1,m1,n2,m2,k,tmp;
    scanf(&quot;%d/%d %d/%d %d&quot;,&amp;n1,&amp;m1,&amp;n2,&amp;m2,&amp;k);
    if(n1*m2&gt;n2*m1){//如果输入的两个分数大小不为先大后小
         tmp=n1;
         n1=n2;
         n2=tmp;
         tmp=m1;
         m1=m2;
         m2=tmp;
    }
    int time=0;
    tmp=0;
    for(int i=n1*k/m1+1;i*m2&lt;n2*k;i++){//此处不加1可能会导致多输出一个不合适的结果。
        if(check(i,k)==1){//之间没有公约数（除了一以外）
            printf(&quot;%s%d/%d&quot;,time++?&quot; &quot;:&quot;&quot;,i,k);//从0开始计数为0不输出空格，其他输出。
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1059</title>
    <url>/2019/10/07/PTA-Basic-1059/</url>
    <content><![CDATA[<p>题目：<br>C 语言竞赛是浙江大学计算机学院主持的一个欢乐的竞赛。既然竞赛主旨是为了好玩，颁奖规则也就制定得很滑稽：</p>
<p>0、冠军将赢得一份“神秘大奖”（比如很巨大的一本学生研究论文集……）。<br>1、排名为素数的学生将赢得最好的奖品 —— 小黄人玩偶！<br>2、其他人将得到巧克力。<br>给定比赛的最终排名以及一系列参赛者的 ID，你要给出这些参赛者应该获得的奖品。</p>
<p>输入格式：<br>输入第一行给出一个正整数 N（≤10<br>​4<br>​​ ），是参赛者人数。随后 N 行给出最终排名，每行按排名顺序给出一位参赛者的 ID（4 位数字组成）。接下来给出一个正整数 K 以及 K 个需要查询的 ID。</p>
<p>输出格式：<br>对每个要查询的 ID，在一行中输出 ID: 奖品，其中奖品或者是 Mystery Award（神秘大奖）、或者是 Minion（小黄人）、或者是 Chocolate（巧克力）。如果所查 ID 根本不在排名里，打印 Are you kidding?（耍我呢？）。如果该 ID 已经查过了（即奖品已经领过了），打印 ID: Checked（不能多吃多占）。</p>
<p>输入样例：</p>
<pre><code>6
1111
6666
8888
1234
5555
0001
6
8888
0001
1111
2222
8888
2222</code></pre><p>输出样例：</p>
<pre><code>8888: Minion
0001: Chocolate
1111: Mystery Award
2222: Are you kidding?
8888: Checked
2222: Are you kidding?</code></pre><p>分析：题目要求根据输入的排名给出相应的奖品</p>
<pre><code>冠军-----Mystery Award
素数排名-----Minion
其他--------Chocolate
已经输入过一次的人-----Checked
没有的人------Are you kidding?


#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
int pops[2][1000000000];//定义一个二维数组
int isPrime(int n){//判断一个数是否是素数的函数第一行存储排名（从1开始不从0开始因为初始化数组是每个都是0）
    if(n==2){
        return 1;
    }else{
        if(n%2==0){
            return 0;
        }else{
            for(int i=3;i&lt;sqrt(n+1);i+=2){
                if(n%i==0){
                    return 0;
                }
            }
            return 1;
        }
    }
}
int main(void){
    int n=0;
    scanf(&quot;%d&quot;,&amp;n);
    int m=0;
    for(int i=1;i&lt;=n;i++){
        scanf(&quot;%d&quot;,&amp;m);
        pops[0][m]=i;//第一行存储排名，第二行存储查询的次数
    }
    scanf(&quot;%d&quot;,&amp;m);
    int k=0;
    for(int i=0;i&lt;m;i++){
        scanf(&quot;%d&quot;,&amp;k);
        printf(&quot;%04d: &quot;,k);
        if(pops[0][k]==0){//如果输入的数字对应的排名是0就表示选手中没有这个人
            printf(&quot;Are you kidding?&quot;);
        }else if(pops[1][k]==0){//否则如果查询次数为0，即一次都没有看过此人
            if(pops[0][k]==1){//如果排名为1
            printf(&quot;Mystery Award&quot;);
        }else if(isPrime(pops[0][k])){//如果排名是素数
            printf(&quot;Minion&quot;);
        }else{
            printf(&quot;Chocolate&quot;);//其他
        }
        pops[1][k]++;//将此人的查询次数加1
        }else{//下列就是查询次数超过1的输出
            printf(&quot;Checked&quot;);
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1064</title>
    <url>/2019/10/07/PTA-Basic-1064/</url>
    <content><![CDATA[<p>题目：<br>如果两个整数各位数字的和是一样的，则被称为是“朋友数”，而那个公共的和就是它们的“朋友证号”。例如 123 和 51 就是朋友数，因为 1+2+3 = 5+1 = 6，而 6 就是它们的朋友证号。给定一些整数，要求你统计一下它们中有多少个不同的朋友证号。</p>
<p>输入格式：<br>输入第一行给出正整数 N。随后一行给出 N 个正整数，数字间以空格分隔。题目保证所有数字小于 10<br>​4<br>​​ 。</p>
<p>输出格式：<br>首先第一行输出给定数字中不同的朋友证号的个数；随后一行按递增顺序输出这些朋友证号，数字间隔一个空格，且行末不得有多余空格。</p>
<p>输入样例：</p>
<pre><code>8
123 899 51 998 27 33 36 12</code></pre><p>输出样例：</p>
<pre><code>4
3 6 9 26</code></pre><p>分析：<br>因为题目说小于10^4所以所有朋友数最大为36，定义一个数组用下标表示朋友数，存储的数字代表是否出现此朋友数（0为没有出现其他为出现），遍历数组存储的数字依次输出下标。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main()
{
    int n=0;
    scanf(&quot;%d&quot;,&amp;n);
    int m=0;
    int friends[37]={0};
    int time=0;
    for(int i=0;i&lt;n;i++){
        int total=0;
        scanf(&quot;%d&quot;,&amp;m);
        while(m!=0){
            total+=m%10;
            m=m/10;
        }
        if(friends[total]==0){
            time++;
        }
        friends[total]++;
    }
    printf(&quot;%d\n&quot;,time);
    int i=0;
    for(i=0;i&lt;37;i++){
        if(friends[i]&gt;=1){
            printf(&quot;%d&quot;,i);
                if(time&gt;1){
                printf(&quot;%c&quot;,&apos; &apos;);
            }
        time--;
        }

    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1065</title>
    <url>/2019/10/07/PTA-Basic-1065/</url>
    <content><![CDATA[<p>“单身狗”是中文对于单身人士的一种爱称。本题请你从上万人的大型派对中找出落单的客人，以便给予特殊关爱。</p>
<p>输入格式：<br>输入第一行给出一个正整数 N（≤ 50 000），是已知夫妻/伴侣的对数；随后 N 行，每行给出一对夫妻/伴侣——为方便起见，每人对应一个 ID 号，为 5 位数字（从 00000 到 99999），ID 间以空格分隔；之后给出一个正整数 M（≤ 10 000），为参加派对的总人数；随后一行给出这 M 位客人的 ID，以空格分隔。题目保证无人重婚或脚踩两条船。</p>
<p>输出格式：<br>首先第一行输出落单客人的总人数；随后第二行按 ID 递增顺序列出落单的客人。ID 间用 1 个空格分隔，行的首尾不得有多余空格。</p>
<p>输入样例：</p>
<pre><code>3
11111 22222
33333 44444
55555 66666
7
55555 44444 10000 88888 22222 11111 23333</code></pre><p>输出样例：</p>
<pre><code>5
10000 23333 44444 55555 88888</code></pre><p>分析：<br>定义一个情侣数组，男方存储女方的编号，女方存放男方的编号，这样就可以通过一个人找到另一个人，并判断另一个人是否到场。定义一个flag数组用于标记某个人是否到场，定义一个数组用于存放单生狗。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int cmp(const void *a,const void *b){
return *(int *)a-*(int *)b;
}
int main()
{//测试点一是关于对象为0的情况
    int n=0,m=0,x=0,time=0;
    int pops[100000]={-1};/初始化数组，-1表示没有情侣，不能为0，如果为0，那么所有单身狗的情侣都是0.
    int flag[100000]={0};
    scanf(&quot;%d&quot;,&amp;n);
    int n1,n2;
    for(int i=0;i&lt;n;i++){
        scanf(&quot;%d %d&quot;,&amp;n1,&amp;n2);
        pops[n1]=n2;
        pops[n2]=n1;
    }
    scanf(&quot;%d&quot;,&amp;m);
    int result[m];
    int res[m];
    for(int i=0;i&lt;m;i++){
        scanf(&quot;%d&quot;,&amp;x);
        if(pops[x]!=-1){//此处如果将输入的每一个元对应的人都标记的话可能会导致下面去对应值时取到0的人头下标不为0可能会导致数据缺失。
            flag[x]=1;//如果有情侣，才有必要标记到场。
        }
        res[i]=x;
    }
    for(int i=0;i&lt;m;i++){
            x=res[i];
        if(pops[x]==-1){//如果对应的人没有情侣
                result[time]=x;
                time++;
        }else if(flag[x]+flag[pops[x]]!=2){//如果情侣的某一方到场二另一方没有到场，也为单身狗。
                result[time]=x;
                time++;
        }else{

        }
    }
    qsort(result,time,sizeof(int),cmp);//对单身狗进行排序
    printf(&quot;%d\n&quot;,time);
    for(int i=0;i&lt;time;i++){
        printf(&quot;%05d&quot;,result[i]);
        if(i!=time-1){
            printf(&quot; &quot;);
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1067</title>
    <url>/2019/10/07/PTA-Basic-1067/</url>
    <content><![CDATA[<p>题目：</p>
<p>当你试图登录某个系统却忘了密码时，系统一般只会允许你尝试有限多次，当超出允许次数时，账号就会被锁死。本题就请你实现这个小功能。</p>
<p>输入格式：<br>输入在第一行给出一个密码（长度不超过 20 的、不包含空格、Tab、回车的非空字符串）和一个正整数 N（≤ 10），分别是正确的密码和系统允许尝试的次数。随后每行给出一个以回车结束的非空字符串，是用户尝试输入的密码。输入保证至少有一次尝试。当读到一行只有单个 # 字符时，输入结束，并且这一行不是用户的输入。</p>
<p>输出格式：<br>对用户的每个输入，如果是正确的密码且尝试次数不超过 N，则在一行中输出 Welcome in，并结束程序；如果是错误的，则在一行中按格式输出 Wrong password: 用户输入的错误密码；当错误尝试达到 N 次时，再输出一行 Account locked，并结束程序。</p>
<p>输入样例 1：</p>
<pre><code>Correct%pw 3
correct%pw
Correct@PW
whatisthepassword!
Correct%pw
#</code></pre><p>输出样例 1：</p>
<pre><code>Wrong password: correct%pw
Wrong password: Correct@PW
Wrong password: whatisthepassword!
Account locked</code></pre><p>输入样例 2：</p>
<pre><code>cool@gplt 3
coolman@gplt
coollady@gplt
cool@gplt
try again
#</code></pre><p>输出样例 2：</p>
<pre><code>Wrong password: coolman@gplt
Wrong password: coollady@gplt
Welcome in</code></pre><p>分析：</p>
<pre><code>定义一个字符数组存储正确的密码，定义一个数字存储输入次数。
用C语言自带的字符串比较函数，如果结果为0，证明两个字符串相同，即密码正确。
此题目的坑比较多（用户输入密码长度不一定为21以内，且不一定不含空格，如果输入正确或次数已到则禁止输入。）</code></pre><p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char cpw[22]={&apos;\0&apos;};
    int time=0;
    scanf(&quot;%s %d&quot;,cpw,&amp;time);//密码中没有空格
    getchar();//吸取第一行的末尾的回车
    while(1){
        char pw[500]={&apos;\0&apos;};//输入密码的长度不一定为20
        gets(pw);//输入的字符串中可能有空格
        if(strlen(pw)==1&amp;&amp;pw[0]==&apos;#&apos;){
            break;
        }
        if(time&gt;0){
            if(!strcmp(cpw,pw)){
                printf(&quot;Welcome in\n&quot;);
                break;
            }else{
                printf(&quot;Wrong password: %s\n&quot;,pw);
                time--;
            }
        }
        if(time==0){
                printf(&quot;Account locked\n&quot;);
                break;
            }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1069</title>
    <url>/2019/10/07/PTA-Basic-1069/</url>
    <content><![CDATA[<p>题目：</p>
<p>小明 PAT 考了满分，高兴之余决定发起微博转发抽奖活动，从转发的网友中按顺序每隔 N 个人就发出一个红包。请你编写程序帮助他确定中奖名单。</p>
<p>输入格式：<br>输入第一行给出三个正整数 M（≤ 1000）、N 和 S，分别是转发的总量、小明决定的中奖间隔、以及第一位中奖者的序号（编号从 1 开始）。随后 M 行，顺序给出转发微博的网友的昵称（不超过 20 个字符、不包含空格回车的非空字符串）。</p>
<p>注意：可能有人转发多次，但不能中奖多次。所以如果处于当前中奖位置的网友已经中过奖，则跳过他顺次取</p>
<p>下一位。</p>
<p>输出格式：</p>
<p>按照输入的顺序输出中奖名单，每个昵称占一行。如果没有人中奖，则输出 Keep going…。</p>
<p>输入样例 1：</p>
<pre><code>9 3 2
Imgonnawin!
PickMe
PickMeMeMeee
LookHere
Imgonnawin!
TryAgainAgain
TryAgainAgain
Imgonnawin!
TryAgainAgain</code></pre><p>输出样例 1：</p>
<pre><code>PickMe
Imgonnawin!
TryAgainAgain</code></pre><p>输入样例 2：</p>
<pre><code>2 3 5
Imgonnawin!
PickMe</code></pre><p>输出样例 2：</p>
<pre><code>Keep going...</code></pre><p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
char result[1000][21];
int check(char *str,int t){
    for(int j=0;j&lt;t;j++){
        if(strcmp(str,result[j])==0){//比较人数数组中是否已经有这个人了
            return 1;
        }
    }
    return 0;
}
int main()
{
    int m,n,s;
    scanf(&quot;%d%d%d&quot;,&amp;m,&amp;n,&amp;s);
    char str[21];
    int t=0;//用来存储有多少人得奖。
    for(int i=1;i&lt;=m;i++){
            scanf(&quot;%s&quot;,str);
            getchar();
        if(i==s){
                if(check(str,t)){//此人已经转发过了
                    s=s+1;//看看它的下一个人是否合适
                    continue;
                }else{
                    strcpy(result[t++],str);//此人没有转发过，就存入数组。
                    s=s+n;//并且到下一个相隔n的人。
                }
        }
    }
    if(t==0){
        printf(&quot;Keep going...&quot;);
    }else{
        for(int i=0;i&lt;t;i++){
            puts(result[i]);
        }
        }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1066</title>
    <url>/2019/10/07/PTA-Basic-1066/</url>
    <content><![CDATA[<p>题目：<br>图像过滤是把图像中不重要的像素都染成背景色，使得重要部分被凸显出来。现给定一幅黑白图像，要求你将灰度值位于某指定区间内的所有像素颜色都用一种指定的颜色替换。</p>
<p>输入格式：<br>输入在第一行给出一幅图像的分辨率，即两个正整数 M 和 N（0&lt;M,N≤500），另外是待过滤的灰度值区间端点 A 和 B（0≤A&lt;B≤255）、以及指定的替换灰度值。随后 M 行，每行给出 N 个像素点的灰度值，其间以空格分隔。所有灰度值都在 [0, 255] 区间内。</p>
<p>输出格式：<br>输出按要求过滤后的图像。即输出 M 行，每行 N 个像素灰度值，每个灰度值占 3 位（例如黑色要显示为 000），其间以一个空格分隔。行首尾不得有多余空格。</p>
<p>输入样例：</p>
<pre><code>3 5 100 150 0
3 189 254 101 119
150 233 151 99 100
88 123 149 0 255</code></pre><p>输出样例：</p>
<pre><code>003 189 254 000 000
000 233 151 099 000
088 000 000 000 255</code></pre><p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    int n=0,m=0,a=0,b=0,replace=0,h=0;
    scanf(&quot;%d %d %d %d %d&quot;,&amp;m,&amp;n,&amp;a,&amp;b,&amp;replace);
    int dlex[m][n];
    for(int i=0;i&lt;m;i++){
        for(int j=0;j&lt;n;j++){
            scanf(&quot;%d&quot;,&amp;h);
            if(h&lt;=b&amp;&amp;h&gt;=a){
                h=replace;
            }
            dlex[i][j]=h;
        }
    }
    for(int i=0;i&lt;m;i++){
        for(int j=0;j&lt;n;j++){
            printf(&quot;%03d&quot;,dlex[i][j]);
            if(j!=n-1){
                printf(&quot; &quot;);
            }
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1061</title>
    <url>/2019/10/07/PTA-Basic-1061/</url>
    <content><![CDATA[<p>题目：</p>
<p>判断题的评判很简单，本题就要求你写个简单的程序帮助老师判题并统计学生们判断题的得分。</p>
<p>输入格式：<br>输入在第一行给出两个不超过 100 的正整数 N 和 M，分别是学生人数和判断题数量。第二行给出 M 个不超过 5 的正整数，是每道题的满分值。第三行给出每道题对应的正确答案，0 代表“非”，1 代表“是”。随后 N 行，每行给出一个学生的解答。数字间均以空格分隔。</p>
<p>输出格式：</p>
<p>按照输入的顺序输出每个学生的得分，每个分数占一行。</p>
<p>输入样例：</p>
<pre><code>3 6
2 1 3 3 4 5
0 0 1 0 1 1
0 1 1 0 0 1
1 0 1 0 1 0
1 1 0 0 1 1</code></pre><p>输出样例：</p>
<pre><code>13
11
12</code></pre><p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int n=0,m=0;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    int score[2][m];
    int stu[n];
    int k=0;
    int x=0;
    for(int i=0;i&lt;n+2;i++){
            stu[x]=0;
        for(int j=0;j&lt;m;j++){
                scanf(&quot;%d&quot;,&amp;k);
            if(i==0){
            score[0][j]=k;
        }else if(i==1){
            score[1][j]=k;
        }else{
            if(k==score[1][j]){
                stu[x]+=score[0][j];
            }
        }
        }
        if(i!=0&amp;&amp;i!=1){
            x++;
        }
    }

    for(int i=0;i&lt;x;i++){
            printf(&quot;%d\n&quot;,stu[i]);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1070</title>
    <url>/2019/10/07/PTA-Basic-1070/</url>
    <content><![CDATA[<p>题目：</p>
<p>给定一段一段的绳子，你需要把它们串成一条绳。每次串连的时候，是把两段绳子对折，再如下图所示套接在一起。这样得到的绳子又被当成是另一段绳子，可以再次对折去跟另一段绳子串连。每次串连后，原来两段绳子的长度就会减半。</p>
<p><img src="https://images.ptausercontent.com/46293e57-aa0e-414b-b5c3-7c4b2d5201e2.jpg" alt=""></p>
<p>给定 N 段绳子的长度，你需要找出它们能串成的绳子的最大长度。</p>
<p>输入格式：<br>每个输入包含 1 个测试用例。每个测试用例第 1 行给出正整数 N (2≤N≤10<br>​4<br>​​ )；第 2 行给出 N 个正整数，即原始绳段的长度，数字间以空格分隔。所有整数都不超过10<br>​4<br>​​ 。</p>
<p>输出格式：<br>在一行中输出能够串成的绳子的最大长度。结果向下取整，即取为不超过最大长度的最近整数。</p>
<p>输入样例：</p>
<pre><code>8
10 15 12 3 4 13 1 15</code></pre><p>输出样例：</p>
<pre><code>14</code></pre><p>思路：排序从小到大，不断折半。<br>代码:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int cmp(const void *a,const void *b){
return *(int *)a-*(int *)b;
}
int main()
{

    int n=0;

    scanf(&quot;%d&quot;,&amp;n);

    int nums[n];

    for(int i=0;i&lt;n;i++){
        scanf(&quot;%d&quot;,&amp;nums[i]);
    }

    qsort(nums,n,sizeof(int),cmp);

    int max=nums[0];

    for(int i=1;i&lt;n;i++){

        max=(max+nums[i])/2;

    }

    printf(&quot;%d&quot;,max);

    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1068</title>
    <url>/2019/10/07/PTA-Basic-1068/</url>
    <content><![CDATA[<p>题目:<br>对于计算机而言，颜色不过是像素点对应的一个 24 位的数值。现给定一幅分辨率为 M×N 的画，要求你找出万绿丛中的一点红，即有独一无二颜色的那个像素点，并且该点的颜色与其周围 8 个相邻像素的颜色差充分大。</p>
<p>输入格式：<br>输入第一行给出三个正整数，分别是 M 和 N（≤ 1000），即图像的分辨率；以及 TOL，是所求像素点与相邻点的颜色差阈值，色差超过 TOL 的点才被考虑。随后 N 行，每行给出 M 个像素的颜色值，范围在 [0,2<br>​24<br>​​ ) 内。所有同行数字间用空格或 TAB 分开。</p>
<p>输出格式：<br>在一行中按照 (x, y): color 的格式输出所求像素点的位置以及颜色值，其中位置 x 和 y 分别是该像素在图像矩阵中的列、行编号（从 1 开始编号）。如果这样的点不唯一，则输出 Not Unique；如果这样的点不存在，则输出 Not Exist。</p>
<p>输入样例 1：</p>
<pre><code>8 6 200
0      0       0        0        0          0           0        0
65280      65280    65280    16711479 65280    65280    65280    65280
16711479 65280    65280    65280    16711680 65280    65280    65280
65280      65280    65280    65280    65280    65280    165280   165280
65280      65280       16777015 65280    65280    165280   65480    165280
16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215</code></pre><p>输出样例 1：</p>
<pre><code>(5, 3): 16711680</code></pre><p>输入样例 2：</p>
<pre><code>4 5 2
0 0 0 0
0 0 3 0
0 0 0 0
0 5 0 0
0 0 0 0</code></pre><p>输出样例 2：</p>
<pre><code>Not Unique</code></pre><p>输入样例 3：</p>
<pre><code>3 3 5
1 2 3
3 4 5
5 6 7</code></pre><p>输出样例 3：</p>
<pre><code>Not Exist</code></pre><p>分析：定义一个足够大的数组用来存储像素点的次数，定义一个结构体用来表示像素点（有坐标，数值），每输入一个像素数值，就存入对应的像素点二维数组中，并在记录次数的数组中加1，然后定义一个判断像素点是否合格的函数，对每个像素点判断是否合格，并且是否只有一个。当这样的点超过1个是就可以不用继续找了。<br>此题目的一个坑就是在所有的点中查找独特的点不管它是否合格，再再独特的点中找合格的个数。而我陷入了这个坑认为不合格的像素点不用加到次数数组中。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include&lt;math.h&gt;
//定义一个二维数组存储像素点
//定义结构体存储合格的像素点，与坐标，次数，一共有多少个像素点
int map[2&lt;&lt;24]={0};
int pixels[1000][1000]={0};
typedef struct pixel{
    int x;
    int y;
    int id;
}pixel;
int check(int i,int j,int n,int m,int tol);
int main()
{
    int m,n,tol;//仿佛数组数目太大的变量只能声明为 全局变量，否则程序不会执行 
    scanf(&quot;%d %d %d&quot;,&amp;m,&amp;n,&amp;tol);
    for(int i=0;i&lt;n;i++){
        for(int j=0;j&lt;m;j++){
            scanf(&quot;%d&quot;,&amp;pixels[i][j]);
            map[pixels[i][j]]++;//将对应的像素点的个数加1.
        }
    }
    int time=0,x=0,y=0,id=0;//time用来记录独特点的个数
    for(int i=0;i&lt;n;i++){
        for(int j=0;j&lt;m;j++){
            if(map[pixels[i][j]]==1&amp;&amp;check(i,j,n,m,tol)){
                y=j+1;
                x=i+1;
                id=pixels[i][j];
                time++;
            }
            if(time==2){//优化当数目超过二是直接跳出循环
                break;
            }
        }
    }
        if(time==0){
            printf(&quot;Not Exist&quot;);
        }else if(time==1){
            printf(&quot;(%d, %d): %d&quot;,y,x,id);
        }else{
            printf(&quot;Not Unique&quot;);
        }
    return 0;
}
int check(int i,int j,int n,int m,int tol){//判断是否合格函数，有左上就看左上，没有就不看，其他一样。
            if(i-1&gt;=0&amp;&amp;j-1&gt;=0&amp;&amp;abs(pixels[i][j]-pixels[i-1][j-1])&lt;=tol){return 0;}//左上
            if(j-1&gt;=0&amp;&amp;abs(pixels[i][j]-pixels[i][j-1])&lt;=tol){return 0;}//左
            if(i+1&lt;n&amp;&amp;j-1&gt;=0&amp;&amp;abs(pixels[i][j]-pixels[i+1][j-1])&lt;=tol){return 0;}//左下
            if(i-1&gt;=0&amp;&amp;abs(pixels[i][j]-pixels[i-1][j])&lt;=tol){return 0;}//上
            if(i+1&lt;n&amp;&amp;abs(pixels[i][j]-pixels[i+1][j])&lt;=tol){return 0;}//下
            if(i-1&gt;=0&amp;&amp;j+1&lt;m&amp;&amp;abs(pixels[i][j]-pixels[i-1][j+1])&lt;=tol){return 0;}//右上
            if(j+1&lt;m&amp;&amp;abs(pixels[i][j]-pixels[i][j+1])&lt;=tol){return 0;}//右
            if(i+1&lt;n&amp;&amp;j+1&lt;m&amp;&amp;abs(pixels[i][j]-pixels[i+1][j+1])&lt;=tol){return 0;}
            return 1;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1071</title>
    <url>/2019/10/08/PTA-Basic-1071/</url>
    <content><![CDATA[<p>题目：</p>
<p>常言道“小赌怡情”。这是一个很简单的小游戏：首先由计算机给出第一个整数；然后玩家下注赌第二个整数将会比第一个数大还是小；玩家下注 t 个筹码后，计算机给出第二个数。若玩家猜对了，则系统奖励玩家 t 个筹码；否则扣除玩家 t 个筹码。</p>
<p>注意：玩家下注的筹码数不能超过自己帐户上拥有的筹码数。当玩家输光了全部筹码后，游戏就结束。</p>
<p>输入格式：<br>输入在第一行给出 2 个正整数 T 和 K（≤ 100），分别是系统在初始状态下赠送给玩家的筹码数、以及需要处理的游戏次数。随后 K 行，每行对应一次游戏，顺序给出 4 个数字：</p>
<p>n1 b t n2<br>其中 n1 和 n2 是计算机先后给出的两个[0, 9]内的整数，保证两个数字不相等。b 为 0 表示玩家赌小，为 1 表示玩家赌大。t 表示玩家下注的筹码数，保证在整型范围内。</p>
<p>输出格式：<br>对每一次游戏，根据下列情况对应输出（其中 t 是玩家下注量，x 是玩家当前持有的筹码量）：</p>
<p>玩家赢，输出 Win t!  Total = x.；<br>玩家输，输出 Lose t.  Total = x.；<br>玩家下注超过持有的筹码量，输出 Not enough tokens.  Total = x.；<br>玩家输光后，输出 Game Over. 并结束程序。<br>输入样例 1：</p>
<pre><code>100 4
8 0 100 2
3 1 50 1
5 1 200 6
7 0 200 8</code></pre><p>输出样例 1：</p>
<pre><code>Win 100!  Total = 200.
Lose 50.  Total = 150.
Not enough tokens.  Total = 150.
Not enough tokens.  Total = 150.</code></pre><p>输入样例 2：</p>
<pre><code>100 4
8 0 100 2
3 1 200 1
5 1 200 6
7 0 200 8</code></pre><p>输出样例 2：</p>
<pre><code>Win 100!  Total = 200.
Lose 200.  Total = 0.
Game Over.</code></pre><p>分析：依据题目思考即可。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    int total,k;
    int n1,n2,b,t;
    scanf(&quot;%d %d&quot;,&amp;total,&amp;k);//存储总的筹码数，与游戏可能执行的最大次数
    for(int i=0;i&lt;k;i++){
    scanf(&quot;%d %d %d %d&quot;,&amp;n1,&amp;b,&amp;t,&amp;n2);
    if(t&gt;total){//判断如果此次的下注的筹码数大于自己有的，则跳过，继续下一次游戏。
        printf(&quot;Not enough tokens.  Total = %d.\n,total);
        continue;
    }
    int boolean=(n2&gt;n1);//用boolean存储n2是否大于n1
        if(boolean==b){//如果boolean 和猜的一样的则赢了此局
            total+=t;
            printf(&quot;Win %d!  Total = %d.\n&quot;,t,total);
        }else{//输了
            total-=t;//减去筹码，不用担心筹码为负数，因为下注数不可能大于筹码。
            printf(&quot;Lose %d.  Total = %d.\n&quot;,t,total);
            if(total==0){//如果扣去下注后的筹码为0，则结束游戏。
                printf(&quot;Game Over.\n&quot;);
                break;
            }
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1075</title>
    <url>/2019/10/16/PTA-Basic-1075/</url>
    <content><![CDATA[<p>题目：</p>
<p>给定一个单链表，请编写程序将链表元素进行分类排列，使得所有负值元素都排在非负值元素的前面，而 [0, K] 区间内的元素都排在大于 K 的元素前面。但每一类内部元素的顺序是不能改变的。例如：给定链表为 18→7→-4→0→5→-6→10→11→-2，K 为 10，则输出应该为 -4→-6→-2→7→0→5→10→18→11。</p>
<p>输入格式：<br>每个输入包含一个测试用例。每个测试用例第 1 行给出：第 1 个结点的地址；结点总个数，即正整数N (≤10^5 )；以及正整数K (≤10^3)。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。</p>
<p>接下来有 N 行，每行格式为：</p>
<p>Address Data Next<br>其中 Address 是结点地址；Data 是该结点保存的数据，为 [−10^5​,10^5] 区间内的整数；Next 是下一结点的地址。题目保证给出的链表不为空。</p>
<p>输出格式：<br>对每个测试用例，按链表从头到尾的顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。</p>
<p>输入样例：</p>
<pre><code>00100 9 10
23333 10 27777
00000 0 99999
00100 18 12309
68237 -6 23333
33218 -4 00000
48652 -2 -1
99999 5 68237
27777 11 48652
12309 7 33218</code></pre><p>输出样例：</p>
<pre><code>33218 -4 68237
68237 -6 48652
48652 -2 12309
12309 7 00000
00000 0 99999
99999 5 23333
23333 10 00100
00100 18 27777
27777 11 -1</code></pre><p>思路：分三次，每次找合适的数据。<br>代码：</p>
<pre><code>#include&lt;stdio.h&gt;

int main()
{
  int iNext=0,iN=0,iK=0;//对应的是首地址，节点的个数，K的值
  int iData[100000][2]={0};//用一个足够大的数组存放数据以及下一个节点的地址，下标就是它的地址
  scanf(&quot;%d%d%d&quot;,&amp;iNext,&amp;iN,&amp;iK);//输入信息
  int iAddr=0,iNum=0,iNAddr=0;
  for(int i=0;i&lt;iN;i++)
  {
    scanf(&quot;%d%d%d&quot;,&amp;iAddr,&amp;iNum,&amp;iNAddr);//存放当前地址，数据，下一个节点的地址
    iData[iAddr][0]=iNum;//存放数据
    iData[iAddr][1]=iNAddr;//存放下一节点地址
  }
  int iOrder[iN];//存放排序好的地址
  int p=0,next=iNext;
  //3次遍历筛选排序
  while(next!=-1)//第一次从首地址出发找出负数的地址。
  {
    if(iData[next][0]&lt;0)//当前节点的数据
    {
      iOrder[p++]=next;
    }
    next=iData[next][1];//将地址存放下一个节点的地址
  }
  next=iNext;//继续从首地址出发
  while(next!=-1)//第二次找&lt;=K的非负数
  {
    if(iData[next][0]&gt;=0&amp;&amp;iData[next][0]&lt;=iK)
    {
      iOrder[p++]=next;
    }
    next=iData[next][1];
  }
  next=iNext;
  while(next!=-1)//第三次找大于等于K的数据
  {
    if(iData[next][0]&gt;iK)
    {
      iOrder[p++]=next;
    }
    next=iData[next][1];
  }
  //循环输出，注意控制范围
  for(int i=0;i&lt;p-1;i++)
  {
    printf(&quot;%05d %d %05d\n&quot;,iOrder[i],iData[iOrder[i]][0],iOrder[i+1]);//输出地址，地址对应的数据以及下一个地址。
  }
  printf(&quot;%05d %d -1&quot;,iOrder[p-1],iData[iOrder[p-1]][0]);//最后一个节点的数据直接输出，并输出-1表示结束。
  return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1072</title>
    <url>/2019/10/08/PTA-Basic-1072/</url>
    <content><![CDATA[<p>题目：<br>下图是上海某校的新学期开学寄语：天将降大任于斯人也，必先删其微博，卸其 QQ，封其电脑，夺其手机，收其 ipad，断其 wifi，使其百无聊赖，然后，净面、理发、整衣，然后思过、读书、锻炼、明智、开悟、精进。而后必成大器也！</p>
<p><img src="https://images.ptausercontent.com/3b1d9f4a-778b-4942-a9e2-836262f363aa.JPG" alt="嘿嘿嘿"></p>
<p>本题要求你写个程序帮助这所学校的老师检查所有学生的物品，以助其成大器。</p>
<p>输入格式：</p>
<p>输入第一行给出两个正整数 N（≤ 1000）和 M（≤ 6），分别是学生人数和需要被查缴的物品种类数。第二行<br>给出 M 个需要被查缴的物品编号，其中编号为 4 位数字。随后 N 行，每行给出一位学生的姓名缩写（由 1-4 个大写英文字母组成）、个人物品数量 K（0 ≤ K ≤ 10）、以及 K 个物品的编号。</p>
<p>输出格式：<br>顺次检查每个学生携带的物品，如果有需要被查缴的物品存在，则按以下格式输出该生的信息和其需要被查缴的物品的信息（注意行末不得有多余空格）：</p>
<p>姓名缩写: 物品编号1 物品编号2 ……<br>最后一行输出存在问题的学生的总人数和被查缴物品的总数。</p>
<p>输入样例：</p>
<pre><code>4 2
2333 6666
CYLL 3 1234 2345 3456
U 4 9966 6666 8888 6666
GG 2 2333 7777
JJ 3 0012 6666 2333</code></pre><p>输出样例：</p>
<pre><code>U: 6666 6666
GG: 2333
JJ: 6666 2333
3 5</code></pre><p>分析：<br>定义一个图，存储被禁止的编号，然后对每一个输入判断，如果有不允许的，就标记一下此人，输入此人的姓名，与违禁品。注意输出格式为4位</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int forbid[10000]={0};
    int n,m,temp,k;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    for(int i=0;i&lt;m;i++){
        scanf(&quot;%d&quot;,&amp;temp);
        forbid[temp]=1;
    }
    int sum=0,fsum=0;
    for(int i=0;i&lt;n;i++){
        char name[5]={&apos;\0&apos;};
        scanf(&quot;%s %d&quot;,name,&amp;k);
        int flag=0;
        for(int j=0;j&lt;k;j++){
            scanf(&quot;%d&quot;,&amp;temp);
            if(forbid[temp]){
                if(!flag){
                    flag=1;
                    printf(&quot;%s:&quot;,name);
                    sum++;
                }
                printf(&quot; %04d&quot;,temp);
                fsum++;
            }
        }
        if(flag){
            printf(&quot;\n&quot;);
        }
    }
    printf(&quot;%d %d&quot;,sum,fsum);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1076</title>
    <url>/2019/10/09/PTA-Basic-1076/</url>
    <content><![CDATA[<p>题目：</p>
<p>下面是微博上流传的一张照片：“各位亲爱的同学们，鉴于大家有时需要使用 wifi，又怕耽误亲们的学习，现将 wifi 密码设置为下列数学题答案：A-1；B-2；C-3；D-4；请同学们自己作答，每两日一换。谢谢合作！！~”—— 老师们为了促进学生学习也是拼了…… 本题就要求你写程序把一系列题目的答案按照卷子上给出的对应关系翻译成 wifi 的密码。这里简单假设每道选择题都有 4 个选项，有且只有 1 个正确答案。</p>
<p><img src="https://images.ptausercontent.com/7e56be3f-caba-45f1-b9cb-38a96d44de76.jpg" alt=""></p>
<p>输入格式：<br>输入第一行给出一个正整数 N（≤ 100），随后 N 行，每行按照 编号-答案 的格式给出一道题的 4 个选项，T 表示正确选项，F 表示错误选项。选项间用空格分隔。</p>
<p>输出格式：<br>在一行中输出 wifi 密码。</p>
<p>输入样例：</p>
<pre><code>8
A-T B-F C-F D-F
C-T B-F A-F D-F
A-F D-F C-F B-T
B-T A-F C-F D-F
B-F D-T A-F C-F
A-T C-F B-F D-F
D-T B-F C-F A-F
C-T A-F B-F D-F</code></pre><p>输出样例：</p>
<pre><code>13224143</code></pre><p>直接对每对字符判断因为输入的一个题目的答案只有一个所有直接判断并输出对应的数字。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main()
{
    int n=0;
    scanf(&quot;%d&quot;,&amp;n);
    char ch1,ch2;
    getchar();//吸收换行符
    for(int i=0;i&lt;n;i++){
        for(int j=0;j&lt;4;j++){
            scanf(&quot;%c-%c&quot;,&amp;ch1,&amp;ch2);
            getchar();//吸收空格与换行符
            if(ch2==&apos;T&apos;){
                    int re=0;
                switch(ch1){
                    case &apos;A&apos;:re=1;break;
                    case &apos;B&apos;:re=2;break;
                    case &apos;C&apos;:re=3;break;
                    case &apos;D&apos;:re=4;break;
                }
                printf(&quot;%d&quot;,re);
            }
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1078</title>
    <url>/2019/10/11/PTA-Basic-1078/</url>
    <content><![CDATA[<p>题目：<br>文本压缩有很多种方法，这里我们只考虑最简单的一种：把由相同字符组成的一个连续的片段用这个字符和片段中含有这个字符的个数来表示。例如 ccccc 就用 5c 来表示。如果字符没有重复，就原样输出。例如 aba 压缩后仍然是 aba。</p>
<p>解压方法就是反过来，把形如 5c 这样的表示恢复为 ccccc。</p>
<p>本题需要你根据压缩或解压的要求，对给定字符串进行处理。这里我们简单地假设原始字符串是完全由英文字母和空格组成的非空字符串。</p>
<p>输入格式：<br>输入第一行给出一个字符，如果是 C 就表示下面的字符串需要被压缩；如果是 D 就表示下面的字符串需要被解压。第二行给出需要被压缩或解压的不超过 1000 个字符的字符串，以回车结尾。题目保证字符重复个数在整型范围内，且输出文件不超过 1MB。</p>
<p>输出格式：<br>根据要求压缩或解压字符串，并在一行中输出结果。</p>
<p>输入样例 1：</p>
<pre><code>C

TTTTThhiiiis isssss a   tesssst CAaaa as</code></pre><p>输出样例 1：</p>
<pre><code>5T2h4is i5s a3 te4st CA3a as</code></pre><p>输入样例 2：</p>
<pre><code>D

5T2h4is i5s a3 te4st CA3a as10Z</code></pre><p>输出样例 2：</p>
<pre><code>TTTTThhiiiis isssss a   tesssst CAaaa asZZZZZZZZZZ</code></pre><p>分析：</p>
<p>首先根据题目要求知道要求我们解压与压缩，解压-&gt;将字符串中的数字转换成其后面紧跟的字符的个数，注</p>
<p>意，此处数字可能大于10。然后输出n个字符。</p>
<p>压缩过程：将连续的n个字符（n&gt;1）表达成‘n字符’的形式。</p>
<p>注意：此题的一个坑，输入中可能会有空格。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include&lt;string.h&gt;
#include &lt;stdlib.h&gt;
void c(char *s){//压缩函数
    char *p=s;
    char cur=*p;//保存当前的字符
    p++;
    int time=1;//默认的字符长度为1
    while(cur){
        char ch=*p;//存储下一个字符
        if(cur==ch){//当前字符与下一个字符比较
            time++;
        }else{//不同时，表示连续的已经断开
            if(time&gt;1){
                printf(&quot;%d%c&quot;,time,cur);
            }else{
                printf(&quot;%c&quot;,cur);
            }
            time=1;//重新将字符设置为1
            cur=ch;//将后一个字符给当前字符。
        }
        p++;//指针指向后面一个字符。
    }
}
void d(char *s){//解压
    char *p=s;
    int time=0;
    while(*p){
        if((*p)&lt;=&apos;9&apos;&amp;&amp;(*p)&gt;=&apos;0&apos;){//将字符串中的数字转化为int型。
            time=time*10+(*p)-&apos;0&apos;;//
        }else
        {
            if(time==0){//如果此处不给time赋值为1，且time==0，那么字母前面没有数字的就会被丢掉。
                time=1;
            }
            for(int i=0;i&lt;time;i++){
                printf(&quot;%c&quot;,*p);
            }
            time=0;//防止遇到数字为两位或更高位的。
        }
        p++;
    }
}
int main()
{
    char ch;
    scanf(&quot;%c&quot;,&amp;ch);
    getchar();
    char str[1001];
    gets(str);
    switch(ch){
    case &apos;C&apos;:c(str);break;
    case &apos;D&apos;:d(str);break;
    default:break;
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1074</title>
    <url>/2019/10/09/PTA-Basic-1074/</url>
    <content><![CDATA[<p>分析：<br>地球人习惯使用十进制数，并且默认一个数字的每一位都是十进制的。而在 PAT 星人开挂的世界里，每个数字的每一位都是不同进制的，这种神奇的数字称为“PAT数”。每个 PAT 星人都必须熟记各位数字的进制表，例如“……0527”就表示最低位是 7 进制数、第 2 位是 2 进制数、第 3 位是 5 进制数、第 4 位是 10 进制数，等等。每一位的进制 d 或者是 0（表示十进制）、或者是 [2，9] 区间内的整数。理论上这个进制表应该包含无穷多位数字，但从实际应用出发，PAT 星人通常只需要记住前 20 位就够用了，以后各位默认为 10 进制。</p>
<p>在这样的数字系统中，即使是简单的加法运算也变得不简单。例如对应进制表“0527”，该如何计算“6203 + 415”呢？我们得首先计算最低位：3 + 5 = 8；因为最低位是 7 进制的，所以我们得到 1 和 1 个进位。第 2 位是：0 + 1 + 1（进位）= 2；因为此位是 2 进制的，所以我们得到 0 和 1 个进位。第 3 位是：2 + 4 + 1（进位）= 7；因为此位是 5 进制的，所以我们得到 2 和 1 个进位。第 4 位是：6 + 1（进位）= 7；因为此位是 10 进制的，所以我们就得到 7。最后我们得到：6203 + 415 = 7201。</p>
<p>输入格式：<br>输入首先在第一行给出一个 N 位的进制表（0 &lt; N ≤ 20），以回车结束。 随后两行，每行给出一个不超过 N 位的非负的 PAT 数。</p>
<p>输出格式：<br>在一行中输出两个 PAT 数之和。</p>
<p>输入样例：</p>
<pre><code>30527
06203
415</code></pre><p>输出样例：</p>
<pre><code>7201</code></pre><p>分析：<br>将输入的字符串存入字符数组，定义一个逆转字符串的函数，将每个字符串逆转，然后从头取对应的数字加起来在加上上一次运算的进数，然后对进制取余存入结果数组，取整作为下一次的进数，注意循环的次数，应该比进制字符串的长度大1，为了防止最高项加后超过进制数而导致进项丢失。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
char decimal[21];
char str1[21];
char str2[21];
char result[22];
char* strrev(char *str){//字符逆置函数。
    char *cs1=str;
    char *cs2=str+(strlen(str)-1);
    while(cs1&lt;cs2){
        char ch=*cs1;
        *cs1=*cs2;
        *cs2=ch;
        cs1++;
        cs2--;
    }
    return str;
}
int main()
{
    gets(decimal);//输入进制
    gets(str1);//输入数字1
    gets(str2);//输入数字2
    char *pdecimal=strrev(decimal);//逆置进制
    char *pstr1=strrev(str1);//逆置数字1
    char *pstr2=strrev(str2);//逆置数字2
    int max=strlen(decimal);//存储最大的字符长度。
    int next=0;
    for(int i=0;i&lt;max+1;i++){
            int n=0,m=0,k=0;
            if(pstr1[i]!=&apos;\0&apos;){//第一个数字的一位
                n=pstr1[i]-&apos;0&apos;;
            }
            if(pstr2[i]!=&apos;\0&apos;){//第二个数字的一位
                m=pstr2[i]-&apos;0&apos;;
            }
            if(pdecimal[i]==&apos;0&apos;){//当i达到max时k变为‘\0’-&apos;0&apos;=-48，而其他数字（不小于-48）对其取还是其他数字任何数字对负数取余的结果是那个数字对对应的整数取余的结果。
                k=10;
            }else{
                k=pdecimal[i]-&apos;0&apos;;
            }
            result[i]=(n+m+next)%k+&apos;0&apos;;
            next=(n+m+next)/k;
    }
    char *presult=strrev(result);
        while(*presult==&apos;0&apos;){//将开头的0都去掉，直到找到不为0的数字
        presult++;
    }
    if(strlen(presult)&gt;0)
     printf(&quot;%s&quot;,presult);
    else//测试点5为所有位数都是0，这是会去掉所有位数上的0，而导致字符串为0.长度为0，此时只需输出一个0即可。
        printf(&quot;0&quot;);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1081</title>
    <url>/2019/10/11/PTA-Basic-1081/</url>
    <content><![CDATA[<p>题目：</p>
<p>本题要求你帮助某网站的用户注册模块写一个密码合法性检查的小功能。该网站要求用户设置的密码必须由不少于6个字符组成，并且只能有英文字母、数字和小数点 .，还必须既有字母也有数字。</p>
<p>输入格式：<br>输入第一行给出一个正整数 N（≤ 100），随后 N 行，每行给出一个用户设置的密码，为不超过 80 个字符的非空字符串，以回车结束。</p>
<p>输出格式：<br>对每个用户的密码，在一行中输出系统反馈信息，分以下5种：</p>
<p>如果密码合法，输出Your password is wan mei.；<br>如果密码太短，不论合法与否，都输出Your password is tai duan le.；<br>如果密码长度合法，但存在不合法字符，则输出Your password is tai luan le.；<br>如果密码长度合法，但只有字母没有数字，则输出Your password needs shu zi.；<br>如果密码长度合法，但只有数字没有字母，则输出Your password needs zi mu.。<br>输入样例：</p>
<pre><code>5
123s
zheshi.wodepw
1234.5678
WanMei23333
pass*word.6</code></pre><p>输出样例：</p>
<pre><code>Your password is tai duan le.
Your password needs shu zi.
Your password needs zi mu.
Your password is wan mei.
Your password is tai luan le.</code></pre><p>代码：<br>#include&lt;stdio.h&gt;<br>#include&lt;string.h&gt;<br>int main(void){<br>    int n;<br>    scanf(“%d”,&amp;n);//测试点二，是第一行的末尾的空格输入下一个。<br>    //scanf()函数则会保留换行符所以必须用getchar()吸收，防止作为一个输入行。<br>    getchar();<br>    char password[85];<br>    for(int i=0;i&lt;n;i++){<br>        int zifuflag=0;<br>        int zimuflag=0;<br>        int shuziflag=0;<br>        gets(password);//gets()函数会将换行符转换为‘\0’输入字符数组。<br>        int len=strlen(password);<br>        if(len&lt;6){<br>            printf(“Your password is tai duan le.\n”);<br>            continue;<br>        }<br>        for(int j=0;j&lt;len;j++){<br>            char ch=password[j];<br>            if((ch&gt;=’a’&amp;&amp;ch&lt;=’z’)||(ch&gt;=’A’&amp;&amp;ch&lt;=’Z’)){<br>                zimuflag=1;<br>            }<br>            if(ch&gt;=’0’&amp;&amp;ch&lt;=’9’){<br>                shuziflag=1;<br>            }<br>            if(ch!=’.’&amp;&amp;!(ch&lt;=’9’&amp;&amp;ch&gt;=’0’)&amp;&amp;!((ch&gt;=’a’&amp;&amp;ch&lt;=’z’)||(ch&gt;=’A’&amp;&amp;ch&lt;=’Z’))){<br>                zifuflag=1;<br>                break;<br>            }<br>        }<br>        if(zifuflag){<br>            printf(“Your password is tai luan le.\n”);<br>            continue;<br>        }<br>        if(zimuflag&amp;&amp;!shuziflag){<br>            printf(“Your password needs shu zi.\n”);<br>            continue;<br>        }<br>        if(!zimuflag&amp;&amp;shuziflag){<br>            printf(“Your password needs zi mu.\n”);<br>            continue;<br>        }<br>        if(zimuflag&amp;&amp;shuziflag){<br>            printf(“Your password is wan mei.\n”);<br>        }<br>    }<br>}</p>
]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1082</title>
    <url>/2019/10/11/PTA-Basic-1082/</url>
    <content><![CDATA[<p>题目：</p>
<p>本题目给出的射击比赛的规则非常简单，谁打的弹洞距离靶心最近，谁就是冠军；谁差得最远，谁就是菜鸟。本题给出一系列弹洞的平面坐标(x,y)，请你编写程序找出冠军和菜鸟。我们假设靶心在原点(0,0)。</p>
<p>输入格式：<br>输入在第一行中给出一个正整数 N（≤ 10 000）。随后 N 行，每行按下列格式给出：</p>
<p>ID x y<br>其中 ID 是运动员的编号（由 4 位数字组成）；x 和 y 是其打出的弹洞的平面坐标(x,y)，均为整数，且 0 ≤ |x|, |y| ≤ 100。题目保证每个运动员的编号不重复，且每人只打 1 枪。</p>
<p>输出格式：<br>输出冠军和菜鸟的编号，中间空 1 格。题目保证他们是唯一的。</p>
<p>输入样例：</p>
<pre><code>3
0001 5 7
1020 -1 3
0233 0 -1</code></pre><p>输出样例：</p>
<pre><code>0233 0001</code></pre><p>分析：<br>直接对输入的每一行数据进行与最大值，最小值对比，然后变换。此处都是int型也是可以的。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    int maxid=0,minid=0;
    long lenmax=0,lenmin=20000;
    long id=0,x=0,y=0;
    for(int i=0;i&lt;n;i++){
        scanf(&quot;%ld %ld %ld&quot;,&amp;id,&amp;x,&amp;y);
        long len=x*x+y*y;
        if(len&gt;lenmax){
            lenmax=len;
            maxid=id;
        }
        if(len&lt;lenmin){
            lenmin=len;
            minid=id;
        }
    }
    printf(&quot;%04ld %04ld&quot;,minid,maxid);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1083</title>
    <url>/2019/10/11/PTA-Basic-1083/</url>
    <content><![CDATA[<p>题目：<br>给定 N 张卡片，正面分别写上 1、2、……、N，然后全部翻面，洗牌，在背面分别写上 1、2、……、N。将每张牌的正反两面数字相减（大减小），得到 N 个非负差值，其中是否存在相等的差？</p>
<p>输入格式：<br>输入第一行给出一个正整数 N（2 ≤ N ≤ 10 000），随后一行给出 1 到 N 的一个洗牌后的排列，第 i 个数表示正面写了 i 的那张卡片背面的数字。</p>
<p>输出格式：<br>按照“差值 重复次数”的格式从大到小输出重复的差值及其重复的次数，每行输出一个结果。</p>
<p>输入样例：</p>
<pre><code>8
3 5 8 6 2 1 4 7</code></pre><p>输出样例：</p>
<pre><code>5 2
3 3
2 2</code></pre><p>分析：定义一个非常大的数组就命名为差值数组，用数组下标存储差值，数组元素值存储此差值出现了多少次，<br>对第i个输入的数字，将其与其i值做差，取绝对值，存入差值数组中。最后倒序遍历输出数组下标与对应的值（大于1的）。<br>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
//而全局变量则可以全部自动初始化为0
int main(void){
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    int time[10002]={0};//如果不手动初始化数组，那么最大初始化为0的长度是7921
    int x,y;
    int z;
    for(int i=0;i&lt;n;i++){
        scanf(&quot;%d&quot;,&amp;x);
        z=abs(x-i-1);
        time[z]++;
    }
    for(int i=n-1;i&gt;=0;i--){
        if(time[i]&gt;1){
            printf(&quot;%d %d\n&quot;,i,time[i]);
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1077</title>
    <url>/2019/10/09/PTA-Basic-1077/</url>
    <content><![CDATA[<p>题目：</p>
<p>在浙大的计算机专业课中，经常有互评分组报告这个环节。一个组上台介绍自己的工作，其他组在台下为其表现评分。最后这个组的互评成绩是这样计算的：所有其他组的评分中，去掉一个最高分和一个最低分，剩下的分数取平均分记为 G<br>​1<br>​​ ；老师给这个组的评分记为 G<br>​2<br>​​ 。该组得分为 (G<br>​1<br>​​ +G<br>​2<br>​​ )/2，最后结果四舍五入后保留整数分。本题就要求你写个程序帮助老师计算每个组的互评成绩。</p>
<p>输入格式：<br>输入第一行给出两个正整数 N（&gt; 3）和 M，分别是分组数和满分，均不超过 100。随后 N 行，每行给出该组得到的 N 个分数（均保证为整型范围内的整数），其中第 1 个是老师给出的评分，后面 N−1 个是其他组给的评分。合法的输入应该是 [0,M] 区间内的整数，若不在合法区间内，则该分数须被忽略。题目保证老师的评分都是合法的，并且每个组至少会有 3 个来自同学的合法评分。</p>
<p>输出格式：<br>为每个组输出其最终得分。每个得分占一行。</p>
<p>输入样例：</p>
<pre><code>6 50
42 
36 51 50 28 -1 3049 49 35 38 41
40 36 41 33 47 49
30 250 -25 27 45 31
48 0 0 50 50 1234
43 41 36 29 42 29</code></pre><p>输出样例：</p>
<pre><code>42
33
41
31
37
39</code></pre><p>分析：<br>先存储行数（亦是列数），再存储总分，定义一个判断函数，然后对于每一行每一个数据进行判断，合适的第一个数赋值给老师，剩余存储到数组中去，对数组排序，从第二个元素开始，到倒数第二个元素求平均值，然后再与老师的分数值取平均值，对此品均值进行四舍五入，注意整型与整型除法的结果为整型。继续下一行的数据的输入与处理。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int cmp(const void *a,const void *b){
    return *(int *)a-*(int *)b;
}
int check(int n,int m){
        if(n&lt;=m&amp;&amp;n&gt;=0){
            return 1;
        }
        return 0;
}
int main()
{
    int n,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    for(int i=0;i&lt;n;i++){
            int n0=0;
            int time=-1;
            int a[n-1];
        for(int j=0;j&lt;n;j++){
                int k;
            scanf(&quot;%d&quot;,&amp;k);
            if(check(k,m)){
                if(time==-1){
                    n0=k;
                }else{
                    a[time]=k;
                }
                time++;
            }else{
                continue;
            }
        }
        qsort(a,time,sizeof(int),cmp);
        int sum=0;
        for(int j=1;j&lt;time-1;j++){
            sum=sum+a[j];
        }
        if(sum!=0){
            sum=sum/(time-2);
        }
        printf(&quot;%d\n&quot;,(int)((sum+n0)*1.0/2+0.5));//必须*1.0，防止整形运算的区别
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1079</title>
    <url>/2019/10/11/PTA-Basic-1079/</url>
    <content><![CDATA[<p>给定一个 k+1 位的正整数 N，写成 a<br>​k<br>​​ ⋯a<br>​1<br>​​ a<br>​0<br>​​  的形式，其中对所有 i 有 0≤a<br>​i<br>​​ &lt;10 且 a<br>​k<br>​​ &gt;0。N 被称为一个回文数，当且仅当对所有 i 有 a<br>​i<br>​​ =a<br>​k−i<br>​​ 。零也被定义为一个回文数。</p>
<p>非回文数也可以通过一系列操作变出回文数。首先将该数字逆转，再将逆转数与该数相加，如果和还不是一个回文数，就重复这个逆转再相加的操作，直到一个回文数出现。如果一个非回文数可以变出回文数，就称这个数为延迟的回文数。（定义翻译自 <a href="https://en.wikipedia.org/wiki/Palindromic_number">https://en.wikipedia.org/wiki/Palindromic_number</a> ）</p>
<p>给定任意一个正整数，本题要求你找到其变出的那个回文数。</p>
<p>输入格式：<br>输入在一行中给出一个不超过1000位的正整数。</p>
<p>输出格式：<br>对给定的整数，一行一行输出其变出回文数的过程。每行格式如下</p>
<p>A + B = C<br>其中 A 是原始的数字，B 是 A 的逆转数，C 是它们的和。A 从输入的整数开始。重复操作直到 C 在 10 步以内变成回文数，这时在一行中输出 C is a palindromic number.；或者如果 10 步都没能得到回文数，最后就在一行中输出 Not found in 10 iterations.。</p>
<p>输入样例 1：</p>
<pre><code>97152</code></pre><p>输出样例 1：</p>
<pre><code>97152 + 25179 = 122331
122331 + 133221 = 255552
255552 is a palindromic number.</code></pre><p>输入样例 2：</p>
<pre><code>196</code></pre><p>输出样例 2：</p>
<pre><code>196 + 691 = 887
887 + 788 = 1675
1675 + 5761 = 7436
7436 + 6347 = 13783
13783 + 38731 = 52514
52514 + 41525 = 94039
94039 + 93049 = 187088
187088 + 880781 = 1067869
1067869 + 9687601 = 10755470
10755470 + 07455701 = 18211171
Not found in 10 iterations.</code></pre><p>分析：<br>定一个判断字符串是否回文字符串的函数，定义一个反转字符串的函数。<br>首先对输入的字符串判断是否是回文字符串，然后定义一个比它长1的字符数组，防止最高位进位，将当前字符串复制到另一个，然后用复制后的字符串与反转字符串相加。然后将结果输出，赋值给第一个字符串重复此操作，直到找到或达到10次。<br>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include&lt;string.h&gt;
#include &lt;stdlib.h&gt;//虽然题目说字符串的长度在0-1000之间但是他们相加后的长度就可能大于1000了所以要定义比1001大的
int isReserve(char* s){//判断是否是回文字符串的函数。
    int i=0;
    int j=strlen(s)-1;
    while(i&lt;j){
        if(s[i]!=s[j]){
            return 0;
        }
        i++;
        j--;
    }
    return 1;
}
char * strrev(char *str){
    int i=0,j=strlen(str)-1;//对源字符串直接操作，
    char ch;
    while(i&lt;j){
        ch=str[j];
        str[j]=str[i];
        str[i]=ch;
        i++;
        j--;
    }
    return str;
}
int main()
{
    char str[1050];
    gets(str);
    int i=0;
    for(;i&lt;10;i++){
        if(isReserve(str)){
            printf(&quot;%s is a palindromic number.&quot;,str);
            break;
        }else{
            char strcopy[1050];//保留反转前的字符串
            strcpy(strcopy,str);
            strrev(str);//反转str中的字符串
            printf(&quot;%s + %s = &quot;,strcopy,str);
            char res[1050]={&apos;\0&apos;};//定义结果数组。
            int k=0;
            int max=strlen(str);
            for(int j=0;j&lt;max;j++){//因为字符串是与反转字符串相加，唯一不同的就是如果最高位有进位，进位就存在右边了，此时需要反转一下。
                int sum=0;
                if(strcopy[j]){
                    sum=sum+strcopy[j]-&apos;0&apos;;
                }
                if(str[j]){
                    sum=sum+str[j]-&apos;0&apos;;
                }
                sum=sum+k;
                res[j]=sum%10+&apos;0&apos;;
                k=sum/10;
                if(j==max-1&amp;&amp;k!=0){//如果高位有进位，就要存下他。
                    res[j+1]=k+&apos;0&apos;;//
                }
            }
            strrev(res);//反转结果数组
            puts(res);//输出
            strcpy(str,res);//将结果赋值给str继续操作。
        }
    }
    if(i==10){
        printf(&quot;Not found in 10 iterations.&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1073</title>
    <url>/2019/10/08/PTA-Basic-1073/</url>
    <content><![CDATA[<p>题目：<br>批改多选题是比较麻烦的事情，有很多不同的计分方法。有一种最常见的计分方法是：如果考生选择了部分正确选项，并且没有选择任何错误选项，则得到 50% 分数；如果考生选择了任何一个错误的选项，则不能得分。本题就请你写个程序帮助老师批改多选题，并且指出哪道题的哪个选项错的人最多。</p>
<p>输入格式：<br>输入在第一行给出两个正整数 N（≤1000）和 M（≤100），分别是学生人数和多选题的个数。随后 M 行，每行顺次给出一道题的满分值（不超过 5 的正整数）、选项个数（不少于 2 且不超过 5 的正整数）、正确选项个数（不超过选项个数的正整数）、所有正确选项。注意每题的选项从小写英文字母 a 开始顺次排列。各项间以 1 个空格分隔。最后 N 行，每行给出一个学生的答题情况，其每题答案格式为 (选中的选项个数 选项1 ……)，按题目顺序给出。注意：题目保证学生的答题情况是合法的，即不存在选中的选项数超过实际选项数的情况。</p>
<p>输出格式：<br>按照输入的顺序给出每个学生的得分，每个分数占一行，输出小数点后 1 位。最后输出错得最多的题目选项的信息，格式为：错误次数 题目编号（题目按照输入的顺序从1开始编号）-选项号。如果有并列，则每行一个选项，按题目编号递增顺序输出；再并列则按选项号递增顺序输出。行首尾不得有多余空格。如果所有题目都没有人错，则在最后一行输出 Too simple。</p>
<p>输入样例 1：</p>
<pre><code>3 4 
3 4 2 a c
2 5 1 b
5 3 2 b c
1 5 4 a b d e
(2 a c) (3 b d e) (2 a c) (3 a b e)
(2 a c) (1 b) (2 a b) (4 a b d e)
(2 b d) (1 e) (1 c) (4 a b c d)</code></pre><p>输出样例 1：</p>
<pre><code>3.5
6.0
2.5
2 2-e
2 3-a
2 3-b</code></pre><p>输入样例 2：</p>
<pre><code>2 2 
3 4 2 a c
2 5 1 b
(2 a c) (1 b)
(2 a c) (1 b)</code></pre><p>输出样例 2：</p>
<pre><code>5.0
5.0
Too simple</code></pre><p>分析：<br>定义一个非常大的二维数组，一维用来表示题目号，二维用来存储答案，用0位表示a，1位表示b,2位表示c,…其存储的数值0-表示正确的选项中没有，1表示正确的选项中有。<br>定义一个非常大的浮点数数组存储每位学生的成绩，再定义一个非常大的二维数组用来存储每个题目每个选项的出错次数，然后找出最大的次数。对于每一个学生的每一题，统计其输入中的对的项数，如果与总的输入次数相同则这题没有错，但是不保证全对，如果此题的step相同则全对。不管某个选项对不对，在flag中记录下此题此人选择的搜友选项，然后与题目一开始输入正确选项对比，找找有没有没选的正确选项，有则在对应的错误次数上加1，题目中不是值统计出错最多的选项还要统计没选的正确选项最多的选项。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
double stu[1000];//存储每个学生的成绩
int score[100];//存储每题目的分数
int step[100];//存储每题目的正确的选项数目。
int map[100][5];//存储每个题目正确的选项
int flag[5];//统计每个人每个题目输入的选项
int time[100][5];//用来计算每道题目，每个选项的出错次数,与总的出错次数
int main()
{   int n,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    for(int i=0;i&lt;m;i++){
        scanf(&quot;%d %*d %d&quot;,&amp;score[i],&amp;step[i]);
        char ch;
        while((ch=getchar())!=&apos;\n&apos;){
            if(ch&lt;=&apos;f&apos;&amp;&amp;ch&gt;=&apos;a&apos;){
            int k=ch-&apos;a&apos;;
            map[i][k]=1;
            }
        }
    }
    int max=0;
    for(int i=0;i&lt;n;i++){
        char ch;
        int step1=0;
        int totalstep=0;
        int t=-1;
        while((ch=getchar())!=&apos;\n&apos;){
            if(ch==&apos; &apos;){
                continue;
            }else if(ch==&apos;(&apos;){
                    t++;
                    step1=0;
                    totalstep=0;
            }else if(ch==&apos;)&apos;){
                    if(totalstep==step1){
                            if(step1==step[t]){
                                stu[i]+=score[t]*1.0;
                            }else{
                                stu[i]+=score[t]*0.5;
                            }
                    }
                    for(int i=0;i&lt;5;i++){
                        if(flag[i]==0&amp;&amp;map[t][i]==1){//选的最多的和没选最多的，此处统计没选的且为正确的最多的选项。
                            time[t][i]++;
                            if(time[t][i]&gt;max){
                                max=time[t][i];
                            }
                        }else{
                            flag[i]=0;
                        }
                    }
            }else if(ch&lt;=&apos;5&apos;&amp;&amp;ch&gt;=&apos;0&apos;){
                totalstep=ch-&apos;0&apos;;
            }else{
                int k=ch-&apos;a&apos;;
               if(map[t][k]==0){
                   time[t][k]++;
                   if(time[t][k]&gt;max){
                        max=time[t][k];
                    }
                }else{//选对的话将对应下标的数值-1
                    step1++;
                }
                flag[k]=1;
            }
        }
    }
    for(int i=0;i&lt;n;i++){
        printf(&quot;%.1f\n&quot;,stu[i]);
    }
    if(max&gt;0){
        for(int i=0;i&lt;m;i++)
                for(int j=0;j&lt;5;j++){
                    if(time[i][j]==max)
                        printf(&quot;%d %d-%c\n&quot;,max,i+1,j+&apos;a&apos;);
                }
    }else{//如果最大值则都是满分
        printf(&quot;Too simple&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1063</title>
    <url>/2019/10/07/PTA-Basic-1063/</url>
    <content><![CDATA[<p>在数学中，矩阵的“谱半径”是指其特征值的模集合的上确界。换言之，对于给定的 n 个复数空间的特征值 { a<br>​1<br>​​ +b<br>​1<br>​​ i,⋯,a<br>​n<br>​​ +b<br>​n<br>​​ i }，它们的模为实部与虚部的平方和的开方，而“谱半径”就是最大模。</p>
<p>现在给定一些复数空间的特征值，请你计算并输出这些特征值的谱半径。</p>
<p>输入格式：<br>输入第一行给出正整数 N（≤ 10 000）是输入的特征值的个数。随后 N 行，每行给出 1 个特征值的实部和虚部，其间以空格分隔。注意：题目保证实部和虚部均为绝对值不超过 1000 的整数。</p>
<p>输出格式：<br>在一行中输出谱半径，四舍五入保留小数点后 2 位。</p>
<p>输入样例：</p>
<pre><code>5
0 1
2 0
-1 0
3 3
0 -3</code></pre><p>输出样例：</p>
<pre><code>4.24</code></pre><p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include&lt;math.h&gt;
int main()
{
    int n=0;
    double real=0,imag=0;
    double max=0;
    double sub=0;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++){
        scanf(&quot;%lf %lf&quot;,&amp;real,&amp;imag);
        sub=sqrt(real*real+imag*imag);
        if(sub&gt;max){
            max=sub;
        }
    }
    printf(&quot;%.2f&quot;,max);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1084</title>
    <url>/2019/10/11/PTA-Basic-1084/</url>
    <content><![CDATA[<p>题目：<br>外观数列是指具有以下特点的整数序列：</p>
<p>d, d1, d111, d113, d11231, d112213111, …<br>它从不等于 1 的数字 d 开始，序列的第 n+1 项是对第 n 项的描述。比如第 2 项表示第 1 项有 1 个 d，所以就是 d1；第 2 项是 1 个 d（对应 d1）和 1 个 1（对应 11），所以第 3 项就是 d111。又比如第 4 项是 d113，其描述就是 1 个 d，2 个 1，1 个 3，所以下一项就是 d11231。当然这个定义对 d = 1 也成立。本题要求你推算任意给定数字 d 的外观数列的第 N 项。</p>
<p>输入格式：<br>输入第一行给出 [0,9] 范围内的一个整数 d、以及一个正整数 N（≤ 40），用空格分隔。</p>
<p>输出格式：<br>在一行中给出数字 d 的外观数列的第 N 项。</p>
<p>输入样例：</p>
<pre><code>1 8</code></pre><p>输出样例：</p>
<pre><code>1123123111</code></pre><p>分析：做此题时，一定要在旁边自己演算一边推算过程，不要只看不动手。对于i-1项，从左边到右边读取，如果有连续的（n个）’d’就记作dn，第一个字符不算它是个特殊字符，不要把他与后面混为一谈，他始终是一个记作d1。<br>处理：</p>
<p>对于一个给定的字符，对其进行从1到n之间的推演，首先将此字符存储入数组，然后对此数组进行n次的推演。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
int main(void){
    int n;
    char ch;
    scanf(&quot;%c %d&quot;,&amp;ch,&amp;n);
    char res[100000]={0};//这个会非常大非常非常大。 
    char crs[100000]={0};
    res[0]=ch;
    for(int i=1;i&lt;n;i++){
        int time=0;
        int begin=0;
        for(int len=0;len&lt;strlen(res);len++){
            time++;
            if(res[len+1]==res[len]){//如果下一个字符还等于当前字符，继续数个数
                continue;
            }else{
                crs[begin++]=res[len];//首先存入字符再存入数字
                crs[begin++]=&apos;0&apos;+time;//这边我一开始担心有次数超过10的情况，但是那种处理起来有点麻烦，而且根据题目要求没看出来有大于10可能性的存在，就没考虑。
                time=0;//time赋值为0用于下一次的计算有多少个
            }
        }
        strcpy(res,crs);//将此次推演的结果存入res中用于下一次的推演。
    }
    printf(&quot;%s&quot;,res);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1085</title>
    <url>/2019/10/16/PTA-Basic-1085/</url>
    <content><![CDATA[<p>题目：<br>每次 PAT 考试结束后，考试中心都会发布一个考生单位排行榜。本题就请你实现这个功能。</p>
<p>输入格式：<br>输入第一行给出一个正整数 N（≤10<br>​5<br>​​ ），即考生人数。随后 N 行，每行按下列格式给出一个考生的信息：</p>
<p>准考证号 得分 学校<br>其中准考证号是由 6 个字符组成的字符串，其首字母表示考试的级别：B代表乙级，A代表甲级，T代表顶级；得分是 [0, 100] 区间内的整数；学校是由不超过 6 个英文字母组成的单位码（大小写无关）。注意：题目保证每个考生的准考证号是不同的。</p>
<p>输出格式：<br>首先在一行中输出单位个数。随后按以下格式非降序输出单位的排行榜：</p>
<p>排名 学校 加权总分 考生人数<br>其中排名是该单位的排名（从 1 开始）；学校是全部按小写字母输出的单位码；加权总分定义为乙级总分/1.5 + 甲级总分 + 顶级总分*1.5的整数部分；考生人数是该属于单位的考生的总人数。</p>
<p>学校首先按加权总分排行。如有并列，则应对应相同的排名，并按考生人数升序输出。如果仍然并列，则按单位码的字典序输出。</p>
<p>输入样例：</p>
<pre><code>10
A57908 85 Au
B57908 54 LanX
A37487 60 au
T28374 67 CMU
T32486 24 hypu
A66734 92 cmu
B76378 71 AU
A47780 45 lanx
A72809 100 pku
A03274 45 hypu</code></pre><p>输出样例：</p>
<pre><code>5
1 cmu 192 2
1 au 192 3
3 pku 100 1
4 hypu 81 2
4 lanx 81 2</code></pre><p>分析：<br>定义一个结构体（包含学校名字（不分大小写），学校出席人数，学校总分（浮点数）），定义两个数组一个用来存储所有学校的（包含重复的内容）信息，然后再利用快排对第一个数组进行排序，再定义另一个数组用来合并名字相同的学校信息，然后每行输出一个学校的信息，排名从1开始，如果遇到不同的就+1。实话实说，这个代码是我抄的，我的思路固化了。<br>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
typedef struct{
  char szSchool[7];
  double fScore;
  int iNumofStu;
} SCHOOL;
int cmp_sch(const void *a, const void *b)//利用学校的名字进行的排序
{
  SCHOOL *p=(SCHOOL *)a;//将a转化为结构体的指针，同样对b也是这样做。
  SCHOOL *q=(SCHOOL *)b;
  return strcmp(p-&gt;szSchool,q-&gt;szSchool);//对数组进行名字升序排序
}
int cmp(const void *a, const void *b)//依据题目排序，先对成绩降序，再对人数升序，再对学校名字升序。
{
  SCHOOL *p=(SCHOOL *)a;
  SCHOOL *q=(SCHOOL *)b;
  int flag=0;
  int iscorep=(int)p-&gt;fScore,iscoreq=(int)q-&gt;fScore;
  if(iscorep&lt;iscoreq)
  {
    flag=1;
  }
  else if(iscorep==iscoreq)
  {
    if(p-&gt;iNumofStu&gt;q-&gt;iNumofStu)
    {
      flag=1;
    }
    else if(p-&gt;iNumofStu==q-&gt;iNumofStu)
    {
      if(strcmp(p-&gt;szSchool,q-&gt;szSchool)&gt;0)
      {
        flag=1;
      }
    }
  }
  return flag;
}
int main()
{
  int iN=0,iNumofSchool=0;
  scanf(&quot;%d&quot;,&amp;iN);
  SCHOOL school[iN],result[iN];
  memset(school,0,iN*sizeof(SCHOOL));//初始化含重复数据数组。
  memset(result,0,iN*sizeof(SCHOOL));//初始化存储无重复数据的数组
  int pos=0;
  char szTempID[7]={0},szTempSch[7]={0};
  double fTempScore=0;
  for(int i=0;i&lt;iN;i++)
  {
    getchar();
    scanf(&quot;%s %lf %s&quot;,szTempID,&amp;fTempScore,szTempSch);
    if(szTempID[0]==&apos;B&apos;)//依据考试的等级进行分数统计。
    {
      fTempScore/=1.5;
    }
    else if(szTempID[0]==&apos;T&apos;)
    {
      fTempScore*=1.5;
    }
    for(int j=0;j&lt;strlen(szTempSch);j++)//将名字变为小写
    {
      if(szTempSch[j]&gt;=&apos;A&apos;&amp;&amp;szTempSch[j]&lt;=&apos;Z&apos;)
      {
        szTempSch[j]+=&apos;a&apos;-&apos;A&apos;;
      }
    }
    strcpy(school[i].szSchool,szTempSch);
    school[i].fScore=fTempScore;
    school[i].iNumofStu=1;//存储到数组中去。
  }
  qsort(school,iN,sizeof(SCHOOL),cmp_sch);
  result[0]=school[0];//首先将第一个学校数据给宁外一个数组
  for(int i=1;i&lt;iN;i++)//从第一个开始，第0个已经给了另一个数组了，
  {
    if(strcmp(school[i].szSchool,school[i-1].szSchool)==0)
    {//用后面的跟前面的比较，姓名一样就说明与前一个相同学校。
      result[pos].fScore+=school[i].fScore;
      result[pos].iNumofStu++;
    }
    else//不一样就说明另外一个学校，那么另一个数组的下标就要加1.
    {
      pos++;
      result[pos]=school[i];
    }
  }
  qsort(result,pos+1,sizeof(SCHOOL),cmp);//用题目条件排序。
  int cnt=1;
  printf(&quot;%d\n&quot;,pos+1);
  printf(&quot;%d %s %d %d&quot;,cnt,result[0].szSchool,(int)result[0].fScore,result[0].iNumofStu);
  for(int i=1;i&lt;=pos;i++)
  {
    if((int)result[i].fScore!=(int)result[i-1].fScore)
    {
      cnt=i+1;
    }
    printf(&quot;\n%d %s %d %d&quot;,cnt,result[i].szSchool,(int)result[i].fScore,result[i].iNumofStu);
  }
  return 0;
}</code></pre><p>原来代码的错误分析：首先说一下运行结果，前三个测试点过去了，后两个运行超时，说明思路是对的，就是解决方法补恰当。</p>
<pre><code>#include &lt;stdio.h&gt;
#include&lt;string.h&gt;
#include &lt;stdlib.h&gt;
typedef struct school{//学校结构体
    char name[8];//名字
    double score;//学校分数
    int time;//出席人数
};
struct school schools[100001];
int cmp(const void *a,const void *b);
int cnmp(const void *a,const void *b);
void toLowerCase(char *s);
int search(int nn,char *n);
int main()
{
    char name[8]={&apos;\0&apos;};
    int scor=0;
    char id[8]={&apos;\0&apos;};
    int n;
    int time=0;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++){
        getchar();
        scanf(&quot;%s %d %s&quot;,id,&amp;scor,name);
        toLowerCase(name);//变为小写
        int index=search(time,name);//这里甚至采用了二人分查找依然没有逃过运行超时的命运，遍历已有的数组看看有没有这个名字有就返回下标没有返回-1。
        if(index==-1){//返回-1，表示数组中要加一个新的学校了。
            strcpy(schools[time].name,name);
            index=time;//将已经有几个学校的数目给index，index就是新加进来的学校在数组中的位置
            time++;//time加1，表示有加了一个新的学校
        }
        schools[index].time++;//出席人数加一
        if(id[0]==&apos;A&apos;){//根据等级对分数计算
            schools[index].score=schools[index].score+scor;
        }else if(id[0]==&apos;B&apos;){
            schools[index].score=schools[index].score+scor*1.0*2/3;
        }else{
            schools[index].score=schools[index].score+scor*1.0*3/2;
        }
        qsort(schools,time,sizeof(struct school),cnmp);//快速排序
    }
    qsort(schools,time,sizeof(struct school),cmp);
    int max=-1;
    int paiming=0;
    int lastpaiming;
    printf(&quot;%d\n&quot;,time);
    for(int i=0;i&lt;time;i++){
        paiming++;
        if((int)(schools[i].score)==max){
            printf(&quot;%d %s %d %d\n&quot;,lastpaiming,schools[i].name,(int)schools[i].score,schools[i].time);
            continue;
        }else{
            max=(int)schools[i].score;
            printf(&quot;%d %s %d %d\n&quot;,paiming,schools[i].name,(int)schools[i].score,schools[i].time);
        }
        lastpaiming=paiming;
    }
    return 0;
}
int search(int time,char *name){
    int start=0,end=time;
    while(start&lt;=end){
        int mid=(start+end)/2;
        int n=strcmp(schools[mid].name,name);
        if(n==0){
            return mid;
        }else if(n&gt;0){
            end=mid-1;
        }else{
            start=mid+1;
        }
    }
    return -1;
}
int cmp(const void *a1,const void *b1){
    struct school sc1=*(struct school *)a1;
    struct school sc2=*(struct school *)b1;
    int a=(int)sc1.score;
    int b=(int)sc2.score;
    if(a&gt;b){
        return -1;
    }else if(a&lt;b){
        return 1;
    }else{
        if(sc1.time&gt;sc2.time){
            return 1;
        }else if(sc1.time&lt;sc2.time){
        return -1;
        }else{
            return strcmp(sc1.name,sc2.name);
        }
    }
}
void toLowerCase(char *s){//将名字变为小写的函数
    while((*s)!=&apos;\0&apos;){
        if(*s&lt;=&apos;Z&apos;&amp;&amp;*s&gt;=&apos;A&apos;){
            *s=(*s)-&apos;A&apos;+&apos;a&apos;;
        }
        s++;
    }
}
int cnmp(const void *a,const void *b){
    struct school sch1=*(struct school*)a;
    struct school sch2=*(struct school*)b;
    return strcmp(sch1.name,sch2.name);
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1080</title>
    <url>/2019/10/11/PTA-Basic-1080/</url>
    <content><![CDATA[<p>题目：<br>对于在中国大学MOOC（<a href="http://www.icourse163.org/">http://www.icourse163.org/</a> ）学习“数据结构”课程的学生，想要获得一张合格证书，必须首先获得不少于200分的在线编程作业分，然后总评获得不少于60分（满分100）。总评成绩的计算公式为 G=(G<br>​mid−term<br>​​ ×40%+G<br>​final<br>​​ ×60%)，如果 G<br>​mid−term<br>​​ &gt;G<br>​final<br>​​ ；否则总评 G 就是 G<br>​final<br>​​ 。这里 G<br>​mid−term<br>​​  和 G<br>​final<br>​​  分别为学生的期中和期末成绩。</p>
<p>现在的问题是，每次考试都产生一张独立的成绩单。本题就请你编写程序，把不同的成绩单合为一张。</p>
<p>输入格式：<br>输入在第一行给出3个整数，分别是 P（做了在线编程作业的学生数）、M（参加了期中考试的学生数）、N（参加了期末考试的学生数）。每个数都不超过10000。</p>
<p>接下来有三块输入。第一块包含 P 个在线编程成绩 G<br>​p<br>​​ ；第二块包含 M 个期中考试成绩 G<br>​mid−term<br>​​ ；第三块包含 N 个期末考试成绩 G<br>​final<br>​​ 。每个成绩占一行，格式为：学生学号 分数。其中学生学号为不超过20个字符的英文字母和数字；分数是非负整数（编程总分最高为900分，期中和期末的最高分为100分）。</p>
<p>输出格式：<br>打印出获得合格证书的学生名单。每个学生占一行，格式为：</p>
<p>学生学号 G<br>​p<br>​​  G<br>​mid−term<br>​​  G<br>​final<br>​​  G</p>
<p>如果有的成绩不存在（例如某人没参加期中考试），则在相应的位置输出“−1”。输出顺序为按照总评分数（四舍五入精确到整数）递减。若有并列，则按学号递增。题目保证学号没有重复，且至少存在1个合格的学生。</p>
<p>输入样例：</p>
<pre><code>6 6 7
01234 880
a1903 199
ydjh2 200
wehu8 300
dx86w 220
missing 400
ydhfu77 99
wehu8 55
ydjh2 98
dx86w 88
a1903 86
01234 39
ydhfu77 88
a1903 66
01234 58
wehu8 84
ydjh2 82
missing 99
dx86w 81</code></pre><p>输出样例：</p>
<pre><code>missing 400 -1 99 99
ydjh2 200 98 82 88
dx86w 220 88 81 84
wehu8 300 55 84 84</code></pre><p>分析：<br>定义一个学生的结构体。<br>首先输入6+6+7行数据，将此输入分为三块，第一块存储平时分合格（》=200）人的名字，与分数，第二部分存储，根据输入的名字在第一部分的结果数组中找到相应的人的下标，将其中成绩赋值，第三部分同第二但是此外还要加上对总评分数的计算，期中期末未来的人分数为-1，依据题目计算总评分，然后首先根据成绩降序排序，然后根据姓名升序排序。</p>
<p>代码：<br>第一次代码：<br>此处最后一个测试点会运行超时，这是因为在查找时，耗时过多，因此必须采用更好的查找算法（先排序（快排），再二分查找）。</p>
<pre><code>//#include&lt;stdio.h&gt;
//#include&lt;string.h&gt;
//#include&lt;stdlib.h&gt;
//typedef struct Stu{
//    char name[21];
//    int gp;
//    int gm;
//    int gt;
//    int g;
//};
//int search(Stu* stus,int total,char *name){
//    for(int i=0;i&lt;total;i++){
//        if(strcmp(stus[i].name,name)==0){
//            return i;
//        }
//    }
//    return -1;
//}
//int cmp(const void *a,const void *b){
//    struct Stu s1=*(struct Stu *)a;
//    struct Stu s2=*(struct Stu *)b;
//    if(s1.g&lt;s2.g){}
//        return 1;
//    }else if(s1.g&gt;s2.g){
//        return -1;
//    }else{
//        return strcmp(s1.name,s2.name);
//    }
//}
//int main(void){
//    int n,m,p;
//    scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;p);
//    struct Stu stus[n];
//    int time=0;
//    char name[21];
//    int k=0;
//    for(int i=0;i&lt;n;i++){
//        scanf(&quot;%s %d&quot;,name,&amp;k);
//        if(k&gt;=200){
//            strcpy(stus[time].name,name);
//            stus[time].gp=k;
//            stus[time].gm=-1;
//            stus[time].gt=-1;
//            stus[time].g=-1;
//            time++;
//        }
//    }
//    for(int i=0;i&lt;m;i++){
//        scanf(&quot;%s %d&quot;,name,&amp;k);
//        int index=search(stus,time,name);
//        if(index&gt;-1){
//            stus[index].gm=k;
//        }
//    }
//    for(int i=0;i&lt;p;i++){
//        scanf(&quot;%s %d&quot;,name,&amp;k);
//        int index=search(stus,time,name);
//        if(index&gt;-1){
//            stus[index].gt=k;
//            if(stus[index].gm&gt;stus[index].gt){
//                stus[index].g=(int)(0.4*stus[index].gm+0.6*stus[index].gt+0.5);
//            }else{
//                stus[index].g=stus[index].gt;
//            }
//        }
//    }
//    qsort(stus,time,sizeof(struct Stu),cmp);
//    for(int i=0;i&lt;time;i++){
//        if(stus[i].g&gt;=60)
//        printf(&quot;%s %d %d %d %d\n&quot;,stus[i].name,stus[i].gp,stus[i].gm,stus[i].gt,stus[i].g);
//    }
//    return 0;
//}</code></pre><p>第二次代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
typedef struct Stu{
    char name[21];
    int gp;//平时成绩
    int gm;//期中成绩
    int gt;//期末成绩
    int g;//总评成绩
};
int search(struct Stu* stus,int total,char *name){//二分查找返回存在的人的下标，不存在就返回-1
    int start=0,end=total-1;
    while(start&lt;=end){
         int mid=(start+end)/2;
         int res=strcmp(stus[mid].name,name);
        if(res==0){
            return mid;
        }else if(res&gt;0){
            end=mid-1;
        } else{
            start=mid+1;
        }
    }
    return -1;
}
int cmp(const void *a,const void *b){
    struct Stu s1=*(struct Stu *)a;
    struct Stu s2=*(struct Stu *)b;
    if(s1.g&lt;s2.g){
        return 1;
    }else if(s1.g&gt;s2.g){
        return -1;
    }else{
        return strcmp(s1.name,s2.name);
    }
}
int tcmp(const void *a,const void *b){//用于二分查找的排序比较算法
    struct Stu s1=*(struct Stu *)a;
    struct Stu s2=*(struct Stu *)b;
    return strcmp(s1.name,s2.name);
    }
int main(void){
    int n,m,p;
    scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;p);
    struct Stu stus[n];
    int time=0;
    char name[21];
    int k=0;
    for(int i=0;i&lt;n+m+p;i++){
        scanf(&quot;%s %d&quot;,name,&amp;k);
        if(i&lt;n){
            if(k&gt;=200){//平时成绩合格才有资格
                strcpy(stus[time].name,name);//首先初始化时将每个人的每个考试成绩都赋值为-1。
                stus[time].gp=k;
                stus[time].gm=-1;
                stus[time].gt=-1;
                stus[time].g=-1;
                time++;
            }
        }else{
            if(i==n){//第n个输入说明所有有资格的人都已经输入完毕，对其排序，以便于二分查找。
                qsort(stus,time,sizeof(struct Stu),tcmp);
            }
            int index=search(stus,time,name);
            if(index&gt;-1){//如果有这个人
                if(i&lt;m+n){
                    stus[index].gm=k;
                }else{
                    stus[index].gt=k;
                    if(stus[index].gm&gt;stus[index].gt){
                        stus[index].g=(int)(0.4*stus[index].gm+0.6*stus[index].gt+0.5);
                    }else{
                        stus[index].g=stus[index].gt;
                    }
                }
            }
        }
    }
    qsort(stus,time,sizeof(struct Stu),cmp);
    for(int i=0;i&lt;time;i++){
        if(stus[i].g&gt;=60)
        printf(&quot;%s %d %d %d %d\n&quot;,stus[i].name,stus[i].gp,stus[i].gm,stus[i].gt,stus[i].g);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1087</title>
    <url>/2019/10/16/PTA-Basic-1087/</url>
    <content><![CDATA[<p>题目：</p>
<p>子曰：“三人行，必有我师焉。择其善者而从之，其不善者而改之。”</p>
<p>本题给定甲、乙、丙三个人的能力值关系为：甲的能力值确定是 2 位正整数；把甲的能力值的 2 个数字调换位置就是乙的能力值；甲乙两人能力差是丙的能力值的 X 倍；乙的能力值是丙的 Y 倍。请你指出谁比你强应“从之”，谁比你弱应“改之”。</p>
<p>输入格式：<br>输入在一行中给出三个数，依次为：M（你自己的能力值）、X 和 Y。三个数字均为不超过 1000 的正整数。</p>
<p>输出格式：<br>在一行中首先输出甲的能力值，随后依次输出甲、乙、丙三人与你的关系：如果其比你强，输出 Cong；平等则输出 Ping；比你弱则输出 Gai。其间以 1 个空格分隔，行首尾不得有多余空格。</p>
<p>注意：如果解不唯一，则以甲的最大解为准进行判断；如果解不存在，则输出 No Solution。</p>
<p>输入样例 1：</p>
<pre><code>48 3 7</code></pre><p>输出样例 1：</p>
<pre><code>48 Ping Cong Gai</code></pre><p>输入样例 2：</p>
<pre><code>48 11 6</code></pre><p>输出样例 2：</p>
<pre><code>No Solution</code></pre><p>分析：<br>输入的是自己的分数，x,y.<br>处理：从99到10假设甲的成绩，利用甲的成绩计算乙的成绩，看看这两个数是否符合条件，符合就计算丙的成绩，之后进行对比。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
int main(void){
    int n,x,y;
    scanf(&quot;%d %d %d&quot;,&amp;n,&amp;x,&amp;y);
    int a=10,b=0;//甲乙成绩肯定是整数
    double c=0;//丙的成绩不一定为整数。即（10-99）
    for(a=99;a&gt;9;a--){//因为甲是两位数，又以甲的最大值为唯一答案，所以要倒序。
        b=(a/10)+(a%10)*10;//利用甲的成绩计算乙的成绩
        if(abs(a-b)*y==x*b){//如果符合此条件那么丙的成绩就可以算出来了。
            c=abs(a-b)*1.0/x;//计算丙的成绩
            printf(&quot;%d &quot;,a);//先输出a的成绩
            if(a==n){//输出对比结果
                printf(&quot;Ping &quot;);
            }else if(a&gt;n){
                printf(&quot;Cong &quot;);
            }else{
                printf(&quot;Gai &quot;);
            }
            if(b==n){
                printf(&quot;Ping &quot;);
            }else if(b&gt;n){
                printf(&quot;Cong &quot;);
            }else{
                printf(&quot;Gai &quot;);
            }
            if(c==n*1.0){//c的成绩可能为浮点数，所以左右多应该为浮点数
                printf(&quot;Ping&quot;);
            }else if(c&gt;n*1.0){
                printf(&quot;Cong&quot;);
            }else{
                printf(&quot;Gai&quot;);
            }
            return 0;//找到即可退出程序。
        }
    }
    printf(&quot;No Solution&quot;);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1088</title>
    <url>/2019/10/16/PTA-Basic-1088/</url>
    <content><![CDATA[<p>题目：<br>当自然数 n 依次取 1、2、3、……、N 时，算式 ⌊n/2⌋+⌊n/3⌋+⌊n/5⌋ 有多少个不同的值？（注：⌊x⌋ 为取整函数，表示不超过 x 的最大自然数，即 x 的整数部分。）</p>
<p>输入格式：<br>输入给出一个正整数 N（2≤N≤10<br>​4<br>​​ ）。</p>
<p>输出格式：<br>在一行中输出题面中算式取到的不同值的个数。</p>
<p>输入样例：</p>
<pre><code>2017</code></pre><p>输出样例：</p>
<pre><code>1480</code></pre><p>思路：利用此函数的递增性。<br>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int main(void){
    int n;
    int time=0;
    int last=-1;//初始一个数为-1，因为n为任何正数，值都不可能为-1
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++){
        int k=i/2+i/3+i/5;
        if(k==last){//如果与上一个相同就跳过此次
            continue;
        }else{
            time++;
            last=k;
        }
    }
    printf(&quot;%d&quot;,time);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1092</title>
    <url>/2019/10/16/PTA-Basic-1092/</url>
    <content><![CDATA[<p>题目：</p>
<p>月饼是久负盛名的中国传统糕点之一，自唐朝以来，已经发展出几百品种。</p>
<p>mk.jpg</p>
<p>若想评比出一种“最好吃”的月饼，那势必在吃货界引发一场腥风血雨…… 在这里我们用数字说话，给出全国各地各种月饼的销量，要求你从中找出销量冠军，认定为最好吃的月饼。</p>
<p>输入格式：<br>输入首先给出两个正整数 N（≤1000）和 M（≤100），分别为月饼的种类数（于是默认月饼种类从 1 到 N 编号）和参与统计的城市数量。</p>
<p>接下来 M 行，每行给出 N 个非负整数（均不超过 1 百万），其中第 i 个整数为第 i 种月饼的销量（块）。数字间以空格分隔。</p>
<p>输出格式：<br>在第一行中输出最大销量，第二行输出销量最大的月饼的种类编号。如果冠军不唯一，则按编号递增顺序输出并列冠军。数字间以 1 个空格分隔，行首尾不得有多余空格。</p>
<p>输入样例：</p>
<pre><code>5 3
1001 992 0 233 6
8 0 2018 0 2008
36 18 0 1024 4</code></pre><p>输出样例：</p>
<pre><code>2018
3 5</code></pre><p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
long long moonBin[1000];
int main(void){
    int n,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    long val;
    long long maxsale=0;
    for(int i=0;i&lt;m;i++){
        for(int j=0;j&lt;n;j++){
            scanf(&quot;%ld&quot;,&amp;val);
            moonBin[j]=moonBin[j]+val;
            if(moonBin[j]&gt;maxsale){
                maxsale=moonBin[j];
            }
        }
    }
    printf(&quot;%ld\n&quot;,maxsale);
    int flag=0;
    for(int i=0;i&lt;n;i++){
        if(maxsale==moonBin[i]){
            if(flag){
                printf(&quot; &quot;);
            }else{
                flag=1;
            }
            printf(&quot;%d&quot;,i+1);
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1086</title>
    <url>/2019/10/16/PTA-Basic-1086/</url>
    <content><![CDATA[<p>题目：</p>
<p>做作业的时候，邻座的小盆友问你：“五乘以七等于多少？”你应该不失礼貌地围笑着告诉他：“五十三。”本题就要求你，对任何一对给定的正整数，倒着输出它们的乘积。</p>
<p><img src="https://images.ptausercontent.com/0c3a4497-27c3-45ea-9c8e-5a1ab2df48af.jpg" alt=""></p>
<p>输入格式：<br>输入在第一行给出两个不超过 1000 的正整数 A 和 B，其间以空格分隔。</p>
<p>输出格式：<br>在一行中倒着输出 A 和 B 的乘积。</p>
<p>输入样例：</p>
<pre><code>5 7</code></pre><p>输出样例：</p>
<pre><code>53</code></pre><p>分析：不超过1000，那么乘积就不会超过1000000，int足够了。计算乘积存入数组，对结果不断取余，不断存入数组，直到为0，最后倒着输出数组。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main(void){
    int n,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    int c=n*m;
    int i=0;
    int result[20];
    int re=0;
    if(c==0){//注意为0是，直接输，出有一个测试点对应这个。
        printf(&quot;%d&quot;,c);
        return 0;
    }
    while(c!=0){
        result[i++]=c%10; 
        c=c/10;
    }
    for(int j=0;j&lt;i;j++){
        re=re*10+result[j];
    }
    printf(&quot;%d&quot;,re);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1090</title>
    <url>/2019/10/16/PTA-Basic-1090/</url>
    <content><![CDATA[<p>题目：</p>
<p>集装箱运输货物时，我们必须特别小心，不能把不相容的货物装在一只箱子里。比如氧化剂绝对不能跟易燃液体同箱，否则很容易造成爆炸。</p>
<p>本题给定一张不相容物品的清单，需要你检查每一张集装箱货品清单，判断它们是否能装在同一只箱子里。</p>
<p>输入格式：<br>输入第一行给出两个正整数：N (≤10<br>​4<br>​​ ) 是成对的不相容物品的对数；M (≤100) 是集装箱货品清单的单数。</p>
<p>随后数据分两大块给出。第一块有 N 行，每行给出一对不相容的物品。第二块有 M 行，每行给出一箱货物的清单，格式如下：</p>
<p>K G[1] G[2] … G[K]<br>其中 K (≤1000) 是物品件数，G[i] 是物品的编号。简单起见，每件物品用一个 5 位数的编号代表。两个数字之间用空格分隔。</p>
<p>输出格式：<br>对每箱货物清单，判断是否可以安全运输。如果没有不相容物品，则在一行中输出 Yes，否则输出 No。</p>
<p>输入样例：</p>
<pre><code>6 3
20001 20002
20003 20004
20005 20006
20003 20001
20005 20004
20004 20006
4 00001 20004 00002 20003
5 98823 20002 20003 20006 10010
3 12345 67890 23333</code></pre><p>输出样例：</p>
<pre><code>No
Yes
Yes</code></pre><p>分析：定义一个结构体，包含此物体的不能放在一起的物品的个数，与它不能放在一起的物体的数组。定义一个图，用于标记出现过的危险品，然后对后来的危险品，先在图中看看有没有出现过，有就遍历它之后的数组部分看看后面的部分有没有它的危险品。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
int contains(int key,int value);
typedef struct danger{
    int time;
    int op[999];
};
int map[100000];//用于标记某个危险品是否出现过
struct danger dangers[100000];
int main(void){
    int n,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    int key,value;
    for(int i=0;i&lt;n;i++){
        scanf(&quot;%d %d&quot;,&amp;key,&amp;value);
        if(map[key]==0)//此物品之前没有与它不能放在一起的物体
            dangers[key].time=0;//将对应的下标置为0
        if(map[value]==0)//同上
            dangers[value].time=0;
        dangers[key].op[dangers[key].time]=value;//此处为互相标记
        dangers[key].time++;
        dangers[value].op[dangers[value].time]=key;
        dangers[value].time++;
        map[key]=1;
        map[value]=1;
    }
    for(int i=0;i&lt;m;i++){
        int num=0;
        scanf(&quot;%d&quot;,&amp;num);
        int things[num];
        int flag=0;
        for(int j=0;j&lt;num;j++){//将某一行的危险品全部存入数组
            scanf(&quot;%d&quot;,&amp;things[j]);
        }
        for(int j=0;j&lt;num;j++){//遍历数组查看有没有排斥的
            if(map[things[j]]==0){//图中没有说明之前没有出现过
                continue;
            }else{//图中有说明之前出先过了，遍历它之后的部分看看有没有危险品
                for(int index=j+1;index&lt;num;index++){
                    if(contains(things[j],things[index])){//后面有危险品就标记一下，并跳出
                        flag=1;
                        break;
                    }
                }
            }
            if(flag){//如果标记过了
                    printf(&quot;No\n&quot;);
                    break;
                }
        }
        if(!flag){
            printf(&quot;Yes\n&quot;);
        }
    }
    return 0;
} 
int contains(int key,int value){
    for(int i=0;i&lt;dangers[key].time;i++){
        if(dangers[key].op[i]==value){
            return 1;
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1094</title>
    <url>/2019/10/16/PTA-Basic-1094/</url>
    <content><![CDATA[<p>###题目描述</p>
<p>2004 年 7 月，谷歌在硅谷的 101 号公路边竖立了一块巨大的广告牌（如下图）用于招聘。内容超级简单，就是一个以 .com 结尾的网址，而前面的网址是一个 10 位素数，这个素数是自然常数 e 中最早出现的 10 位连续数字。能找出这个素数的人，就可以通过访问谷歌的这个网站进入招聘流程的下一步。</p>
<p><img src="https://images.ptausercontent.com/57148679-d574-4f49-b048-775c6c07791c.jpg" alt=""></p>
<p>自然常数 e 是一个著名的超越数，前面若干位写出来是这样的：e = 2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427427466391932003059921… 其中粗体标出的 10 位数就是答案。</p>
<p>本题要求你编程解决一个更通用的问题：从任一给定的长度为 L 的数字中，找出最早出现的 K 位连续数字所组成的素数。</p>
<p>输入格式：<br>输入在第一行给出 2 个正整数，分别是 L（不超过 1000 的正整数，为数字长度）和 K（小于 10 的正整数）。接下来一行给出一个长度为 L 的正整数 N。<br>###格式<br>输出格式：<br>在一行中输出 N 中最早出现的 K 位连续数字所组成的素数。如果这样的素数不存在，则输出 404。注意，原始数字中的前导零也计算在位数之内。例如在 200236 中找 4 位素数，0023 算是解；但第一位 2 不能被当成 0002 输出，因为在原始数字中不存在这个 2 的前导零。<br>###样例<br>输入样例 1：</p>
<pre><code>20 5
23654987725541023819</code></pre><p>输出样例 1：</p>
<pre><code>49877</code></pre><p>输入样例 2：</p>
<pre><code>10 3

2468024680</code></pre><p>输出样例 2：</p>
<pre><code>404</code></pre><p>代码：</p>
]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1091</title>
    <url>/2019/10/16/PTA-Basic-1091/</url>
    <content><![CDATA[<p>题目：<br>如果某个数 K 的平方乘以 N 以后，结果的末尾几位数等于 K，那么就称这个数为“N-自守数”。例如 3×92<br>​2<br>​​ =25392，而 25392 的末尾两位正好是 92，所以 92 是一个 3-自守数。</p>
<p>本题就请你编写程序判断一个给定的数字是否关于某个 N 是 N-自守数。</p>
<p>输入格式：<br>输入在第一行中给出正整数 M（≤20），随后一行给出 M 个待检测的、不超过 1000 的正整数。</p>
<p>输出格式：<br>对每个需要检测的数字，如果它是 N-自守数就在一行中输出最小的 N 和 N*K^<br>​2<br>​​  的值，以一个空格隔开；否则输出 No。注意题目保证 N&lt;10。</p>
<p>输入样例：</p>
<pre><code>3
92 5 233</code></pre><p>输出样例：</p>
<pre><code>3 25392
1 25
No</code></pre><p>分析：题目说了保证n&lt;10，即在1-9之中找就可以了，定义一个判断是不是字守数的函数，然后对每个数字判断就可以了。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
int re(long value,long contains);
int main(void){
    int n;
    int key;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++){
        scanf(&quot;%d&quot;,&amp;key);
        int k=1;
        for(;k&lt;10;k++){
            if(re(key*key*k,key)){
                printf(&quot;%d %ld\n&quot;,k,key*key*k);
                break;
            }
        }
        if(k&gt;9){
            printf(&quot;No\n&quot;);
        }
    }
}
int re(long value,long contains){
    int i=0;
    long key=contains;
    do{
        i++;
        key=key/10;
    }while(key);
    if((value-contains)%((int)pow(10,i))==0){
        return 1;
    }    
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/05/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>PTA-Basic-1089</title>
    <url>/2019/10/16/PTA-Basic-1089/</url>
    <content><![CDATA[<p>题目：</p>
<p>以下文字摘自《灵机一动·好玩的数学》：“狼人杀”游戏分为狼人、好人两大阵营。在一局“狼人杀”游戏中，1 号玩家说：“2 号是狼人”，2 号玩家说：“3 号是好人”，3 号玩家说：“4 号是狼人”，4 号玩家说：“5 号是好人”，5 号玩家说：“4 号是好人”。已知这 5 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。扮演狼人角色的是哪两号玩家？</p>
<p>本题是这个问题的升级版：已知 N 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。要求你找出扮演狼人角色的是哪几号玩家？</p>
<p>输入格式：<br>输入在第一行中给出一个正整数 N（5≤N≤100）。随后 N 行，第 i 行给出第 i 号玩家说的话（1≤i≤N），即一个玩家编号，用正号表示好人，负号表示狼人。</p>
<p>输出格式：<br>如果有解，在一行中按递增顺序输出 2 个狼人的编号，其间以空格分隔，行首尾不得有多余空格。如果解不唯一，则输出最小序列解 —— 即对于两个序列 A=a[1],…,a[M] 和 B=b[1],…,b[M]，若存在 0≤k&lt;M 使得 a[i]=b[i] （i≤k），且 a[k+1]&lt;b[k+1]，则称序列 A 小于序列 B。若无解则输出 No Solution。</p>
<p>输入样例 1：</p>
<pre><code>5
-2
+3
-4
+5
+4</code></pre><p>输出样例 1：</p>
<pre><code>1 4</code></pre><p>输入样例 2：</p>
<pre><code>6
+6
+3
+1
-5
-2
+4</code></pre><p>输出样例 2（解不唯一）：</p>
<pre><code>1 5</code></pre><p>输入样例 3：</p>
<pre><code>5
-2
-3
-4
-5
-1</code></pre><p>输出样例 3：</p>
<pre><code>No Solution</code></pre><p>分析：<br>定义一个数组存储每个人说的话，定义一个身份数组存储每个人的身份初始为1，每个人都是村民。然后双重循环，假设第i与第j个人是狼人。之后在已经有狼人的情况下统计说谎的次数（此处题目的合格条件：村民中有一个说假话，狼人中有一个人说谎话）如果找到合格的输出终止程序，没找到输出No Solution。<br>注意：第i个说的可以是第任意个人，而不是顺序说下一个。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;//此题目中我们的两个数组都舍弃了一个空间为了方便思考
#include&lt;math.h&gt;
int main(void){
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    int a[n+1];
    int b[n+1];
    for(int i=1;i&lt;=n;i++){
        scanf(&quot;%d&quot;,&amp;a[i]);
        b[i]=1;//顺便初始化身份数组
    }
    for(int i=1;i&lt;=n;i++){
        for(int j=i+1;j&lt;=n;j++){//假设i,j个人是狼人
            b[i]=0;
            b[j]=0;
            int langtime=0;//狼人的说谎次数
            int time=0;//好人的说谎次数
            for(int x=1;x&lt;=n;x++){
                if((a[x]&gt;0&amp;&amp;b[abs(a[x])]==0)||(a[x]&lt;0&amp;&amp;b[abs(a[x])]==1)){
                    if(x==i||x==j)
                        langtime++;
                    else
                        time++;
                }
            }
            if(time==1&amp;&amp;langtime==1){//如果符合题目条件
                printf(&quot;%d %d&quot;,i,j);
                return 0;
            }//否则还原身份数组
            b[i]=1;
            b[j]=1;

        }
    }
    printf(&quot;No Solution&quot;);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表</title>
    <url>/2019/11/20/%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>单链表：顺序表的链表实现。</p>
<p>建议放入头文件。</p>
<p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#define ElementType char
typedef struct LinkNode{
    ElementType data;
    struct LinkNode *next;//内部使用此结构体时，要加struct
}LinkList;
LinkList* List_HeadInsert(LinkList *s){
    s=(LinkList *)malloc(sizeof(struct LinkNode));//头结点
    s-&gt;next=NULL;
    LinkList *node;
    ElementType data;
    printf(&quot;请输入用于构建单链表的字符（以空格分隔）以换行结尾:&quot;);
    data=getchar();
    while(data!=&apos;\n&apos;){
        getchar();
        node=(LinkList *)malloc(sizeof(struct LinkNode));
        node-&gt;data=data;
        node-&gt;next=s-&gt;next;
        s-&gt;next=node;
        data=getchar();
    }
    return s;
}
LinkList* List_TailInsert(LinkList *s){
    s=(LinkList *)malloc(sizeof(struct LinkNode));//头结点
    s-&gt;next=NULL;
    LinkList *r=s;
    LinkList *node;
    ElementType data;
    printf(&quot;请输入用于构建单链表的字符（以空格分隔）以换行结尾:&quot;);
    data=getchar();
    while(data!=&apos;\n&apos;){
        getchar();
        node=(LinkList *)malloc(sizeof(struct LinkNode));
        node-&gt;data=data;
        node-&gt;next=NULL;
        r-&gt;next=node;
        r=node;
        data=getchar();
    }
    return s;
}
int Length(LinkList *s){
    if(!s)
        return 0;
    int len=0;
    s=s-&gt;next;
    while(s){
        len++;
        s=s-&gt;next;
    }
    return len;
}
LinkList* GetElem(LinkList *s,int i){
    if(i&lt;0){
        return NULL;
    }
    int curr=0;
    LinkList* currNode=s;
    while(currNode&amp;&amp;curr&lt;i){
        curr++;
        currNode=currNode-&gt;next;
    }
    return currNode;
}
LinkList *LocateElement(LinkList *l,ElementType e){
    LinkList *r=l-&gt;next;
    while(r&amp;&amp;r-&gt;data!=e)r=r-&gt;next;
    return r;
}
void ListInsert(LinkList *s,int pos,ElementType e){
    if(pos&lt;1||pos&gt;Length(s)){
        printf(&quot;位置不合法\n&quot;);
        return;
    }
    LinkList *r=GetElem(s,pos-1);
    LinkList *node=(LinkList *)malloc(sizeof(struct LinkNode));
    node-&gt;data=e;
    node-&gt;next=r-&gt;next;
    r-&gt;next=node;
}
void ListDelete(LinkList *l,int pos){
    if(pos&lt;1||pos&gt;Length(l)){
        printf(&quot;位置不合法\n&quot;);
        return;
    }
    LinkList *r=GetElem(l,pos-1);
    LinkList *q= r-&gt;next; 
    r-&gt;next=q-&gt;next;
    free(q);
}
int isEmpty(LinkList *l){
    if(l==NULL||l-&gt;next==NULL){
        return 1;
    }
    return 0;
}
void PrintList(LinkList *l){
    if(!isEmpty(l)){
        int flag=1;
        LinkList *temp=l-&gt;next;
        while(temp){
            if(flag){
                printf(&quot;%c&quot;,temp-&gt;data);
                flag=0; 
            }else{
                printf(&quot;-&gt;%c&quot;,temp-&gt;data);
            }
            temp=temp-&gt;next;
        }
    }else{
        printf(&quot;链表为空\n&quot;);
    }
}
void DestroyList(LinkList *s){
    free(s);
}
int main(void){
    LinkList *s;
    s=List_TailInsert(s);
    ListInsert(s,3,&apos;k&apos;);
    ListDelete(s,2); 
    PrintList(s);
    printf(&quot;\n%d&quot;,Length(s));
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1095</title>
    <url>/2019/10/16/PTA-Basic-1095/</url>
    <content><![CDATA[<p>题目：</p>
<p>PAT 准考证号由 4 部分组成：</p>
<p>第 1 位是级别，即 T 代表顶级；A 代表甲级；B 代表乙级；<br>第 2<del>4 位是考场编号，范围从 101 到 999；<br>第 5</del>10 位是考试日期，格式为年、月、日顺次各占 2 位；<br>最后 11~13 位是考生编号，范围从 000 到 999。<br>现给定一系列考生的准考证号和他们的成绩，请你按照要求输出各种统计信息。</p>
<p>输入格式：<br>输入首先在一行中给出两个正整数 N（≤10<br>​4<br>​​ ）和 M（≤100），分别为考生人数和统计要求的个数。</p>
<p>接下来 N 行，每行给出一个考生的准考证号和其分数（在区间 [0,100] 内的整数），其间以空格分隔。</p>
<p>考生信息之后，再给出 M 行，每行给出一个统计要求，格式为：类型 指令，其中</p>
<p>类型 为 1 表示要求按分数非升序输出某个指定级别的考生的成绩，对应的 指令 则给出代表指定级别的字母；<br>类型 为 2 表示要求将某指定考场的考生人数和总分统计输出，对应的 指令 则给出指定考场的编号；<br>类型 为 3 表示要求将某指定日期的考生人数分考场统计输出，对应的 指令 则给出指定日期，格式与准考证上日期相同。<br>输出格式：<br>对每项统计要求，首先在一行中输出 Case #: 要求，其中 # 是该项要求的编号，从 1 开始；要求 即复制输入给出的要求。随后输出相应的统计结果：</p>
<p>类型 为 1 的指令，输出格式与输入的考生信息格式相同，即 准考证号 成绩。对于分数并列的考生，按其准考证号的字典序递增输出（题目保证无重复准考证号）；<br>类型 为 2 的指令，按 人数 总分 的格式输出；<br>类型 为 3 的指令，输出按人数非递增顺序，格式为 考场编号 总人数。若人数并列则按考场编号递增顺序输出。<br>如果查询结果为空，则输出 NA。</p>
<p>输入样例：</p>
<pre><code>8 4
B123180908127 99
B102180908003 86
A112180318002 98
T107150310127 62
A107180908108 100
T123180908010 78
B112160918035 88
A107180908021 98
1 A
2 107
3 180908
2 999</code></pre><p>输出样例：</p>
<pre><code>Case 1: 1 A
A107180908108 100
A107180908021 98
A112180318002 98
Case 2: 2 107
3 260
Case 3: 3 180908
107 2
123 2
102 1
Case 4: 2 999
NA</code></pre><p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

struct id{
        char str[14];
        char level[2];
        int room;
        int date;
        int num;
        int score;
};

int cmp(const void *a, const void *b)
{
        struct id *ida = (struct id*)a, *idb = (struct id*)b;
        if (ida-&gt;score != idb-&gt;score)
                return idb-&gt;score - ida-&gt;score;
        return strcmp(ida-&gt;str, idb-&gt;str);
}

int type1(struct id ids[], int n, int i);
int type2(struct id ids[], int n, int i);
int type3(struct id ids[], int n, int i);

int main()
{
        struct id ids[10000];
        int n, m, type;
        int i;
        char level[2];

        scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
        for (i = 0; i &lt; n; i++) {
                scanf(&quot;%s %d&quot;, ids[i].str, &amp;ids[i].score);
                sscanf(ids[i].str, &quot;%1s%3d%6d%3d&quot;, ids[i].level,
                                &amp;ids[i].room, &amp;ids[i].date, &amp;ids[i].num);
        }

        qsort(ids, n, sizeof(ids[0]), cmp);

        for (i = 0; i &lt; m; i++) {
                scanf(&quot;%d&quot;, &amp;type);
                if (type == 1)
                        type1(ids, n, i);
                else if (type == 2)
                        type2(ids, n, i);
                else if (type == 3)
                        type3(ids, n, i);
        }

        return 0;
}

int type1(struct id ids[], int n, int i)
{
        char level[2];
        int f = 1, j;
        scanf(&quot;%1s&quot;, level);
        printf(&quot;Case %d: %d %c\n&quot;, i + 1, 1, level[0]);
        for (j = 0; j &lt; n; j++)
                if (ids[j].level[0] == level[0]) {
                        f = 0;
                        printf(&quot;%s %d\n&quot;, ids[j].str,ids[j].score);
                }
        if (f)
                puts(&quot;NA&quot;);
        return 0;
}

int type2(struct id ids[], int n, int i)
{
        int room, sum = 0, count = 0;
        int j, f = 1;

        scanf(&quot;%d&quot;, &amp;room);
        printf(&quot;Case %d: %d %d\n&quot;, i + 1, 2, room);
        for (j = 0; j &lt; n; j++)
                if (ids[j].room == room) {
                        f = 0;
                        count++;
                        sum += ids[j].score;
                }
        if (f)
                puts(&quot;NA&quot;);
        else
                printf(&quot;%d %d\n&quot;, count, sum);

        return 0;
}

int type3(struct id ids[], int n, int i)
{
        int date, max = 0, rooms[1000] = {0};
        int f = 1, j;

        scanf(&quot;%d&quot;, &amp;date);
        printf(&quot;Case %d: %d %06d\n&quot;, i + 1, 3, date);
        for (j = 0; j &lt; n; j++)
                if (ids[j].date == date) {
                        f = 0;
                        rooms[ids[j].room]++;
                        if (max &lt; rooms[ids[j].room])
                                max = rooms[ids[j].room];
                }
        if (f)
                puts(&quot;NA&quot;);
        else
                for (; max &gt; 0; max--)
                        for (j = 101; j &lt; 1000; j++)
                                if (rooms[j] == max)
                                        printf(&quot;%d %d\n&quot;, j, max);

        return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>双链表</title>
    <url>/2019/11/20/%E5%8F%8C%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>在单链表的基础上添加了一个指向前面结点的指针。</p>
<p>代码：</p>
<pre><code>#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;
#define ElementType char
typedef struct DNode{
    ElementType data;
    struct DNode* prior;
    struct DNode* next; 
}DLinkList,DNode;
DLinkList* DList_HeadInsert(DLinkList *s){
    s=(DNode *)malloc(sizeof(DNode));//头结点
    s-&gt;prior=NULL;
    s-&gt;next=NULL;
    DNode *node;
    ElementType data;
    printf(&quot;请输入用于构建单链表的字符（以空格分隔）以换行结尾:&quot;);
    data=getchar();
    while(data!=&apos;\n&apos;){
        getchar();
        node=(DNode *)malloc(sizeof(DNode));
        node-&gt;data=data;
        DNode *nextNode=s-&gt;next;
        if(nextNode){
            node-&gt;next=nextNode;
            node-&gt;prior=nextNode-&gt;prior;
            nextNode-&gt;prior=node;
            s-&gt;next=node;
        }else{
            node-&gt;prior=s;
            node-&gt;next=s-&gt;next;
            s-&gt;next=node;
        }
        data=getchar();
    }
    return s;
}
DLinkList* DList_TailInsert(DLinkList *s){
    s=(DLinkList *)malloc(sizeof(DNode));//头结点
    s-&gt;next=NULL;
    DNode *r=s;
    DNode *node;
    ElementType data;
    printf(&quot;请输入用于构建单链表的字符（以空格分隔）以换行结尾:&quot;);
    data=getchar();
    while(data!=&apos;\n&apos;){
        getchar();
        node=(DNode *)malloc(sizeof(DNode));
        node-&gt;data=data;
        node-&gt;next=NULL;
        node-&gt;prior=r;
        r-&gt;next=node;
        r=node;
        data=getchar();
    }
    return s;
}
int Length(DLinkList *s){
    if(!s)
        return 0;
    int len=0;
    s=s-&gt;next;
    while(s){
        len++;
        s=s-&gt;next;
    }
    return len;
}
DNode* GetElem(DLinkList *s,int i){
    if(i&lt;0){
        return NULL;
    }
    int curr=0;
    DNode* currNode=s;
    while(currNode&amp;&amp;curr&lt;i){
        curr++;
        currNode=currNode-&gt;next;
    }
    return currNode;
}
DNode *LocateElement(DLinkList *l,ElementType e){
    DLinkList *r=l-&gt;next;
    while(r&amp;&amp;r-&gt;data!=e)r=r-&gt;next;
    return r;
}
int isEmpty(DLinkList *l){
    if(l==NULL||l-&gt;next==NULL){
        return 1;
    }
    return 0;
}
void DListInsert(DLinkList *s,int pos,ElementType e){
    if(pos&lt;1||pos&gt;Length(s)){
        printf(&quot;位置不合法\n&quot;);
        return;
    }
    DNode *r=GetElem(s,pos-1);
    DNode *node=(DNode *)malloc(sizeof(DNode));
    node-&gt;data=e;
    node-&gt;next=r-&gt;next;
    r-&gt;next-&gt;prior=node;
    node-&gt;prior=r;
    r-&gt;next=node;
}
void DListDelete(DLinkList *l,int pos){
    if(pos&lt;1||pos&gt;Length(l)){
        printf(&quot;位置不合法\n&quot;);
        return;
    }
    DNode *r=GetElem(l,pos-1);
    DNode *q= r-&gt;next; 
    q-&gt;next-&gt;prior=r;
    r-&gt;next=q-&gt;next;
    free(q);
}
void PrintDList(DLinkList *l){
    if(!isEmpty(l)){
        int flag=1;
        DNode *temp=l-&gt;next;
        while(temp){
            if(flag){
                printf(&quot;%c&quot;,temp-&gt;data);
                flag=0; 
            }else{
                printf(&quot;&lt;=&gt;%c&quot;,temp-&gt;data);
            }
            temp=temp-&gt;next;
        }
    }else{
        printf(&quot;链表为空\n&quot;);
    }
}
void DestroyDList(DLinkList *s){
    free(s);
}
int main(void){
    DLinkList *s=NULL;
    s=DList_TailInsert(s);
    DListInsert(s,0,&apos;x&apos;);
    DListDelete(s,2);
    PrintDList(s);
    printf(&quot;链表长度是：%d&quot;,Length(s));
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1093</title>
    <url>/2019/10/16/PTA-Basic-1093/</url>
    <content><![CDATA[<p>题目：<br>给定两个字符串 A 和 B，本题要求你输出 A+B，即两个字符串的并集。要求先输出 A，再输出 B，但重复的字符必须被剔除。</p>
<p>输入格式：<br>输入在两行中分别给出 A 和 B，均为长度不超过 10<br>​6<br>​​ 的、由可见 ASCII 字符 (即码值为32~126)和空格组成的、由回车标识结束的非空字符串。</p>
<p>输出格式：<br>在一行中输出题面要求的 A 和 B 的和。</p>
<p>输入样例：</p>
<pre><code>This is a sample test
to show you_How it works</code></pre><p>输出样例：</p>
<pre><code>This ampletowyu_Hrk</code></pre><p>代码：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
char a[2000002];
char b[1000001];
char *del(char *s,char c){
    char *src,*dst;
    for(src=dst=s;*src!=&apos;\0&apos;;src++){
        *dst=*src;
        if(*dst!=c)
            dst++;
    }
    *dst=&apos;\0&apos;;
    return dst;
} 
int main(void){
    gets(a);
    char *s=a;//如果先先连接再去重复的话操作时间比对每个先去重再连接再去重用的时间长。
    while(*s){
        del(s+1,*s);
        s++;
    }
    gets(b);
    s=b;
    while(*s){
        del(s+1,*s);
        s++;
    }
    strcat(a,b);
    s=a;
    while(*s){
        del(s+1,*s);
        s++;
    }
    puts(a);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>串</title>
    <url>/2019/11/21/%E4%B8%B2/</url>
    <content><![CDATA[<p>注意此处的串的实现中的模式匹配，并不是最优解法（使用KMP算法）。建议直接放入头文件。此外，但凡程序中涉及的位置皆为位序（从1开始），在某些部分，如果使用坐标作为参数，可能会产生错误，不过基本上这些错误，程序中都有所应对。</p>
<pre><code>#ifndef STRING_H_INCLUDED
#define STRING_H_INCLUDED
#define MAXSIZE 255//默认最大长度设置为255
typedef struct{
    char strs[MAXSIZE];
    int len;
}String;
String* StrInit(String *s){//串的初始化
    s=(String *)malloc(sizeof(String));
    s-&gt;len=0;
    return s;
}
void StrAppend(String *s,char ch){//将字符追加到串上
    if(s-&gt;len&lt;MAXSIZE){
        s-&gt;strs[(s-&gt;len)++]=ch;
    }else{
        printf(&quot;string is filled\n&quot;);
    }
}
void StrAssign(String *s,char *p){//将指向的字符串赋值链接到s后面
    while(*p!=&apos;\0&apos;){
        StrAppend(s,*p);
        p++;
    }
}
void StrCopy(String *s1,String *s2){//将s2复制给s1
    if(s2-&gt;len==0){
            return;
    }
        s1-&gt;len=0;
    for(int i=0;i&lt;(s2-&gt;len);i++){
        StrAppend(s1,s2-&gt;strs[i]);
    }
}
int StrEmpty(String *s){//判断串是否为空
    if(s==NULL)
        return 1;
    if(s!=NULL)
        return s-&gt;len==0;

        printf(&quot;must initial\n&quot;);
    return 1;
}
int StrLength(String *s){//求串长度
    if(s!=NULL)
    {
        return s-&gt;len;
    }
    else
    {
        printf(&quot;must initial\n&quot;);
        return 0;
    }
}
String * SubString(String *s,int pos,int len){//求子串
    if(pos-1+len&gt;(s-&gt;len)){
        printf(&quot;the length of the string is over MAXSIZE\n&quot;);
        return NULL;
    }else{
        String *temp;
        temp=StrInit(temp);
        for(int i=pos-1;i&lt;len;i++){
            StrAppend(temp,s-&gt;strs[i]);
        }
        return temp;
    }
}
String * Conact(String *s1,String *s2){//连接两个字符串，这里并不是最好的解法。
    String *result;
    if(StrLength(s1)+StrLength(s2)&gt;MAXSIZE){
        printf(&quot;the length of the string is over MAXSIZE\n&quot;);
        result=NULL;
    }else{
        result=StrInit(result);
        for(int i=0;i&lt;StrLength(s1);i++){
            StrAppend(result,s1-&gt;strs[i]);
        }

        for(int i=0;i&lt;StrLength(s2);i++){
            StrAppend(result,s2-&gt;strs[i]);
        }
    }
        return result;
}
int Index(String *s,int pos,String *sub){//求某个字符串在串中的起始位置
    if((pos+StrLength(sub)&gt;=MAXSIZE)){
        printf(&quot;not suitable\n&quot;);
        return 0;
    }
    int i=pos-1,j=0;
    while(i&lt;(s-&gt;len)&amp;&amp;j&lt;(sub-&gt;len)){
        if(s-&gt;strs[i]==sub-&gt;strs[j]){
            ++i;
            ++j;
        }else{
            i=i-j+1;
            j=0;
        }
    }
    if(j&gt;=sub-&gt;len)
        return i-sub-&gt;len+1;
    else
        return 0;
}
String * StrInsert(String *s,String *r,int pos){/将r插入到s的第pos个位置处
    String *result;
    if(s-&gt;len+r-&gt;len&gt;=MAXSIZE){
        printf(&quot;the length of the result is over MAXSIZE\n&quot;);
        result=NULL;
    }else{
        result=StrInit(result);
        for(int i=0;i&lt;pos-1;i++){
            StrAppend(result,s-&gt;strs[i]);
        }
        for(int i=0;i&lt;r-&gt;len;i++){
            StrAppend(result,r-&gt;strs[i]);
        }
        for(int i=pos-1;i&lt;s-&gt;len;i++){
            StrAppend(result,s-&gt;strs[i]);
        }
    }
        return result;
}
void ClearString(String *s){//清空串
    s-&gt;len=0;
}
String * StrDelete(String *s,int pos,int len){//删除串中指定位置开始，长度为len的字符串。
    String *result;
    result=StrInit(result);
    for(int i=0;i&lt;pos-1;i++){
        StrAppend(result,s-&gt;strs[i]);
    }
    for(int i=pos+len-1;i&lt;s-&gt;len;i++){
        StrAppend(result,s-&gt;strs[i]);
    }
    return result;
}
String * StrReplace(String *s,String *target,String *r){//将s中的所有target子串替换为r
    if(target-&gt;len==0){
        return s;
    }
    int index=Index(s,1,target);
    while(index){
        s=StrDelete(s,index,target-&gt;len);
        s=StrInsert(s,r,index);
        index=Index(s,1,target);
    }
    return s;
}
void StrPrint(String *s){//打印字符串
    if(s==NULL)
    {
        printf(&quot;must initial\n&quot;);
    }
    else
    {
        for(int i=0;i&lt;s-&gt;len;i++){
            printf(&quot;%c&quot;,s-&gt;strs[i]);
        }
    }
}
void DestroyString(String *s){//销毁字符串
    s-&gt;len=0;
    free(s);
}
#endif // STRING_H_INCLUDED</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA-Basic-1057</title>
    <url>/2019/09/29/PTA-Basic-1057/</url>
    <content><![CDATA[<p>给定一串长度不超过 10<br>​5<br>​​  的字符串，本题要求你将其中所有英文字母的序号（字母 a-z 对应序号 1-26，不分大小写）相加，得到整数 N，然后再分析一下 N 的二进制表示中有多少 0、多少 1。例如给定字符串 PAT (Basic)，其字母序号之和为：16+1+20+2+1+19+9+3=71，而 71 的二进制是 1000111，即有 3 个 0、4 个 1。</p>
<p>输入格式：<br>输入在一行中给出长度不超过 10<br>​5<br>​​ 、以回车结束的字符串。</p>
<p>输出格式：<br>在一行中先后输出 0 的个数和 1 的个数，其间以空格分隔。</p>
<p>输入样例：</p>
<pre><code>PAT (Basic)</code></pre><p>输出样例：</p>
<pre><code>3 4</code></pre><p>分析：</p>
<p>一个一个字符读取并将输入的字符化为小写形式，如果是字母就将其对应的值加到和上。定义一个长度为2的整型数组，0位存储二进制中0的个数，1位存储二进制中1的个数，二进制位数数字除以2的余数，注意数字为0数二进制位的0位不为1，即数字为0时不计算其二进制位。</p>
<p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include&lt;string.h&gt;
int sum(char *a);
int main()
{
    char ch=&apos;\0&apos;;
    int total=0;
    while((ch=getchar())!=&apos;\n&apos;){
        ch=tolower(ch);
        if(ch&lt;=&apos;z&apos;&amp;&amp;ch&gt;=&apos;a&apos;){
            total=total+ch-&apos;a&apos;+1;
        }
    }
    int a[]={0,0};
    while(total){
            a[total%2]++;
            total=total/2;
    }
    printf(&quot;%d %d&quot;,a[0],a[1]);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>PTA</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-9</title>
    <url>/2020/05/13/LeetCode-9/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<p>#回文数<br>##题目内容<br>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br>##示例<br>###示例 1<br>    输入: 121<br>    输出: true<br>###示例 2<br>    输入: -121<br>    输出: false<br>    解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。<br>###示例 3<br>    输入: 10<br>    输出: false<br>    解释: 从右向左读, 为 01 。因此它不是一个回文数。<br>##思路1-反转一半数字<br>    由于数字对称的特点，那么一半的反转，等于另外一半。<br>##代码1<br>    public boolean isPalindrome(int x) {<br>        int revert = 0;<br>        if(x&lt;0 || (x%10 ==0 &amp;&amp; x!=0)){//此处是如果为10的倍数或者负数，但不是0，则不是对称的。<br>            return false;<br>        }//由于对称数的特性，左边-中间与右边-中间的数值应该一样<br>        while(revert&lt;x){//反转的数等于时表名有偶数个数位，&gt;时表示奇数个数位<br>            revert =revert*10+x%10;<br>            x=x/10;<br>        }<br>        if(revert==x || revert/10 ==x){//防止有奇数个数位，那么就应该取整再比较<br>            return true;<br>        }<br>        return false;<br>    }<br>    ###时间复杂度：O(n^2)<br>##思路2-字符串法</p>
<pre><code>将数字转化为字符串，调用反转函数，返回两者比对值。</code></pre>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-简单</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-8</title>
    <url>/2020/05/13/LeetCode-8/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<p>#字符串转整数<br>##题目内容<br>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p>
<p>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。<br>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。<br>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p>
<p>提示：<br>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<p>##示例<br>###示例 1<br>    输入: “42”<br>    输出: 42<br>###示例 2<br>    输入: “   -42”<br>    输出: -42<br>    解释: 第一个非空白字符为 ‘-‘, 它是一个负号。<br>        我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p>
<p>##思路1-逻辑覆盖<br>##代码1<br>    public int myAtoi(String str) {<br>            str=str.trim();<br>            if(str.length()==0)return 0;<br>            char ch;<br>            int flag=1,result=0;<br>            for(int i=0;i&lt;str.length();i++){<br>                ch=str.charAt(i);<br>                if(i==0){<br>                   if(ch==’+’)flag=1;<br>                   else if(ch==’-‘)flag=-1;<br>                   else if(ch&gt;=’0’&amp;ch&lt;=’9’)result=ch-‘0’;<br>                   else return 0;<br>                }else{<br>                    if(ch&gt;=’0’&amp;&amp;ch&lt;=’9’){<br>                        if(result&gt;214748364){<br>                            return flag==1?2147483647:-2147483648;<br>                        }else if(result==214748364){<br>                            if(flag==1&amp;&amp;ch&gt;’7’)return 2147483647;<br>                            if(flag==-1&amp;&amp;ch&gt;’8’)return -2147483648;<br>                        }<br>                        result=result<em>10+ch-‘0’;<br>                    }else{<br>                        break;<br>                    }<br>                }<br>            }<br>            return flag</em>result;<br>        }<br>###时间复杂度：O(n)<br>##思路2-自动机<br>暂时未理解<br><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/solution/zi-fu-chuan-zhuan-huan-zheng-shu-atoi-by-leetcode-/" title="自动机">https://leetcode-cn.com/problems/string-to-integer-atoi/solution/zi-fu-chuan-zhuan-huan-zheng-shu-atoi-by-leetcode-/</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-中等</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-6</title>
    <url>/2020/05/10/LeetCode-6/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<p>#Z字形变换<br>##题目内容<br>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p>
<pre><code>L   C   I   R

E T O E S I I G

E   D   H   N</code></pre><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<p>string convert(string s, int numRows);<br>##示例</p>
<p>###示例 1</p>
<p>输入: s = “LEETCODEISHIRING”, numRows = 3<br>输出: “LCIRETOESIIGEDHN”</p>
<p>###示例 2</p>
<p>输入: s = “LEETCODEISHIRING”, numRows = 4<br>输出: “LDREOEIIECIHNTSG”<br>解释:</p>
<pre><code>L     D     R
E   O E   I I
E C   I H   N
T     S     G</code></pre><p>##思路1-根据规律取字符<br>##代码1<br>        class Solution {<br>            public static String convert(String s, int numRows) {<br>            if(numRows==1)return s;<br>            int n=s.length();<br>            int cycleLen=2*numRows-2;<br>            StringBuilder result=new StringBuilder();<br>            for(int i=0;i&lt;numRows;i++){<br>                for(int j=0;j+i&lt;n;j=j+cycleLen){<br>                    result.append(s.charAt(i+j));<br>                    if(i!=0&amp;&amp;i!=numRows-1&amp;&amp;j+cycleLen-i&lt;n){<br>                        result.append(s.charAt(j+cycleLen-i));//每一次的周长都是cycleLen<br>                    }<br>                }<br>            }<br>            return result.toString();<br>        }<br>    }</p>
<p>###时间复杂度：O(n^2)<br>##思路2-模拟表现<br>    通过从左向右迭代字符串，我们可以轻松地确定字符位于 Z 字形图案中的哪一行。<br>##代码2<br>    public String convert(String s, int numRows) {</p>
<pre><code>    if (numRows == 1) return s;

    List&lt;StringBuilder&gt; rows = new ArrayList&lt;&gt;();
    for (int i = 0; i &lt; Math.min(numRows, s.length()); i++)
        rows.add(new StringBuilder());

    int curRow = 0;
    boolean goingDown = false;

    for (char c : s.toCharArray()) {
        rows.get(curRow).append(c);
        if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown;
        curRow += goingDown ? 1 : -1;
    }

    StringBuilder ret = new StringBuilder();
    for (StringBuilder row : rows) ret.append(row);
    return ret.toString();
}</code></pre>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-中等</category>
        <category>算法类型</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-7</title>
    <url>/2020/05/13/LeetCode-7/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zigzag-conversion</span><br></pre></td></tr></table></figure>
<p>#整数反转<br>##题目内容<br>    给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。<br>##示例<br>###示例 1<br>    输入: 123<br>    输出: 321<br>###示例 2<br>    输入: -123<br>    输出: -321<br>###示例 3<br>    输入: 120<br>    输出: 21<br>注意：<br>    假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。<br>##思路1-逆序取值<br>    不断取出原整数的最后一个数位<br>##代码1<br>    public static int reverse(int x) {<br>        int result=0;<br>        int flag=x&gt;0?1:-1;<br>            x=Math.abs(x);<br>            while(x&gt;0){<br>                if(result&gt;214748364){<br>                    return 0;<br>                }else if(result==214748364){<br>                    if((x&gt;7&amp;&amp;flag==1)||(flag==-1&amp;&amp;x&gt;8)){<br>                        return 0;<br>                    }<br>                }<br>                result=result<em>10+(x%10);<br>                x/=10;<br>            }<br>        return flag</em>result;<br>    }<br>###时间复杂度：O(n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-简单</category>
        <category>数学</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-4</title>
    <url>/2020/05/10/LeetCode-4/</url>
    <content><![CDATA[<p>###4. 寻找两个正序数组的中位数<br>##题目：<br>    给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。</p>
<pre><code>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。</code></pre><p>##示例 1</p>
<pre><code>nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0</code></pre><p>##示例 2</p>
<pre><code>nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5</code></pre><p>##思路<br>    将所有数字存储到一个数组中，然后根据中位数的求法求中位数。<br>##代码</p>
<pre><code>public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int i=0,j=0,time=0;
        int totalNum=nums1.length+nums2.length;
        int[] nums=new int[totalNum];
        while(i&lt;nums1.length&amp;&amp;j&lt;nums2.length){
            if(i==nums1.length||j==nums2.length){
                break;
            }else{
                if(nums1[i]&lt;=nums2[j]){
                    nums[time++]=nums1[i++];
                }else{
                    nums[time++]=nums2[j++];
                }
            }
        }
        while(i&lt;nums1.length){
            nums[time++]=nums1[i++];
        }
        while(j&lt;nums2.length){
            nums[time++]=nums2[j++];
        }
        if(totalNum%2==0){
            return (nums[totalNum&gt;&gt;1]+nums[(totalNum&gt;&gt;1)-1])/2.0;
        }else{
            return nums[totalNum&gt;&gt;1]/1.0;
        }
}</code></pre>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-困难</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-5</title>
    <url>/2020/05/10/LeetCode-5/</url>
    <content><![CDATA[<p>#最长回文子串<br>##题目<br>    给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br>##示例<br>    ###示例 1</p>
<pre><code>输入: &quot;babad&quot;
输出: &quot;bab&quot;
注意: &quot;aba&quot; 也是一个有效答案。

###示例 2

输入: &quot;cbbd&quot;
输出: &quot;bb&quot;</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;longest-palindromic-substring</span><br></pre></td></tr></table></figure>
<p>##思路1-中心扩展法<br>    从左向右，选定一个字符，然后根据两边可扩展的回文字符串的最大长度，作为该字符所能构建的最大的回文字符串，<br>    用一个方法返回该长度，并与上一个长度比较，进行相应的记录。</p>
<pre><code>注意：在求解过程中，基数的回文子串与偶数的回文子串是不一样的。比如最长回文子串为aba，对称中心就是b，如果
最长回文子串为abba，则对称中心应该为两个b之间.</code></pre><p>##代码1<br>    class Solution {<br>        public String longestPalindrome(String s) {<br>            if(s.length()&lt;1||s==null){//首先判断特殊情况<br>                return “”;<br>            }<br>            int len1=0;<br>            int len2=0;<br>            int maxLength=0,start=0,end=0;<br>            for(int i=0;i&lt;s.length();i++){<br>                len1=expend(s,i,i);//如果回文子串字符数是奇数<br>                len2=expend(s,i,i+1);//如果回文子串字符数是偶数<br>                maxLength=Math.max(len1, len2);<br>                if(maxLength&gt;(end-start)){<br>                    start=i-((maxLength-1)&gt;&gt;1);<br>                    end=i+(maxLength&gt;&gt;1);<br>                }<br>            }<br>            return s.substring(start,end+1);</p>
<pre><code>    }
    public int expend(String s,int left,int right){
        while(left&gt;-1&amp;&amp;right&lt;s.length()&amp;&amp;s.charAt(left)==s.charAt(right)){
            right++;
            left--;
        }
        return right-left-1;
    }
}</code></pre><p>###时间复杂度：O(n^2)<br>##思路2-Manacher<br>    该算法实质上是中心扩展方法的变质，只不过将中心扩展方法求以一个字符为中心向左右两边扩展的方法利用了此<br>    字符之前的其他字符求的辅助长度：详细见连接：<a href="https://www.cxyxiaowu.com/2665.html" title="马拉车算法详解">https://www.cxyxiaowu.com/2665.html</a><br>##代码1<br>        public class Five_Manacher {<br>        /**<br>         *<br>         * @param s 要添加分隔符的字符串<br>         * @return r.toString() 添加之后的字符串<br>         <em>/<br>        private String addBoundaries(String s){<br>            StringBuilder r=new StringBuilder();<br>            for (char c : s.toCharArray()) {<br>                r.append(“#”+c);<br>            }<br>            r.append(“#”);<br>            return r.toString();<br>        }<br>        public String longestPalindrome(String s) {<br>            if(s==null||s.length()==0){<br>                return “”;<br>            }<br>            //得到处理之后的字符串（恒为奇数个字符）,此处要保留原字符串<br>            String str=addBoundaries(s);<br>            //新字符串的长度<br>            int nLen=s.length()</em>2+1;<br>            //辅助数组<br>            int p[]= new int[nLen];<br>            //最大回文字符串中心 ，最右边界<br>            int center=0,maxRight=0;<br>            //最大回文字符串的长度<br>            int maxLen=1;<br>            //结果字符串的起点<br>            int start=0;<br>            int left,right,mirror;<br>            char[]chs=str.toCharArray();<br>            for(int i=0;i&lt;nLen;i++){<br>                if(i&lt;maxRight){//当前字符在最右回文边界左边，可以直接利用镜像字符的辅助数组值<br>                    mirror=2*center-i;<br>                    p[i] = (maxRight - i)&gt;p[mirror]?p[mirror]:(maxRight - i);<br>                }<br>                //防止maxRight-i的长度等于p[mirror],<br>                //那么就是因为左边的字符而停止扩展回文字符串的，就该继续扩展<br>                left=i-p[i]-1;//目前到达的左边回文字符串的位置<br>                right=i+p[i]+1;//目前到达的右边回文字符串的位置<br>                while(left&gt;=0&amp;&amp;right&lt;nLen&amp;&amp;chs[left]==chs[right]){<br>                    left–;<br>                    right++;<br>                    p[i]++;<br>                }<br>                if(i+p[i]&gt;maxRight){//可能会更新最右边界<br>                    maxRight=i+p[i];<br>                    center=i;<br>                }<br>                if(p[i]&gt;maxLen){//最长回文字符串的长度，要实时更新<br>                    maxLen=p[i];<br>                    start=(i&gt;&gt;1)-(maxLen&gt;&gt;1);//i/2代表的是去掉分隔符起始字符的位置，maxLen/2代表将此处回文字符串中分隔符去掉<br>                }<br>            }<br>            return s.substring(start,start+maxLen);<br>        }<br>    }<br>###时间复杂度：O(n)<br>##思路3（最优解）<br>##代码3<br>        class Solution {<br>         int start = 0;<br>        int end = 0;</p>
<pre><code>    public String longestPalindrome(String s) {
        if(s.length() == 0 || s == null)  return &quot;&quot;;
        char []c = s.toCharArray();
        longestPalindrome(c,0);    
        return s.substring(start, end+1);
    }

    public void longestPalindrome(char [] c, int index) {
        if(index&gt;=c.length-1) return;

        int cur_start = index;

        int cur_end = index;

        while(cur_end&lt;c.length-1&amp;&amp;c[cur_end]==c[cur_end+1])
            cur_end++;

        index = cur_end;

        while(cur_start&gt;0&amp;&amp;cur_end&lt;c.length-1&amp;&amp;c[cur_start-1]==c[cur_end+1]) {
            cur_start--;
            cur_end++;
        }

        if(cur_end-cur_start &gt; end-start) {
            start = cur_start;
            end = cur_end;
        }
        longestPalindrome(c,index+1);
    }
}</code></pre>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>LeetCode-中等</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
